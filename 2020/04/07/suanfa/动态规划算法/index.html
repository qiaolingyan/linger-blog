<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="qiao">
    
    <title>
        
            动态规划算法 |
        
        Qiao
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/img.jpg">
    <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/css/font-awesome.min.css">
    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"zh","path":"search.json"};
    KEEP.theme_config = {"toc":{"enable":true,"number":true,"expand_all":false,"init_open":false},"style":{"primary_color":"#0066CC","avatar":"/images/img.jpg","favicon":"/images/img.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":true},"code_copy":{"enable":true,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":true},"version":"3.4.3"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                Qiao
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/categories"
                            >
                                CATEGORIES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/tags"
                            >
                                TAGS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/links"
                            >
                                LINKS
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                ABOUT
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/categories">CATEGORIES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/tags">TAGS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/links">LINKS</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">ABOUT</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">动态规划算法</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/img.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">qiao</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;2020-04-07 21:55:14
    </span>
    
        <span class="article-categories article-meta-item">
            <i class="fas fa-folder"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/categories/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fas fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/%E7%AE%97%E6%B3%95/">算法</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h3 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h3><p>​     一般满足以下条件之一，大概率就是 <strong>动态规划</strong> 题目</p>
<ul>
<li>求最大值，最小值</li>
<li>判断方案是否可行</li>
<li>统计方案个数</li>
</ul>
<h4 id="动态规划问题性质"><a href="#动态规划问题性质" class="headerlink" title="动态规划问题性质"></a>动态规划问题性质</h4><pre><code>* 重叠子问题
* 
</code></pre>
<h4 id="动态规划固定流程"><a href="#动态规划固定流程" class="headerlink" title="动态规划固定流程"></a>动态规划固定流程</h4><pre><code>* 递归的暴力解法
* 带备忘录的递归解法
* 非递归的动态规划解法
</code></pre>
<h4 id="案例1：斐波那契数列"><a href="#案例1：斐波那契数列" class="headerlink" title="案例1：斐波那契数列"></a>案例1：斐波那契数列</h4><p>数列：0、1、1、2、3、5、8、13、21、34、…、n-2、n-1、n-2+n-1</p>
<ol>
<li><p>暴力的递归算法</p>
<p><strong>递归算法的时间复杂度</strong></p>
<p>子问题个数乘以解决一个子问题需要的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function fib(n) &#123;</span><br><span class="line">  if(n &lt;= 0) return 0</span><br><span class="line">  if(n &lt;= 2) return 1</span><br><span class="line">  return fib(n - 1) + fib(n - 2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>递归树</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E9%80%92%E5%BD%92.png"
                      alt="斐波那契"
                ></p>
<ul>
<li><strong>递归算法的时间复杂度</strong> —– 子问题个数乘以解决一个子问题需要的时间<ol>
<li>子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 <strong>O(2^n)</strong></li>
<li>解决一个子问题的时间，在本算法中，没有循环，只有 f(n-1) + f(n-2) 一个加法操作，时间为<strong>O(1)</strong></li>
<li>所以这个算法的时间复杂度为 **O(2^n)，指数级别</li>
</ol>
</li>
</ul>
<ol start="2">
<li>带备忘录的递归解法</li>
</ol>
<p>造一个备忘录，每次算出某个子问题的答案后先记到 备忘录 里再返回，每个遇到一个子问题先去 备忘录 里查一查</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fib2(n) &#123;</span><br><span class="line">  if(n &lt; 1) return 0</span><br><span class="line">  let arr = new Array(n + 1)</span><br><span class="line">  return helper(arr,n)</span><br><span class="line">&#125;</span><br><span class="line">function helper(arr,n) &#123;</span><br><span class="line">  if(n &lt;= 2) return 1</span><br><span class="line">  if(arr[n]) return arr[n]</span><br><span class="line">  arr[n] = helper(arr, n - 1) + helper(arr, n - 2)</span><br><span class="line">  return arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递归树</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E5%A4%87%E5%BF%98%E5%BD%95%E9%80%92%E5%BD%92.png"
                      alt="斐波那契"
                ></p>
</li>
<li><p><strong>时间复杂度</strong></p>
<ol>
<li>子问题个数，由于本算法中不存在冗余计算，子问题就是f(1),f(2),f(3)…f(n),数量和输入规模成正比，所以子问题个数为<strong>O(n)</strong></li>
<li>解决一个子问题的时间，没有循环，时间为**O(1)</li>
<li>所以本算法的时间复杂度是**O(n)</li>
</ol>
</li>
<li><p>带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做【自顶向下】，动态规划叫做【自底向上】</p>
<ol>
<li>【自顶向下】是从上向下延伸，都是从一个规模较大的原问题比如说 f(20),向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案</li>
<li>【自底向上】直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20),这就是动态规划的思路，所以动态规划一般脱离了递归，由循环迭代完成计算</li>
</ol>
</li>
</ul>
<ol start="3">
<li>动态规划</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fib3(n) &#123;</span><br><span class="line">  let arr = new Array(n + 1)</span><br><span class="line">  arr[0] = 0</span><br><span class="line">  arr[1] = arr[2] = 1</span><br><span class="line">  for(let i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">    arr[i] = arr[i-1] + arr[i-2]</span><br><span class="line">  &#125;</span><br><span class="line">  return arr[n]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>树</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"
                      alt="斐波那契-动态规划"
                ></p>
</li>
<li><p><strong>动态转移方程–暴力解</strong></p>
<p>把 f(n) 想做一个状态 n,这个状态 n 是由状态 n-1 和状态 n-2 相加转移而来，这就叫状态转移</p>
</li>
</ul>
<ol start="4">
<li>动态规划优化</li>
</ol>
<p>当前状态只和之前的两个状态有关，所以不需要那么长的arr 来存储所有状态，只要想办法存储之前的两个状态就行了，所以可以进一步优化，把空间复杂度降为  <strong>O(1)</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fib4(n) &#123;</span><br><span class="line">  if(n &lt; 2) return n</span><br><span class="line">  let pre = 0</span><br><span class="line">  let cur = 1</span><br><span class="line">  for(let i = 0; i &lt; n - 1; i++)&#123;</span><br><span class="line">    let sum = pre + cur</span><br><span class="line">    pre = cur</span><br><span class="line">    cur = sum</span><br><span class="line">  &#125;</span><br><span class="line">  return cur</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="案例2：凑零钱问题"><a href="#案例2：凑零钱问题" class="headerlink" title="案例2：凑零钱问题"></a>案例2：凑零钱问题</h4><p>题目：给你 k 种面值的硬币，面值分为 c1,c2,…ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1</p>
<p>比如，，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。</p>
<p>​    这个时候我们分别假设 1，2，5 三种面值的币分别为最后一个硬币的情况：</p>
<ul>
<li><p>最后一枚硬币的面额为 1: min = f(11-1) + 1</p>
</li>
<li><p>最后一枚硬币的面额为 2: min = f(11-2) + 1</p>
</li>
<li><p>最后一枚硬币的面额为 5: min = f(11-5) + 1</p>
<p>f(11) = min( f(11-1),f(11-2),f(11-5) ) + 1</p>
<ul>
<li>f(n) = min{f(n-1), f(n-5), f(n-11)} + 1</li>
<li>f(n-1) = min{f(n-1-1), f(n-1-5), f(n-1-11)} + 1</li>
</ul>
</li>
</ul>
<ol>
<li><p>暴力解法-递归</p>
<ul>
<li><strong>最优子结构</strong>，子问题间必须互相独立</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function coin(coins, amount) &#123;</span><br><span class="line">  if(amount === 0) return 0</span><br><span class="line">  let min = Number.MAX_SAFE_INTEGER</span><br><span class="line">  for(let i of coins)&#123;</span><br><span class="line">    if(amount - i &lt; 0) continue</span><br><span class="line">    min = Math.min(coin(coins,amount - i),min)</span><br><span class="line">  &#125;</span><br><span class="line">  return min + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递归树</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E5%87%91%E9%9B%B6%E9%92%B1-%E9%80%92%E5%BD%92.png"
                      alt="凑零钱-递归"
                ></p>
</li>
<li><p>时间复杂度</p>
<ol>
<li>子问题总数，<strong>O(n^k)</strong></li>
<li>每个子问题中含有一个for循环，复杂度为 <strong>O(k)</strong></li>
<li>所以总时间复杂度为 <strong>O(k*n^k)</strong></li>
</ol>
</li>
</ul>
<ol start="2">
<li>带备忘录的递归算法</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function coin2(coins, amount) &#123;</span><br><span class="line">  let arr = new Array(amount + 1)</span><br><span class="line">  return coinHelper(coins, amount,arr)</span><br><span class="line">&#125;</span><br><span class="line">function coinHelper(coins, amount,arr) &#123;</span><br><span class="line">  if(amount === 0) return 0</span><br><span class="line">  if(arr[amount]) return arr[amount]</span><br><span class="line">  let min = Number.MAX_SAFE_INTEGER</span><br><span class="line">  for(let i of coins)&#123;</span><br><span class="line">    if(amount - i &lt; 0) continue</span><br><span class="line">    min = Math.min(coinHelper(coins, amount-i,arr),min)</span><br><span class="line">  &#125;</span><br><span class="line">  arr[amount] = min + 1</span><br><span class="line">  return arr[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>动态规划</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function coin3(coins, amount) &#123;</span><br><span class="line">  let arr = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER)</span><br><span class="line">  arr[0] = 0</span><br><span class="line">  for(let i = 1; i &lt;= amount; i++)&#123;</span><br><span class="line">    for(let j of coins)&#123;</span><br><span class="line">      if(i &lt; j) continue</span><br><span class="line">      arr[i] = Math.min(arr[i-j],arr[i])+1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>树</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E5%87%91%E9%9B%B6%E9%92%B1-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"
                      alt="凑零钱-动态规划"
                ></p>
</li>
</ul>
</li>
</ol>
<h4 id="案例3：双蛋问题"><a href="#案例3：双蛋问题" class="headerlink" title="案例3：双蛋问题"></a>案例3：双蛋问题</h4><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E5%8F%8C%E8%9B%8B.png"
                      alt="双蛋问题"
                ></p>
<ol>
<li><p>递归解法</p>
<p>假设从 i 层开始扔鸡蛋</p>
<p>f(还要尝试的楼层，剩下的鸡蛋)</p>
<pre><code>* 鸡蛋碎了 f(i-1,e-1) 
* 鸡蛋没碎 f(f-i,e)
* max(f(i-1,e-1),  f(f-i,e)) + 1
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function egg(f,e) &#123;</span><br><span class="line">  if(f &lt;= 1 || e === 1) return f</span><br><span class="line">  let min = Number.MAX_SAFE_INTEGER</span><br><span class="line">  for(let i = 1; i &lt;= f; i++)&#123;</span><br><span class="line">    min = Math.min(Math.max(egg(i-1,e-1),egg(f-i,e))+1,min)</span><br><span class="line">  &#125;</span><br><span class="line">  return min</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>递归树</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E5%8F%8C%E8%9B%8B%E6%A0%91.png"
                      alt="img"
                ></p>
</li>
</ul>
</li>
<li><p>动态规划</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E5%8F%8C%E8%9B%8B-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png"
                      alt="img"
                ></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function egg2(f,e) &#123;</span><br><span class="line">  if(f &lt;= 1 || e === 1) return f</span><br><span class="line">  // 二维数组,初始填充0</span><br><span class="line">  let arr = Array.from(new Array(f+1), () =&gt; new Array(e + 1).fill(0))</span><br><span class="line">  // 边界处理，只有一个鸡蛋，i 层就要扔 i 次</span><br><span class="line">  for(let i = 1; i &lt;= f; i++)&#123;</span><br><span class="line">    arr[i][1] = i</span><br><span class="line">  &#125;</span><br><span class="line">  // 边界处理，只有一层，i不论多少个鸡蛋，只要扔一次</span><br><span class="line">  for(let j = 1; j &lt;= e; j++)&#123;</span><br><span class="line">    arr[1][j] = 1</span><br><span class="line">  &#125;</span><br><span class="line">  for(let i = 2; i &lt;= f; i++)&#123;</span><br><span class="line">    for(let j = 2; j &lt;= e; j++)&#123;</span><br><span class="line">      let min = Number.MAX_SAFE_INTEGER</span><br><span class="line">      for(let k = 1; k &lt; i; k++)&#123;</span><br><span class="line">        min = Math.min(Math.max(arr[k-1][j-1],arr[i-k][j])+1,min)</span><br><span class="line">      &#125;</span><br><span class="line">      arr[i][j] = min</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return arr[f][e]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="案例4：石头游戏"><a href="#案例4：石头游戏" class="headerlink" title="案例4：石头游戏"></a>案例4：石头游戏</h4><p>题目：你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。</p>
<p>石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 piles = [1, 100, 3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。</p>
<p>假设两人都很聪明，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。</p>
<p>这样推广之后，这个问题算是一道 Hard 的动态规划问题了。博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？</p>
<p>还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。</p>
<h5 id="一、定义-dp-数组的含义"><a href="#一、定义-dp-数组的含义" class="headerlink" title="一、定义 dp 数组的含义"></a>一、定义 dp 数组的含义</h5><p>定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。</p>
<p>介绍 dp 数组的含义之前，我们先看一下 dp 数组最终的样子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E7%9F%B3%E5%A4%B4-1.png"
                      alt="img"
                ></p>
<p>下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 <code>dp[1][3].fir = 10，dp[0][1].sec = 3</code>。</p>
<p>先回答几个读者可能提出的问题：</p>
<p>这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。</p>
<p><strong>以下是对 dp 数组含义的解释：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。</span><br><span class="line">dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。</span><br><span class="line"></span><br><span class="line">举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始</span><br><span class="line">dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。</span><br><span class="line">dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 <code>dp[0][n-1].fir - dp[0][n-1].sec</code>，即面对整个 piles，先手的最优得分和后手的最优得分之差。</p>
<h5 id="二、状态转移方程"><a href="#二、状态转移方程" class="headerlink" title="二、状态转移方程"></a>二、状态转移方程</h5><p>写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。</p>
<p>根据前面对 dp 数组的定义，<strong>状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j][fir or sec]</span><br><span class="line">其中：</span><br><span class="line">0 &lt;= i &lt; piles.length</span><br><span class="line">i &lt;= j &lt; piles.length</span><br></pre></td></tr></table></figure>

<p>对于这个问题的每个状态，可以做的选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。 我们可以这样穷举所有状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">n = piles.length</span><br><span class="line">for 0 &lt;= i &lt; n:</span><br><span class="line">    for j &lt;= i &lt; n:</span><br><span class="line">        for who in &#123;fir, sec&#125;:</span><br><span class="line">            dp[i][j][who] = max(left, right)</span><br></pre></td></tr></table></figure>

<p>上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？</p>
<p>根据我们对 dp 数组的定义，很容易解决这个难点，<strong>写出状态转移方程：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)</span><br><span class="line">dp[i][j].fir = max(选择最左边的石头堆, 选择最右边的石头堆)</span><br><span class="line"> # 解释：我作为先手，面对 piles[i...j] 时，有两种选择：</span><br><span class="line"> # 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j]</span><br><span class="line"> # 但是此时轮到对方，相当于我变成了后手；</span><br><span class="line"> # 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1]</span><br><span class="line"> # 但是此时轮到对方，相当于我变成了后手。</span><br><span class="line"></span><br><span class="line">if 先手选择左边:</span><br><span class="line">dp[i][j].sec = dp[i+1][j].fir</span><br><span class="line">if 先手选择右边:</span><br><span class="line">dp[i][j].sec = dp[i][j-1].fir</span><br><span class="line"># 解释：我作为后手，要等先手先选择，有两种情况：</span><br><span class="line"># 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]</span><br><span class="line"># 此时轮到我，我变成了先手；</span><br><span class="line"># 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]</span><br><span class="line"># 此时轮到我，我变成了先手。</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>根据 dp 数组的定义，我们也可以找出 base case，也就是最简单的情况：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j].fir = piles[i]</span><br><span class="line">dp[i][j].sec = 0</span><br><span class="line">其中 0 &lt;= i == j &lt; n</span><br><span class="line"># 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]</span><br><span class="line"># 那么显然先手的得分为 piles[i]</span><br><span class="line"># 后手没有石头拿了，得分为 0</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>



<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E7%9F%B3%E5%A4%B4-2.png"
                      alt="img"
                ></p>
<p>这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 <code>dp[i+1][j] 和 dp[i][j-1]：</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E7%9F%B3%E5%A4%B4-3.png"
                      alt="img"
                ></p>
<p>所以说算法不能简单的一行一行遍历 dp 数组，而要<strong>斜着遍历数组：</strong></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E7%9F%B3%E5%A4%B4-4.png"
                      alt="img"
                ></p>
<p>说实话，斜着遍历二维数组说起来容易，你还真不一定能想出来怎么实现，不信你思考一下？这么巧妙的状态转移方程都列出来了，要是不会写代码实现，那真的很尴尬了。。。</p>
<h5 id="三、代码实现"><a href="#三、代码实现" class="headerlink" title="三、代码实现"></a>三、代码实现</h5><p>如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 <code>dp[n][n][2]</code>，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Pair &#123;</span><br><span class="line">    int fir, sec;</span><br><span class="line">    Pair(int fir, int sec) &#123;</span><br><span class="line">        this.fir = fir;</span><br><span class="line">        this.sec = sec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>然后直接把我们的状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/* 返回游戏最后先手和后手的得分之差 */</span><br><span class="line">int stoneGame(int[] piles) &#123;</span><br><span class="line">    int n = piles.length;</span><br><span class="line">    // 初始化 dp 数组</span><br><span class="line">    Pair[][] dp = new Pair[n][n];</span><br><span class="line">    for (int i = 0; i &lt; n; i++) </span><br><span class="line">        for (int j = i; j &lt; n; j++)</span><br><span class="line">            dp[i][j] = new Pair(0, 0);</span><br><span class="line">    // 填入 base case</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        dp[i][i].fir = piles[i];</span><br><span class="line">        dp[i][i].sec = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    // 斜着遍历数组</span><br><span class="line">    for (int l = 2; l &lt;= n; l++) &#123;</span><br><span class="line">        for (int i = 0; i &lt;= n - l; i++) &#123;</span><br><span class="line">            int j = l + i - 1;</span><br><span class="line">            // 先手选择最左边或最右边的分数</span><br><span class="line">            int left = piles[i] + dp[i+1][j].sec;</span><br><span class="line">            int right = piles[j] + dp[i][j-1].sec;</span><br><span class="line">            // 套用状态转移方程</span><br><span class="line">            if (left &gt; right) &#123;</span><br><span class="line">                dp[i][j].fir = left;</span><br><span class="line">                dp[i][j].sec = dp[i+1][j].fir;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i][j].fir = right;</span><br><span class="line">                dp[i][j].sec = dp[i][j-1].fir;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Pair res = dp[0][n-1];</span><br><span class="line">    return res.fir - res.sec;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。</p>
<p>而且，注意到计算 <code>dp[i][j] </code>只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。</p>
<h5 id="四、最后总结"><a href="#四、最后总结" class="headerlink" title="四、最后总结"></a>四、最后总结</h5><p>本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。</p>
<p>之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。这种角色转换使得我们可以重用之前的结果，典型的动态规划标志。</p>
<p>读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。dp 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。</p>
<h5 id="3-动态规划设计方法：归纳思想"><a href="#3-动态规划设计方法：归纳思想" class="headerlink" title="3. 动态规划设计方法：归纳思想"></a>3. 动态规划设计方法：归纳思想</h5><p>了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。</p>
<p>最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。</p>
<p>先看一下题目，很容易理解：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97.png"
                      alt="img"
                ></p>
<p>注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。</p>
<p><strong>动态规划解法</strong> 动态规划的核心设计思想是<strong>数学归纳法</strong>。</p>
<p>相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;nk&lt;n 时成立，然后想办法证明 k=nk=n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。</p>
<p>类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 dp[0…i-1]dp[0…i−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？</p>
<p>直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？</p>
<p><strong>我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。</strong></p>
<p>举两个例子：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%972.png"
                      alt="img"
                ></p>
<p>算法演进的过程是这样的，：</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%973.png"
                      alt="img"
                ></p>
<p>根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int res = 0;</span><br><span class="line">for (int i = 0; i &lt; dp.size(); i++) &#123;</span><br><span class="line">    res = Math.max(res, dp[i]);</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure>

<p>读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？</p>
<p>这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：</p>
<p>我们已经知道了 dp[0…4]dp[0…4] 的所有结果，我们如何通过这些已知结果推出 dp[5]dp[5] 呢？</p>
<p>根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。</p>
<p>nums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。</p>
<p>当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./img/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%973"
                      alt="img"
                ></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">    if (nums[i] &gt; nums[j]) </span><br><span class="line">        dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？</p>
<p>类似数学归纳法，你已经可以算出 dp[5] 了，其他的就都可以算出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">        if (nums[i] &gt; nums[j]) </span><br><span class="line">            dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>还有一个细节问题，dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    int[] dp = new int[nums.length];</span><br><span class="line">    // dp 数组全都初始化为 1</span><br><span class="line">    Arrays.fill(dp, 1);</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[j]) </span><br><span class="line">                dp[i] = Math.max(dp[i], dp[j] + 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; dp.length; i++) &#123;</span><br><span class="line">        res = Math.max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的<strong>设计流程：</strong></p>
<p><strong>首先明确 dp 数组所存数据的含义</strong>。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。</p>
<p><strong>然后根据 dp 数组的定义，运用数学归纳法的思想</strong>，假设 dp[0…i-1]dp[0…i−1] 都已知，想办法求出 dp[i]dp[i]，一旦这一步完成，整个题目基本就解决了。</p>
<p>但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p>
<p><strong>最后想一想问题的 base case 是什么，以此来初始化 dp 数组</strong>,以保证算法正确运行。</p>

        </div>

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/2021/05/14/js/%E9%97%AD%E5%8C%85/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">闭包</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
            </div>
        

        
            <div class="comment-container">
                <div class="comments-container">
    <div id="comment-anchor"></div>
    <div class="comment-area-title">
        <i class="fas fa-comments">&nbsp;Comments</i>
    </div>
    

        
            
    <div id="gitalk-container"></div>
    <script data-pjax
            src="//cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js"></script>
    <script data-pjax>

        function loadGitalk() {
            let __gitalk__pathname = decodeURI(location.pathname);
            const __gitalk__pathnameLength = __gitalk__pathname.length;
            const __gitalk__pathnameMaxLength = 50;
            if (__gitalk__pathnameLength > __gitalk__pathnameMaxLength) {
                __gitalk__pathname = __gitalk__pathname.substring(0, __gitalk__pathnameMaxLength - 3) + '...';
            }

            try {
                Gitalk && new Gitalk({
                    clientID: 'd497aebd1393e4084852',
                    clientSecret: 'fe2df06d7885541a3c098ad225dc39c6d64dc5f6',
                    repo: 'blog-issues',
                    owner: 'qiaolingyan',
                    admin: ['qiaolingyan'],
                    id: __gitalk__pathname,
                    language: 'zh'
                }).render('gitalk-container');

            } catch (e) {
                window.Gitalk = null;
            }
        }

        if ('true') {
            const loadGitalkTimeout = setTimeout(() => {
                loadGitalk();
                clearTimeout(loadGitalkTimeout);
            }, 1000);
        } else {
            window.addEventListener('DOMContentLoaded', loadGitalk);
        }
    </script>



        
    
</div>

            </div>
        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2021</span>&nbsp;-&nbsp;
            
            2021&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">qiao</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.3</a>
        </div>
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
            <li class="go-comment">
                <i class="fas fa-comment"></i>
            </li>
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95"><span class="nav-number">1.</span> <span class="nav-text">动态规划算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98%E6%80%A7%E8%B4%A8"><span class="nav-number">1.1.</span> <span class="nav-text">动态规划问题性质</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9B%BA%E5%AE%9A%E6%B5%81%E7%A8%8B"><span class="nav-number">1.2.</span> <span class="nav-text">动态规划固定流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B1%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">案例1：斐波那契数列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B2%EF%BC%9A%E5%87%91%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98"><span class="nav-number">1.4.</span> <span class="nav-text">案例2：凑零钱问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B3%EF%BC%9A%E5%8F%8C%E8%9B%8B%E9%97%AE%E9%A2%98"><span class="nav-number">1.5.</span> <span class="nav-text">案例3：双蛋问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%88%E4%BE%8B4%EF%BC%9A%E7%9F%B3%E5%A4%B4%E6%B8%B8%E6%88%8F"><span class="nav-number">1.6.</span> <span class="nav-text">案例4：石头游戏</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AE%9A%E4%B9%89-dp-%E6%95%B0%E7%BB%84%E7%9A%84%E5%90%AB%E4%B9%89"><span class="nav-number">1.6.1.</span> <span class="nav-text">一、定义 dp 数组的含义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%96%B9%E7%A8%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">二、状态转移方程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="nav-number">1.6.3.</span> <span class="nav-text">三、代码实现</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E6%9C%80%E5%90%8E%E6%80%BB%E7%BB%93"><span class="nav-number">1.6.4.</span> <span class="nav-text">四、最后总结</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95%EF%BC%9A%E5%BD%92%E7%BA%B3%E6%80%9D%E6%83%B3"><span class="nav-number">1.6.5.</span> <span class="nav-text">3. 动态规划设计方法：归纳思想</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>



<script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/utils.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/main.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/header-shrink.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/back2top.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/dark-light-toggle.js"></script>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/local-search.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/code-copy.js"></script>



    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/lazyload.js"></script>


<div class="post-scripts pjax">
    
        <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/left-side-toggle.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/toc.js"></script>
    
</div>


    <script src="//cdn.jsdelivr.net/npm/hexo-theme-keep@3.4.3/source/js/libs/pjax.min.js"></script>
<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
