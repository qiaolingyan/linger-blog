[{"url":"/2021/06/22/webpack/webpack5%E6%96%B0%E7%89%B9%E6%80%A7/","content":""},{"url":"/2021/06/22/%E5%8D%9A%E5%AE%A2/postman%E4%BD%BF%E7%94%A8/","content":""},{"url":"/2021/06/22/%E6%8A%80%E5%B7%A7/","content":"创建一个都是 0 的二维数组（Array.from()回调函数使用)Array.from(new Array(f+1), () =&gt; new Array(e + 1).fill(0))\n浅拷贝 slice()jsonpArray = jsonpArray.slice();\n查看vue的webpack配置vue inspect &gt; output.js\nctrl + k + 0\n处理时间和日期的 js 库dayjs 更轻量\nmomentjs\n将 markdown 格式转换为 htmlMarkdownIt\n启动一个服务http-server\nnpm i -g http-server\n\nhttp-server -c-1\n\n\n\n连接\n阮一峰 es6 https://es6.ruanyifeng.com/#docs/decorator\nTypeScript 英文：https://www.typescriptlang.org/\nTypeScript 中文：https://www.tslang.cn/\nvue-property-decrator 使vue-class-component装饰器使用简单点：https://github.com/kaorun343/vue-property-decorator\n\nvscode 快捷键ctrl+K ctrl+[ 折叠本级\nctrl+K ctrl+] 取消折叠本级\nctrl+K ctrl+0 折叠全部\nctrl+K ctrl+J 取消折叠全部\nvue 深度选择器::v-deep\n请求参数为 multipart/form-data 类型处理需要提交 FormData 数据对象\nasync handleUpload(options: any) &#123;    const fd = new FormData()    fd.append(&#x27;file&#x27;, options.file)    const &#123; data &#125; = await upload(fd)    if (data.code === &#x27;000000&#x27;) &#123;    &#125;&#125;\n\n\n\n富文本编辑器\nwangeditor https://www.wangeditor.com/\n基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。\n\nTinyMCE https://www.tiny.cloud/docs/demo/full-featured/\nTinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。\n\n百度ueditor https://github.com/fex-team/ueditor\nUEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了\n\nkindeditor http://kindeditor.net/demo.php\n界面经典。\n\nTextbox https://www.textbox.io/\nTextbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。\n\nCKEditor https://ckeditor.com/ckeditor-5/demo/\n国外的，界面美观。\n\nquill https://quilljs.com/\n功能强大，还可以编辑公式等\n\nmedium-editor https://yabwe.github.io/medium-editor/\nhttps://github.com/yabwe/medium-editor\n\nsimditor https://simditor.tower.im/\n界面美观，功能较全。（个人博客考虑使用）\n\n**summernote **https://summernote.org/\nUI好看，精美\n\njodit https://xdsoft.net/jodit/\n功能齐全\n\nEditor.md https://pandao.github.io/editor.md/\n功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费\n\nfroala Editorhttps://froala.com/wysiwyg-editor/\n界面非常好看，功能非常强大，非常好用（非免费，可破解）\n\nsyncfusion https://ej2.syncfusion.com/react/demos/#/material/rich-text-editor/tools\n\ndhtmlxEditor https://dhtmlx.com/docs/products/dhtmlxRichText/\n\nbootstrap-wysiwyg https://www.zybuluo.com/mdeditor\nbootstrap-wysiwyg是基于Bootstrap的轻型、免费开源的富文本编辑器，界面简洁大方。使用需要先引入bootstrap。\n\neWebEditor http://www.ewebeditor.net/demo/\neWebEditor外观和使用风格都和微软 Word很类似，功能很多。工具条可以定制，运行速度很快。导入文件接口很多，支持word、excel、pdf、ppt直接导入，目前版本不支持代码高亮，不适合纯技术平台使用，适合内容编辑人员使用\n\n\n比较推荐：不在维护的项目不介意使用\n\nCKEditor\nquill\nmedium-editor\nwangeditor\nueditor\ntinymce\n\n图片压缩插件compressorjs https://fengyuanchen.github.io/compressorjs/\niview 多级表头动态展示"},{"url":"/2021/06/22/js/ES%E6%96%B0%E7%89%B9%E6%80%A7/","content":"let 和 const\nvar \n声明提升，使用undefined初始化\n全局作用域\n可以仅声明不初始化\n可以重复定义\n可以多次赋值\n可以声明前访问\n\n\nlet\n不存在变量提升，会存入暂时性死区\n块级作用域\n可以仅声明不初始化\n不可以重复定义\n可以多次赋值\n不可以声明前访问（Cannot access ‘tmp’ before initialization）\n\n\nconst\n不存在变量提升，会存入暂时性死区\n块级作用域\n必须在声明时初始化\n不可以重复定义\n基本数据类型不可以，引用数据类型仅可以改变值\n不可以声明前访问（Cannot access ‘tmp’ before initialization）\n\n\n\nArrow functions1、箭头函数特点\n\n箭头函数没有自己的this，箭头函数的this不是调用的时候决定的，而是在定义的时候处在的对象就是它的this\n箭头函数没有自己的arguments，指向离它最近包裹它的函数的arguments\n箭头函数没有显示原型属性\n箭头函数不能new调用\n\nClasses（类）\n实例方法\n静态方法\n类的继承\n\nclass Person1 &#123;  // 当前类型的构造函数,this为当前实例对象  constructor(name)&#123;    this.name = name  &#125;  // 实例方法 调用：this.say()  say()&#123;    console.log(`hi,my name is $&#123;this.name&#125;`)  &#125;  // 静态方法 调用：Person1.create(&#x27;tom&#x27;)  // 静态方法里的this不会指向实例对象，而是指向Person  static create(name)&#123;    return new Person1(name)  &#125;&#125;class Students extends Person1&#123;  constructor(name,number)&#123;    super(name)  // 继承父类的属性    this.number = number  &#125;  hello()&#123;    super.say() // 调用父类的方法    console.log(`my school number is $&#123;this.number&#125;`)  &#125;&#125;const s = new Students(&#x27;jack&#x27;,&#x27;100&#x27;)s.hello()\nPromisesGeneratorsModulesTemplate literals（模板字⾯量）\n普通模板字符串\nconst str = `hello es2015,this is a \\`string\\`` //支持转义const str1 = `hello es2015,  this is a \\`string\\``    // 可直接换行const name1 = &#x27;tom&#x27;const msg = `hey,$&#123;name1&#125; -- $&#123;1+2&#125; -- $&#123;Math.random()&#125;`  // 支持变量及数学运算\n带标签的模板字符串\nconst name2 = &#x27;tom&#x27;const gender = truefunction myTagFunc(strings,name,gender) &#123;  // 对模板字符串进行分割,根据$&#123;&#125;  console.log(strings,name,gender)  // strings:[ &#x27;hey,&#x27;, &#x27; is a &#x27;, &#x27;&#x27; ] ---  name:&#x27;tom&#x27; ---gender:true  const sex = gender ? &#x27;boy&#x27; : &#x27;girl&#x27;  return strings[0] + name + strings[1] + sex + strings[2]&#125;const result = myTagFunc`hey,$&#123;name2&#125; is a $&#123;gender&#125;`console.log(result)  // hey,tom is a boy\n\nDefault parameters（默认参数）Enhanced object literals（对象字⾯量增强）Destructuring assignments（解构分配）Spread operator（展开操作符）Symbol\n用途\n作为对象的属性，可以作为对象的私有属性\n阻止对象上属性名的冲突，每个Symbol都独一无二的，可以保证不与其他属性名产生冲突\n使用Symbol来代替常量for … of 循环Map 和 SetProxy浅拷贝与深拷贝\n\n\n浅拷贝：针对Object,Array这种复杂数据类型，浅拷贝复制一层对象的属性，属性中的值是基本数据类型直接复制值，如果是引用数据类型复制内存地址的指针，所以在修改复制后的变量里引用类型的里面的值时，会导致原始数据也被修改\nObject.assign({},target)\n\n\n深拷贝：针对Object,Array这种复杂数据类型，深拷贝递归复制了所有的层级，新数据和原始数据不存在联系，因此在修改复制后的变量里引用类型的里面的值时，不会导致原始数据也被修改\nJSON.parse(JSON.stringfy())\n\n\n\n"},{"title":"js操作符","url":"/2021/05/18/js/js%E6%93%8D%E4%BD%9C%E7%AC%A6/","content":"这些 JS 中强大的操作符，总有几个你没听说过\\1. 数值分割符 _\n\\2. 逗号运算符 ,\n\\3. 零合并操作符 ??\n\\4. 可选链操作符 ?.\n\\5. 私有方法/属性\n\\6. 位运算符 &gt;&gt; 与 &gt;&gt;&gt;\n\\7. 位运算符 &amp; 与 |\n\\8. 双位运算符 ~~\n\\9. 短路运算符 &amp;&amp; 与 ||\n\\10. void 运算符\n\\11. 其他常用操作符\n\\12. 操作符优先级\nJS 里的操作符大家每天都在使用，还有一些 ES2020、ES2021 新加的实用操作符，这些共同构成了 JS 灵活的语法生态。\n本文除介绍常用的操作符之外，还会介绍 JS 里一些不常用但是很强大的操作符，下面我们一起来看看吧～\n1. 数值分割符 _ES2021 引入了数值分割符 _，在数值组之间提供分隔，使一个长数值读起来更容易。Chrome 已经提供了对数值分割符的支持，可以在浏览器里试起来。\nlet number = 100_0000_0000_0000 // 0太多了不用数值分割符眼睛看花了console.log(number)             // 输出 100000000000000\n\n此外，十进制的小数部分也可以使用数值分割符，二进制、十六进制里也可以使用数值分割符。\n0x11_1 === 0x111// true 十六进制0.11_1 === 0.111// true 十进制的小数0b11_1 === 0b111// true 二进制\n\n2. 逗号运算符 ,什么，逗号也可以是运算符吗？是的，曾经看到这样一个简单的函数，将数组的第一项和第二项调换，并返回两项之和：\nfunction reverse(arr) &#123;    return [arr[0], arr[1]]=[arr[1], arr[0]], arr[0] + arr[1]&#125;const list = [1, 2]reverse(list)   // 返回 3，此时 list 为[2, 1]\n\n逗号操作符对它的每个操作数求值（从左到右），并返回最后一个操作数的值。\nexpr1, expr2, expr3...\n\n会返回最后一个表达式 expr3 的结果，其他的表达式只会进行求值。\n3. 零合并操作符 ??零合并操作符 ?? 是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回右侧操作数，否则返回左侧操作数。\nexpr1 ?? expr2\n\n空值合并操作符一般用来为常量提供默认值，保证常量不为 null 或者 undefined，以前一般使用 || 来做这件事 variable = variable || &#39;bar&#39;。然而，由于 || 是一个布尔逻辑运算符，左侧的操作数会被强制转换成布尔值用于求值。任何假值（0， &#39;&#39;， NaN， null， undefined）都不会被返回。这导致如果你使用 0、&#39;&#39;、NaN 作为有效值，就会出现不可预料的后果。\n正因为 || 存在这样的问题，而 ?? 的出现就是解决了这些问题，?? 只会在左侧为 undefined、null 时才返回后者，?? 可以理解为是 || 的完善解决方案。\n可以在浏览器中执行下面的代码感受一下：\nundefined || &#x27;default&#x27;// &#x27;default&#x27;null || &#x27;default&#x27;// &#x27;default&#x27;false || &#x27;default&#x27;// &#x27;default&#x27;0 || &#x27;default&#x27;// &#x27;default&#x27;undefined ?? &#x27;default&#x27;// &#x27;default&#x27;null ?? &#x27;default&#x27;// &#x27;default&#x27;false ?? &#x27;default&#x27;// &#x27;false&#x27;0 ?? &#x27;default&#x27;// 0\n\n另外在赋值的时候，可以运用赋值运算符的简写 ??=\nlet a = &#123;b: null, c: 10&#125;a.b ??= 20a.c ??= 20console.log(a)     // 输出 &#123; b: 20, c: 10 &#125;\n\n4. 可选链操作符 ?.可选链操作符 ?. 允许读取位于连接对象链深处的属性的值，而不必验证链中的每个引用是否有效。?. 操作符的功能类似于 . 链式操作符，不同之处在于，在引用为 null 或者 undefined 的情况下不会引起错误，该表达式短路返回值是 undefined。\n当尝试访问可能不存在的对象属性时，可选链操作符将会使表达式更短、更简明。\nconst obj = &#123;  a: &#x27;foo&#x27;,  b: &#123;    c: &#x27;bar&#x27;  &#125;&#125;console.log(obj.b?.c)      // 输出 barconsole.log(obj.d?.c)      // 输出 undefinedconsole.log(obj.func?.())  // 不报错，输出 undefined\n\n以前可能会通过 obj &amp;&amp; obj.a &amp;&amp; obj.a.b 来获取一个深度嵌套的子属性，现在可以直接 obj?.a?.b 即可。\n可选链除了可以用在获取对象的属性，还可以用在数组的索引 arr?.[index]，也可以用在函数的判断 func?.(args)，当尝试调用一个可能不存在的方法时也可以使用可选链。\n调用一个对象上可能不存在的方法时（版本原因或者当前用户的设备不支持该功能的场景下），使用可选链可以使得表达式在函数不存在时返回 undefined 而不是直接抛异常。\nconst result = someInterface.customFunc?.()\n\n5. 私有方法/属性在一个类里面可以给属性前面增加 # 私有标记的方式来标记为私有，除了属性可以被标记为私有外，getter/setter 也可以标记为私有，方法也可以标为私有。\nclass Person &#123;  getDesc()&#123;     returnthis.#name +&#x27; &#x27;+ this.#getAge()  &#125;    #getAge()&#123; returnthis.#age &#125; // 私有方法  get #name()&#123; return&#x27;foo&#x27; &#125; // 私有访问器  #age = 23// 私有属性&#125;const a = new Person()console.log(a.age)       // undefined 直接访问不到console.log(a.getDesc()) // foo 23\n\n6. 位运算符 &gt;&gt; 与 &gt;&gt;&gt;有符号右移操作符 &gt;&gt; 将第一个操作数向右移动指定的位数，多余的位移到右边被丢弃，高位补其符号位，正数补 0，负数则补 1。因为新的最左位与前一个最左位的值相同，所以符号位（最左位）不会改变。\n(0b111&gt;&gt;1).toString(2)   // &quot;11&quot;(-0b111&gt;&gt;1).toString(2)  // &quot;-100&quot; 感觉跟直觉不一样\n\n正数的好理解，负数怎么理解呢，负数在计算机中存储是按照补码来存储的，补码的计算方式是取反加一，移位时将补码形式右移，最左边补符号位，移完之后再次取反加一求补码获得处理后的原码。\n-111// 真值10000111// 原码（高位的0无所谓，后面加不到）11111001// 补码11111100// 算数右移10000100// 移位后求补码获得原码-100// 移位后的真值\n\n一般我们用 &gt;&gt; 来将一个数除 2，相当于先舍弃小数位然后进行一次 Math.floor：\n10 &gt;&gt; 1// 513 &gt;&gt; 1// 6 相当于13.9 &gt;&gt; 1// 6-13 &gt;&gt; 1// -7 相当于-13.9 &gt;&gt; 1// -7\n\n无符号右移操作符 &gt;&gt;&gt;，将符号位作为二进制数据的一部分向右移动，高位始终补 0，对于正整数和算数右移没有区别，对于负数来说由于符号位被补 0，成为正数后就不用再求补码了，所以结果总是非负的。即便右移 0 个比特，结果也是非负的。\n(0b111&gt;&gt;&gt;1).toString(2)   // &quot;11&quot;(-0b111&gt;&gt;&gt;1).toString(2)  // &quot;1111111111111111111111111111100&quot;\n\n可以这样去理解\n-111// 真值1000000000000000000000000000111// 原码1111111111111111111111111111001// 补码0111111111111111111111111111100// 算数右移（由于右移后成为正数，就不要再求补码了）1073741820// 移位后的真值\n\n左移运算符 &lt;&lt; 与之类似，左移很简单左边移除最高位，低位补 0：\n(0b1111111111111111111111111111100&lt;&lt;1).toString(2)   // &quot;-1000&quot;(0b1111111111111111111111111111100&lt;&lt;&lt;1).toString(2)  // &quot;-1000&quot;\n\n\nPS：JS 里面没有无符号左移，而且其他语言比如 JAVA 也没有无符号左移。\n\n7. 位运算符 &amp; 与 |位运算符是按位进行运算，&amp; 与、| 或、~ 非、^ 按位异或：\n&amp;: 1010  |: 1010  ~: 1010  ^: 1010   011001100110   ----     ----     ----     ----   0010111001011100\n\n使用位运算符时会抛弃小数位，我们可以利用这个特性来给数字取整，比如给任意数字 &amp; 上二进制的 32 个 1，或者 | 上 0，显而易见后者简单些。\n所以我们可以对一个数字 | 0 来取整，负数也同样适用\n1.3 | 0// 1-1.9 | 0// -1\n\n判断奇偶数除了常见的取余 % 2 之外，也可以使用 &amp; 1，来判断二进制数的最低位是不是 1，这样除了最低位之外都被置 0，取余的结果只剩最低位，是不是很巧妙。负数也同样适用：\nconst num = 3!!(num &amp; 1)                    // true!!(num % 2)                    // true\n\n8. 双位运算符 ~~可以使用双位操作符来替代正数的 Math.floor( )，替代负数的 Math.ceil( )。双否定位操作符的优势在于它执行相同的操作运行速度更快。\nMath.floor(4.9) === 4// true// 简写为：~~4.9 === 4// true\n\n不过要注意，对正数来说 ~~ 运算结果与 Math.floor( ) 运算结果相同，而对于负数来说与 Math.ceil( ) 的运算结果相同：\n~~4.5// 4Math.floor(4.5)      // 4Math.ceil(4.5)       // 5 ~~-4.5// -4Math.floor(-4.5)     // -5Math.ceil(-4.5)      // -4\n\n\nPS：注意 ~~(num/2) 方式和 num &gt;&gt; 1 在值为负数时的差别\n\n9. 短路运算符 &amp;&amp; 与 ||我们知道逻辑与 &amp;&amp; 与逻辑或 || 是短路运算符，短路运算符就是从左到右的运算中前者满足要求，就不再执行后者了。\n可以理解为：\n\n&amp;&amp; 为取假运算，从左到右依次判断，如果遇到一个假值，就返回假值，以后不再执行，否则返回最后一个真值\n|| 为取真运算，从左到右依次判断，如果遇到一个真值，就返回真值，以后不再执行，否则返回最后一个假值\n\nlet param1 = expr1 &amp;&amp; expr2let param2 = expr1 || expr2\n\n短路运算符\n因此可以用来做很多有意思的事，比如给变量赋初值：\nlet variable1let variable2 = variable1  || &#x27;foo&#x27;\n\n如果 variable1 是真值就直接返回了，后面短路就不会被返回了，如果为假值，则会返回后面的foo。\n也可以用来进行简单的判断，取代冗长的if语句：\nlet variable = param &amp;&amp; param.prop// 有了可选链之后可以直接 param?.prop\n\n如果 param 如果为真值则返回 param.prop 属性，否则返回 param 这个假值，这样在某些地方防止 param 为 undefined 的时候还取其属性造成报错。\n10. void 运算符void` 运算符 对给定的表达式进行求值，然后返回 `undefined\n\n可以用来给在使用立即调用的函数表达式（IIFE）时，可以利用 void 运算符让 JS 引擎把一个 function 关键字识别成函数表达式而不是函数声明。\nfunction iife() &#123; console.log(&#x27;foo&#x27;) &#125;()       // 报错，因为JS引擎把IIFE识别为了函数声明voidfunction iife() &#123; console.log(&#x27;foo&#x27;) &#125;()  // 正常调用~function iife() &#123; console.log(&#x27;foo&#x27;) &#125;()      // 也可以使用一个位操作符(function iife() &#123; console.log(&#x27;foo&#x27;) &#125;)()     // 或者干脆用括号括起来表示为整体的表达式\n\n还可以用在箭头函数中避免传值泄漏，箭头函数，允许在函数体不使用括号来直接返回值。这个特性给用户带来了很多便利，但有时候也带来了不必要的麻烦，如果右侧调用了一个原本没有返回值的函数，其返回值改变后，会导致非预期的副作用。\nconst func = () =&gt;void customMethod()   // 特别是给一个事件或者回调函数传一个函数时\n\n安全起见，当不希望函数返回值是除了空值以外其他值，应该使用 void 来确保返回 undefined，这样，当 customMethod 返回值发生改变时，也不会影响箭头函数的行为。\n11. 其他常用操作符\n三元表达式：很简单了，大家经常用，expr ? expr1 : expr2 如果 expr 为真值则返回 expr1，否则返回 expr2\n赋值运算符简写：加法赋值 +=、减法赋值 -=、乘法赋值 *=、除法赋值 /=、求幂赋值 **=、按位或复制 |=、按位与赋值 &amp;=、有符号按位右移赋值 &gt;&gt;=、无符号按位右移赋值 &gt;&gt;&gt;=、逻辑空赋值 ??= ….\n求幂运算符：var1 ** var2 相当于 Math.pow，结果为 var1 的 var2 次方\n\n12. 操作符优先级正因为有操作符优先级，所以 variable = 1, 2 的含义是将变量先赋值为 1，再返回数字 2，而不是变量赋值给 1, 2 的返回值 2，这是因为 = 运算符的优先级高于 , 逗号运算符。再比如表达式 6 - 2 * 3 === 0 &amp;&amp; 1，- * === &amp;&amp; 这四个运算符优先级最高的 * 先运算，然后 - 运算符结果为 0，=== 运算符优先级高于 &amp;&amp; 而 true &amp;&amp; 1 的结果为 1，所以这就是运算的结果。\n\n\n\n优先级\n运算类型\n关联性\n运算符\n\n\n\n21\n圆括号\nn/a（不相关）\n（）\n\n\n20\n成员访问\n从左到右\na.b.c\n\n\n20\n需计算的成员访问\n从左到右\na[b]\n\n\n20\nnew(带参数列表)\nn/a\nnew fn()\n\n\n20\n函数调用\n从左到右\nfn()\n\n\n20\n可选链\n从左到右\n?.\n\n\n19\nnew (无参数列表)\n从右到左\nnew fn\n\n\n18\n后置递增（运算符在后）\nn/a\na++\n\n\n18\n后置递减（运算符在后）\nn/a\na–\n\n\n17\n逻辑非\n从右到左\n!\n\n\n17\n按位非\n从右到左\n~\n\n\n17\n一元加法、一元减法\n从右到左\n+ 2、- 2\n\n\n17\n前置递增、前置递减\n从右到左\n++a  –a\n\n\n17\ntypeof\n从右到左\ntypeof\n\n\n17\nvoid\n从右到左\nvoid\n\n\n17\ndelete\n从右到左\ndelete\n\n\n17\nawait\n从右到左\nawait\n\n\n16\n幂\n从右到左\n2**4\n\n\n15\n乘法、除法、取模\n从左到右\n*    /   %\n\n\n14\n加法、减法\n从左到右\n1 + 2    2 - 1\n\n\n13\n按位左移、按位右移\n从左到右\n&lt;&lt;   、 &gt;&gt;\n\n\n13\n无符号右移\n从左到右\n&gt;&gt;&gt;\n\n\n12\n小于、小于等于、大于、大于等于\n从左到右\n&lt; 、&lt;=、&gt;、&gt;=\n\n\n12\nin\n从左到右\nin\n\n\n12\ninstanceof\n从左到右\ninstanceof\n\n\n11\n等号、非等号、全等号、非全等号\n从左到右\n== 、!= 、 === 、!==\n\n\n10\n按位与\n从左到右\n&amp;\n\n\n9\n按位异或\n从左到右\n^\n\n\n8\n按位或\n从左到右\n|\n\n\n7\n逻辑与\n从左到右\n&amp;&amp;\n\n\n6\n逻辑或\n从左到右\n||\n\n\n5\n空值合并\n从左到右\n??\n\n\n4\n条件运算符\n从右到左\n？ ：\n\n\n3\n赋值\n从右到左\n\n\n\n2\nyield\n从右到左\nyield\n\n\n2\nyield*\n从右到左\nyield*\n\n\n1\n展开运算符\nn/a\n…\n\n\n0\n逗号\n从左到右\n,\n\n\n\n\n\n\n\n\n","categories":["js"],"tags":["js","操作符"]},{"title":"js方法手写","url":"/2021/05/14/js/js%E6%96%B9%E6%B3%95%E6%89%8B%E5%86%99/","content":"函数柯里化数组mapfilterreduceeverysomefindflat图片图片懒加载图片预加载节流 &amp; 防抖节流防抖call, apply, bingcallapplybindnewinstanceof封装数据类型函数记忆函数1判断是否存在循环引用1深浅拷贝浅拷贝深拷贝promiseasync-await订阅发布单例模式Object.createes6 的 classcompose 组合函数异步函数异步并行函数异步串行函数私有变量的实现","categories":["js"],"tags":["js","函数手写"]},{"url":"/2021/06/22/js/promise/","content":"手写promise\nPromise就是一个类，在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行\nPromise 中有三种状态，分别为 fulfilled 成功、rejected 失败、pending 等待\n\n\n pending -&gt; fulfilled\npending -&gt; rejected\n一旦状态确定就不可更改\n\n\nresolve和reject函数是用来更改状态的\n\n\nresolve: fulfilled\nreject: rejected\n\n\nthen 方法内部做的事情就判断状态，如果是成功，调用成功的回调函数，如果状态是失败，调用失败的回调函数，then方法是被定义在原型对象中的\nthen成功回调有一个参数，表示成功之后的值，then失败回调有一个参数表示失败后的原因\n同一个promise对象下面的then方法是可以被调用多次的\nthen方法是可以被链式调用的，后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值\n\n/*  1. Promise 就是一个类 在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行  2. Promise 中有三种状态 分别为 成功 fulfilled 失败 rejected 等待 pending    pending -&gt; fulfilled    pending -&gt; rejected    一旦状态确定就不可更改  3. resolve和reject函数是用来更改状态的    resolve: fulfilled    reject: rejected  4. then方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败 调用失败回调函数 then方法是被定义在原型对象中的  5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因  6. 同一个promise对象下面的then方法是可以被调用多次的  7. then方法是可以被链式调用的, 后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值*/// 定义状态常量，使编辑器可以自动提醒const PENDING  = &#x27;pending&#x27;const FULFILLED = &#x27;fulfilled&#x27;const REJECTED = &#x27;rejected&#x27;class MyPromise &#123;  PromiseState = PENDING  // 对象状态  PromiseResult = null  // 对象结果    tmpFulfilled = [] // 暂存成功回调  tmpRejected = [] // 暂存失败回调    // 构造方法，new 的时候自动执行  constructor(executor)&#123;    try&#123;      executor(this.resolve,this.reject)    &#125;catch(e)&#123;      this.reject(e) // 异常时设为失败状态    &#125;  &#125;    // 设置成功状态，结果，因为是直接调用，所以箭头函数使其this指向MyPromise实例  resolve = value =&gt; &#123;    // 如果状态不为待定，则函数直接返回，确保状态不可逆    if(this.PromiseState !== PENDING) return    this.PromiseState = FULFILLED    this.PromiseResult = value    // 设置成功状态时，循环执行暂存的成功回调函数（promise可以多次then调用）    while (this.tmpFulfilled.length) this.tmpFulfilled.shift()()  &#125;  // 设置失败状态，结果  resolve = reason =&gt; &#123;    if(this.PromiseState !== PENDING) return    this.PromiseState = REJECTED    this.PromiseResult = reason    while (this.tmpRejected.length) this.tmpRejected.shift()()  &#125;    then(onFulfilled,onRejected)&#123;    // 参数不是函数时，给默认值    onFulfilled = typeof onFulfilled === &#x27;function&#x27; ? onFulfilled : value =&gt; value    onRejected = typeof onRejected === &#x27;function&#x27; ? onRejected : reason =&gt; &#123;throw reason&#125;    const thenPromise = new MyPromise((resolve,reject) =&gt; &#123;      let resolvePromise = cb =&gt; &#123;        // 创建一个微任务        queueMicrotask(() =&gt; &#123;          try&#123;            let x = cb(this.PromiseResult)            if(x === thenPromise)&#123;              return reject(new TypeError(&#x27;Chaining cycle detected for promise #&lt;Promise&gt;&#x27;))            &#125;            if(x instanceof MyPromise)&#123;              x.then(val =&gt; &#123;                resolvePromise(() =&gt; val)              &#125;,reason =&gt; &#123;                resolvePromise(() =&gt; reason)              &#125;)            &#125;else&#123;              resolve(x)            &#125;          &#125;catch(e)&#123;            reject(e)          &#125;        &#125;)      &#125;            if(this.PromiseState === FULFILLED)&#123;        resolvePromise(onFulfilled)      &#125;else if(this.PromiseState === REJECTED)&#123;        resolvePromise(onRejected)      &#125;else&#123;        this.tmpFulfilled.push(resolvePromise.bind(this,onFulfilled))        this.tmpRejected.push(resolvePromise.bind(this,onRejected))      &#125;    &#125;)    return thenPromise  &#125;    static all(arr)&#123;    const result = []    let count = 0    return new MyPromise((resolve, reject) =&gt; &#123;      let addData = (i,val) =&gt; &#123;        result[i] = val        count++        if(count === arr.length) resolve(result)      &#125;      arr.forEach((item,index) =&gt; &#123;        if(item instanceof MyPromise)&#123;          item.then(val =&gt; addData(index,val),reject)        &#125;else&#123;          addData(index,item)        &#125;      &#125;)    &#125;)  &#125;    static race(arr)&#123;    return new MyPromise((resolve,reject) =&gt; &#123;      arr.forEach(item =&gt; &#123;        if(item instanceof MyPromise)&#123;          item.then(resolve,reject)        &#125;else&#123;          queueMicrotask(() =&gt; &#123;            resolve(item)          &#125;)        &#125;      &#125;)    &#125;)  &#125;    static resolve(param)&#123;    if(param instanceof MyPromise) return param    return new MyPromise(resolve =&gt; resolve(param))  &#125;    static reject(param)&#123;    return new MyPromise((resolve,reject) =&gt; reject(param))  &#125;    finally(callback)&#123;    /*return this.then(v =&gt; &#123;      return MyPromise      .resolve(callback())      .then (() =&gt; v)    &#125;, r =&gt; &#123;      return MyPromise      .resolve(callback())      .then (() =&gt; &#123; throw r &#125;)    &#125;)*/        let x = typeof callback === &#x27;function&#x27; ? callback() : callback    return MyPromise.resolve(x).then(() =&gt; this,reason =&gt; &#123;throw reason&#125;)  &#125;    catch(onRejected)&#123;    return this.then(undefined,onRejected)  &#125;&#125;MyPromise.deferred = function () &#123;  var result = &#123;&#125;  result.promise = new MyPromise(function (resolve,reject) &#123;    result.resolve = resolve    result.reject = reject  &#125;)  return result&#125;module.exports = MyPromise\n"},{"url":"/2021/06/22/js/%E5%87%BD%E5%AD%90/","content":"函子（Functor）\n容器：包含值和值得变形关系（这个变形关系就是函数）\n函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理（变形关系）class Container &#123;  static of(value)&#123;    return new Container(value)  &#125;  constructor(value)&#123;    this._value = value  &#125;  map(fn)&#123;    return Container.of(fn(this._value))  &#125;&#125;Container.of(3)  .map(x =&gt; x + 2)  .map(x =&gt; x * x)\n总结\n函数式编程的运算不能直接操作值，而是由函子完成\n函子就是一个实现了map契约的对象\n我们可以把函子想象成一个盒子，这个盒子里封装了一个值\n想要处理盒子中的值，我们需要给盒子的map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理\n最终map方法返回一个新值的盒子（函子）\n如果传入 null 或者 undefined 会报错MayBe函子\n\n\nMayBe函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）\n缺点：不能确认是哪一步产生的空值问题class MayBe &#123;  static of(value)&#123;    return new MayBe(value)  &#125;  constructor(value)&#123;    this._value = value  &#125;  map(fn)&#123;    return this.isNothing() ? MayBe.of(null) : MayBe.of(fn(this._value))  &#125;  isNothing()&#123;    return this._value === null || this._value === undefined  &#125;&#125;MayBe.of(null)  .map(x =&gt; x.toUpperCase())\nEither函子\n两者中的任何一个，类似于 if … else … 的处理\n异常会让函数变的不纯，Either函子可以用来做异常处理class Left &#123;  static of(value)&#123;    return new Left(value)  &#125;  constructor(value)&#123;    this._value = value  &#125;  map(fn)&#123;    return this  &#125;&#125;class Right &#123;  static of(value)&#123;    return new Right(value)  &#125;  constructor(value)&#123;    this._value = value  &#125;  map(fn)&#123;    return Right.of(fn(this._value))  &#125;&#125;// Either用来处理异常function parseJSON(json) &#123;  try&#123;    return Right.of(JSON.parse(json))  &#125;catch(e)&#123;    return Left.of(&#123;error: e.message&#125;)  &#125;&#125;let r = parseJSON(&#x27;&#123;&quot;name&quot;:&quot;zs&quot;&#125;&#x27;)          .map(x =&gt; x.name.toUpperCase())\nIO函子\nIO函子中的_value 是一个函数，这里是把函数作为值来处理\nIO函子可以把不纯的动作存储到_value中，延迟执行这个不纯的操作（惰性执行），包装当前的操作\n把不纯的操作交给调用者来处理const fp = require(&#x27;lodash/fp&#x27;)class IO &#123;  static of (x) &#123;    return new IO(function () &#123;      return x    &#125;)  &#125;  constructor (fn) &#123;    this._value = fn  &#125;  map (fn) &#123;// 把当前的 value 和 传入的 fn 组合成一个新的函数    return new IO(fp.flowRight(fn, this._value))  &#125;&#125;let io = IO.of(process).map(p =&gt; p.execPath)console.log(io._value())\nTask异步执行\nfoktale,一个标准的函数式编程库\n只提供了一些函数式处理的操作，例如：compose，curry等。一些函子 Task、Either、MayBe等const &#123; task &#125; = require(&#x27;folktale/concurrency/task&#x27;)function readFile(filename) &#123;  return task(resolver =&gt; &#123;    fs.readFile(filename, &#x27;utf-8&#x27;, (err, data) =&gt; &#123;      if (err) resolver.reject(err)      resolver.resolve(data)    &#125;)  &#125;)&#125;// 调用 run 执行readFile(&#x27;package.json&#x27;).map(split(&#x27;\\n&#x27;)).map(find(x =&gt; x.includes(&#x27;version&#x27;))).run().listen(&#123;  onRejected: err =&gt; &#123;    console.log(err)  &#125;,  onResolved: value =&gt; &#123;    console.log(value)  &#125;&#125;)\nPointed函子\n\n\nPointed函子是实现了of静态方法的函子\nof方法是为了避免使用new来创建对象，更深层的含义是of方法用来把值放到上下文Context(把值放到容器中，使用map来处理值)class Container &#123;  static of (value) &#123;    return new Container(value)  &#125;&#125;Contanier.of(2).map(x =&gt; x + 5)\nMonad函子\nMonad函子是可以变扁的Pointed函子，IO(IO(X))\n一个函子如果具有join和of两个方法并遵守一些定律就是一个Monadconst fp = require(&#x27;lodash/fp&#x27;)// IO Monadclass IO &#123;  static of (x) &#123;    return new IO(function () &#123;      return x    &#125;)  &#125;  constructor (fn) &#123;    this._value = fn  &#125;  map (fn) &#123;    return new IO(fp.flowRight(fn, this._value))  &#125;  join () &#123;    return this._value()  &#125;  flatMap (fn) &#123;    return this.map(fn).join()  &#125;&#125;let r = readFile(&#x27;package.json&#x27;).map(fp.toUpper).flatMap(print).join()\n\n函数式编程指北函数式编程入门Pointfree 编程风格指南图解 MonadFunctors, Applicatives, And Monads In Pictures\n"},{"url":"/2021/06/22/js/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","content":"函数式编程什么是函数式编程\n函数式编程（Functional Programming,FP),FP是编程范式之一。\n\n面向对象：把现实世界中的事物抽象成程序世界中的类和对象，用过封装、继承和多态来演示事物事件的联系。\n\n函数式编程：把现实世界的事物与事物之间的联系抽象到程序世界（对运算过程进行抽象）\n\n程序的本质：根据输入通过某种运算获得相应的输出，程序开发过程中会涉及很多有输入和输出的函数\nx -&gt; f(联系、映射) -&gt; y，y=f(x)\n函数式编程中的函数指的不是程序中的函数(方法)，而是数学中的函数即映射关系，例如：y= sin(x)，x和y的关系\n相同的输入始终要得到相同的输出(纯函数)\n函数式编程用来描述数据(函数)之间的映射\n\n\n函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）\n\n我们可以把一个函数的执行结果交给另一个函数去处理\n// 非函数式let num1 = 2let num2 = 3let sum = num1 + num2console.log(sum)// 函数式function add (n1, n2) &#123;  return n1 + n2&#125;let sum = add(2, 3)console.log(sum)\n函数是一等公民\n函数可以存储在变量中\n\n函数可以作为参数\n\n函数可以作为返回值\nconst BlogController = &#123;  index (posts) &#123; return Views.index(posts) &#125;&#125;// 优化const BlogController = &#123;  index: Views.index&#125;\n\n高阶函数\n可以把函数作为参数传递给另一个函数\n可以把函数作为另一个函数的返回值\n常用高阶函数\nforEach\nmap\nfilter\nevery\nsome\nfind/findIndex\nreduce\nsort\n\n\n使用高阶函数的意义\n抽象可以帮我们屏蔽细节，只需要关注于我们的目标\n高阶函数可以用来抽象通用的问题// forEachfunction forEach(arr, fn) &#123;  for(let i = 0, len = arr.length; i &lt; len; i++)&#123;    fn(arr[i])  &#125;&#125;// filterfunction filter(arr, fn) &#123;  let results = []  for(let i = 0, len = arr.length; i &lt; len; i++)&#123;    if(fn(arr[i]))&#123;      results.push(arr[i])    &#125;  &#125;  return results&#125;// mapfunction map(arr, fn) &#123;  let results = []  for(let value of arr)&#123;    results.push(fn(value))  &#125;  return results&#125;// everyfunction every(arr, fn) &#123;  let result = true  for(let value of arr)&#123;    result = fn(value)    if(!result) break  &#125;  return result&#125;// somefunction some(arr, fn) &#123;  let result = false  for(let value of arr)&#123;    result = fn(value)    if(result) break  &#125;  return result&#125;// oncefunction once(fn) &#123;  let done = false  return function () &#123;    if(!done)&#123;      done = true      return fn.apply(this,arguments)    &#125;  &#125;&#125;\n\n\n\n闭包\n闭包：函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包\n可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域中的成员\n\n\n闭包的本质：函数在执行的时候会放到一个执行栈上，当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问到外部函数的成员\n产生：\n函数嵌套\n内部函数引用外部函数局部变量\n执行外部函数\n\n\n作用：\n延长局部变量的生命周期\n让函数外面操作（读/写）函数内部的数据\n\n\n缺点：容易导致内存泄漏var a = [];for(var i = 0; i &lt; 10; i++) &#123;  a[i] = ((i) =&gt; &#123;    return function() &#123;      console.log(i)    &#125;  &#125;)(i)&#125;a[6]()\n节流与防抖\n节流（滚轮事件），在单位时间内让函数只调用一次，是第一次生效\n防抖（下拉选模糊查询），在单位时间内让函数只调用一次，是最后一次生效// 节流function throtte(fn, time) &#123;  let startTime = 0  return function () &#123;    const endTime = Date.now()    if(endTime - startTime &gt;= time)&#123;      fn.apply(this,arguments)      startTime = endTime    &#125;  &#125;&#125;// 防抖function debounce(fn, time) &#123;  let timer = null  return function () &#123;    clearTimeout(timer)    const args = arguments    timer = setTimeout(() =&gt; &#123;      fn.apply(this.args)    &#125;)  &#125;&#125;\n\n\n\n函数柯里化\n当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不变）\n然后返回一个新的函数接收剩余的参数，返回结果\n作用：\n参数复用，减少重复传递不变的参数（利用事件闭包原理，让前面传输过来的参数不要被释放掉）\n延迟计算，节流 防抖\n提前确认（用来对浏览器兼容性作出一些判断，比如事件绑定）\n\n\n实现// 函数柯里化function curry(fn) &#123;  return function curriedFn(...args) &#123;    if(args.length &lt; fn.length)&#123;      return function (...args2) &#123;        return curriedFn(...args,...args2)      &#125;    &#125;else&#123;      return fn(...args)    &#125;  &#125;&#125;function add(a, b, c) &#123;  return a + b + c&#125;let addCurry = curry(add)console.log(addCurry(1)(2,3))console.log(addCurry(1,2,3))console.log(addCurry(1)(2)(3))\nfunction curry2() &#123;  let data = [...arguments]  function tmp(...args) &#123;    data = [...data,...args]    return tmp  &#125;  tmp.toString = function () &#123;    return data.reduce((pre,cur) =&gt; pre + cur,0)  &#125;  return tmp&#125;curry2(1)curry2(1,4)(2)curry2(1,4,3,4)\n优点：\n柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数\n这是一种对函数参数的缓存\n让函数变的更灵活，让函数的粒度更小\n可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能\n\n\n\n纯函数\n相同的输入永远会得到相同的输出，而且没有任何可观察的副作用\n数组的 slice 和 splice 分别是：纯函数和不纯的函数\nslice 返回数组中的指定部分，不会改变原数组\nsplice 对数组进行操作返回该数组，会改变原数组\n\n\n优点：\n可缓存：因为纯函数对相同的输入始终得到相同的结果，所以可以把纯函数的结果缓存起来// memorize记忆函数function memorize(f) &#123;  let cache = &#123;&#125;  return function () &#123;    let arg_str = JSON.stringify(arguments)    cache[arg_str] = cache[arg_str] || f.apply(f,arguments)    return cache[arg_str]  &#125;&#125;\n可测试\n并行处理\n在多线程环境下并行操作共享的内存数据可能会出现意外情况\n纯函数不需要访问共享的内存数据，所以在并行环境下可以任意运行纯函数（Web Worker)\n\n\n\n\n副作用\n如果函数依赖于外部的状态就无法保证输出相同，就会带来副作用\n\n\n\n函数组合（compose)\n函数组合：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数\n函数组合默认从右到左执行\n函数的组合要满足结合律\n\n\nlodash中组合函数有 flow() 与 flowRight()\nflow 从左到右运行\nflowRight 从右向左运行// lodash const _ = require(&#x27;lodash&#x27;) const f = _.flowRight(_.toUpper, _.first, _.reverse)  // 模拟实现lodash的flowRight方法 function compose(...fns) &#123;   return function (value) &#123;     return fns.reverse().reduce((pre,cur) =&gt; cur(pre),value)   &#125; &#125;  // 调试 const trace = curry((tag, v) =&gt; &#123;   console.log(tag, v)   return v &#125;)  const f = compose(first,trace(&#x27;reverse&#x27;),reverse) console.log(f([&#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;]))\nlodash\n\n\n\nconst _ = require(‘lodash)\nPonit Free\n我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。\n不需要指明需要处理的数据\n只需要合成运算过程\n需要定义一些辅助的基本运算函数const fp = require(&#x27;lodash/fp&#x27;)const firstLetterToUpper = fp.flowRight(join(&#x27;. &#x27;),fp.map(fp.flowRight(fp.first, fp.toUpper)), split(&#x27; &#x27;))console.log(firstLetterToUpper(&#x27;world wild web&#x27;))// =&gt; W. W. W\n\n\n\n"},{"url":"/2021/06/22/js/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/","content":"异步编程\nJavaScript语言的执行环境是单线程的，一次只能执行一个任务，多任务需要排队等候，这种模式可能会阻塞代码，导致代码执行效率低下。为了避免这个问题，出现了异步编程。一般是通过callback回调函数、事件发布/订阅、Promise等来组织代码，本质都是通过回调函数来实现异步代码的存放与执行线程与进程\n\n同步模式与异步模式事件循环与消息队列\nEventLoop 是一种循环机制，不断去轮询一些队列，从中找到需要执行的任务并按顺序执行的一个执行模型\n消息队列 是用来存放宏任务的队列，比如定时器时间到了，定时器内传入的方法引用会存到该队列，ajax回调之后的执行方法也会存到该队列一开始整个脚本作为一个宏任务。执行过程中同步代码直接执行，宏任务等待时间到达或者成功后，将方法的回调放入宏任务队列中，微任务进入微任务队列中。当前主线程的宏任务执行完出队，检查并清空微任务队列。接着执行浏览器UI线程的渲染工作，检查web worker任务，有则执行。然后再取出一个宏任务执行。以此循环。。。宏任务与微任务\n宏任务 可以理解为每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。浏览器为了让JS内部宏任务与DOM操作能够有序的执行，会在一个宏任务执行结束后，在下一个宏任务执行开始前，对页面进行重新渲染。\n包含：\nscript（整体代码）\nsetTimeout\nsetInterval\nI/O\nUI交互事件\nMessageChannel\n\n\n\n\n微任务 可以理解是在当前任务执行结束后需要立即执行的任务。也就是说，在当前任务后，在渲染之前，执行清空微任务。所以它的响应速度相比宏任务会更快，因为无需等待UI渲染\n包含：\nPromise.then\nMutationObserver\nprocess.nextTick(Node.js环境)\n\n\n\n\n\n异步编程几种方式// Promise chainajax(&#x27;/api/url1&#x27;)  .then(value =&gt; &#123;    return ajax(&#x27;ajax/url2&#x27;)  &#125;)  .then(value =&gt; &#123;    return ajax(&#x27;ajax/url3&#x27;)  &#125;)  .then(value =&gt; &#123;    return ajax(&#x27;ajax/url4&#x27;)  &#125;)  .catch(error =&gt; &#123;    console.error(error)  &#125;)    \n回调地狱$.get(&#x27;/url1&#x27;, function (data1) &#123;  $.get(&#x27;/url2&#x27;, data1, function (data2) &#123;    $.get(&#x27;/url3&#x27;, data2, function (data3) &#123;      $.get(&#x27;/url4&#x27;, data3, function (data4) &#123;        $.get(&#x27;/url5&#x27;, data4, function (data5) &#123;          $.get(&#x27;/url6&#x27;, data5, function (data6) &#123;            $.get(&#x27;/url7&#x27;, data6, function (data7) &#123;              // 略微夸张了一点点            &#125;)          &#125;)        &#125;)      &#125;)    &#125;)  &#125;)&#125;)\npromise\nPromise就是一个类，在执行这个类的时候，需要传递一个执行器进去，执行器会立即执行\nPromise 中有三种状态，分别为 fulfilled 成功、rejected 失败、pending 等待\n\n\n pending -&gt; fulfilled\npending -&gt; rejected\n一旦状态确定就不可更改\n\n\nresolve和reject函数是用来更改状态的\n\n\nresolve: fulfilled\nreject: rejected\n\n\nthen 方法内部做的事情就判断状态，如果是成功，调用成功的回调函数，如果状态是失败，调用失败的回调函数，then方法是被定义在原型对象中的\nthen成功回调有一个参数，表示成功之后的值，then失败回调有一个参数表示失败后的原因\n同一个promise对象下面的then方法是可以被调用多次的\nthen方法是可以被链式调用的，后面then方法的回调函数拿到值的是上一个then方法的回调函数的返回值Promise.resolve().then(() =&gt; &#123;  console.log(0)  return Promise.resolve(4)&#125;).then((res) =&gt; &#123;  console.log(res)&#125;)Promise.resolve().then(() =&gt; &#123;  console.log(1)&#125;).then(() =&gt; &#123;  console.log(2)&#125;).then(() =&gt; &#123;  console.log(3)&#125;).then(() =&gt; &#123;  console.log(5)&#125;).then(() =&gt; &#123;  console.log(6)&#125;)// 1. AB两段微任务会交替运行// 2. 执行顺序//    A段 微任务 第1个 then 输出0，返回 Promise.resolve(4)//    B段 微任务 输出1//    A段 微任务 第1个 then 无输出，判断返回值是Promise对象，得到4//    B段 微任务 输出2//    A段 微任务 第1个 then 无输出，判断返回的值4是否是 Promise 对象，执行 resolve(4)，作为A段第二个 then 的值//    B段 微任务 输出3//    A段 微任务 第2个 then 接收值4，输出值4//    B段 微任务 输出5//    A段 结束//    B段 微任务 输出6\ngenerator\n\n\n调用函数生成一个generator生成器，不会调用里边的代码\n调用next()执行，遇到yield暂停\n第一个next传值没用，第二个next传值作为第一个yield语句的返回值function * main () &#123;  try &#123;    const users = yield ajax(&#x27;/api/users.json&#x27;)    console.log(users)    const posts = yield ajax(&#x27;/api/posts.json&#x27;)    console.log(posts)    const urls = yield ajax(&#x27;/api/urls11.json&#x27;)    console.log(urls)  &#125; catch (e) &#123;    console.log(e)  &#125;&#125;function co (generator) &#123;  const g = generator()  function handleResult (result) &#123;    if (result.done) return // 生成器函数结束    result.value.then(data =&gt; &#123;      handleResult(g.next(data))    &#125;, error =&gt; &#123;      g.throw(error)    &#125;)  &#125;  handleResult(g.next())&#125;co(main)// 实现一个发号器function* createIdMaker() &#123;  let id = 1  \twhile(true)&#123;    yield id++  &#125;&#125;let idMaker = createIdMaker()console.log(idMaker.next().value)  // 1console.log(idMaker.next().value)  // 2console.log(idMaker.next().value)  // 3\nasync/awaitasync function main () &#123;  try &#123;    const users = await ajax(&#x27;/api/users.json&#x27;)    console.log(users)    const posts = await ajax(&#x27;/api/posts.json&#x27;)    console.log(posts)    const urls = await ajax(&#x27;/api/urls.json&#x27;)    console.log(urls)  &#125; catch (e) &#123;    console.log(e)  &#125;&#125;// co(main)const promise = main()promise.then(() =&gt; &#123;  console.log(&#x27;all completed&#x27;)&#125;)\n\n"},{"url":"/2021/06/22/js/%E6%8C%87%E5%BC%95/","content":"函数式编程什么是函数式编程函数是一等公民高阶函数闭包函数柯里化纯函数函数组合lodashPonit Free函子（Functor）MayBe函子Either函子IO函子Task异步执行Pointed函子Monad(单子)异步编程线程与进程同步模式与异步模式事件循环与消息队列宏任务与微任务异步编程几种方式回调地狱promisegeneratorasync/awaitES新特性let 和 constArrow functionsClasses（类）PromisesGeneratorsModulesTemplate literals（模板字⾯量）Default parameters（默认参数）Enhanced object literals（对象字⾯量增强）Destructuring assignments（解构分配）Spread operator（展开操作符）Symbolfor … of 循环Map 和 SetProxy浅拷贝与深拷贝"},{"title":"闭包","url":"/2021/05/14/js/%E9%97%AD%E5%8C%85/","content":"","categories":["js"],"tags":["js"]},{"title":"Vue-Router","url":"/2021/06/01/nodejs/nodejs%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/","content":"什么是爬虫使用程序获取并分析网页中的内容给特定业务应用使用\n可以用多中语言进行爬虫\nconst axios = require(&#x27;axios&#x27;)const cheerio = require(&#x27;cheerio&#x27;)const fs = require(&#x27;fs&#x27;)const request = axios.create(&#123;  baseURL:&#x27;https://cnodejs.org/&#x27; // 基础路径&#125;)async function main (page = 1)&#123;  const &#123; data &#125;= await request.get(`/?tab=all&amp;page=$&#123;page&#125;`)  const $ = cheerio.load(data);  const articles = []  const topics = $(&#x27;#topic_list .cell&#x27;)  // 抓取当前页面数据  for(let i = 0; i &lt; topics.length; i++)&#123;    const item = $(topics.get(i))    const title =  item.find(&#x27;.topic_title&#x27;).text()    const href = item.find(&#x27;.topic_title&#x27;).attr(&#x27;href&#x27;)    const articleContent = await getArticleContent(href)    articles.push(&#123;      title:title,      content:articleContent    &#125;)  &#125;  // fs.writeFileSync(&#x27;./data.json&#x27;,JSON.stringify(articles))  console.log(`$&#123;page&#125;页抓取`)  // 当前页面抓取完毕，查看是否有下一页，递归调用 main  fs.writeFileSync(`./data-$&#123;page&#125;.json`,JSON.stringify(articles))  if(!$(&#x27;.pagination li&#x27;).last().hasClass(&#x27;disabled&#x27;))&#123;    await main(page + 1)  &#125;  &#125;async function getArticleContent(link)&#123;  const &#123; data &#125;= await request.get(link)  const $ = cheerio.load(data);  return $(&#x27;.markdown-text&#x27;).html()&#125;main(1)// 从第一页来时抓取数据\n\n","categories":["Nodejs"],"tags":["Nodejs"]},{"url":"/2021/06/22/ts/ts/","content":"反馈问题// 有一个 promise 中的请求失败，取消其他请求const controller = new AbortController();let signal = controller.signal;// axiosconst requests = [     fetch(&#x27;index.html&#x27;, &#123; signal &#125;),    fetch(&#x27;index.html&#x27;, &#123; signal &#125;),    fetch(&#x27;ftp://example.com&#x27;, &#123; signal &#125;)]Promise    .all(requests)    .then(arr =&gt; &#123;        console.log(arr)    &#125;)    .catch(err =&gt; &#123;        console.log(err)        controller.abort()    &#125;)\n\nreact中map循环生成的DOM，绑定事件时，是推荐使用事件委托的方式，还是直接在map循环出来的每一个DOM上直接写onClick\n性能优化\n对性能优化还是一知半解，不知在工作中如何去运用\n标记清除会造成空间碎片化，那么引用计数会吗？\nv8引擎中的分代回收希望能给在细讲一下\nhttps://juejin.cn/post/6927100870765051917\n\n\n\n变量和函数\nlet到底存不存在变量提升，我看有的地方明确说了let也是会存在变量提升的，只是因为存在暂时性死区(从当前块的顶部到let声明的地方被称为暂时性死区)的原因，导致不可在这个区域内去使用该变量\n函数定义时有多个参数  但是调用的时候直传了部分参数 是不是只要按顺序传递有效参数，部分不传也是可以的呢 例如 function add(m,n){console.log(m+1)｝  add(2);   或者 funnction  add(m,n){console.log(n+1)｝  add(,2);\n老师您好，我想问下  lodash库中的debounce函数和memoize函数似乎都能实现缓存的效果，它们两者有什么区别呢？谢谢。\nhttps://www.lodashjs.com/docs/lodash.debounce\n\n\n\n// 记忆函数const _ = require(&#x27;lodash&#x27;)function getArea (r) &#123;  console.log(r)  return Math.PI * r * r&#125;// let getAreaWithMemory = _.memoize(getArea)// console.log(getAreaWithMemory(4))// console.log(getAreaWithMemory(4))// console.log(getAreaWithMemory(4))// 模拟 memoize 方法的实现function memoize (f) &#123;  let cache = &#123;&#125;  return function () &#123;    let key = JSON.stringify(arguments)    cache[key] = cache[key] || f.apply(f, arguments)    return cache[key]  &#125;&#125;\n\n\n\nTS\n讲一下 Reflect.apply()\n\nfn.apply()\n\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/apply\n\n\nTypeScript相关： 配置文件target设置了  es5，没有设置lib，symbol和Promise都不报错，把lib设为[“ES2015”],console.log也没报错是怎么回事     \n\n和 Symbol.toStringTag 类似的属性还有什么？  对象的每一个方法都可以 Symbol.xxxTag 这样用吗？还是只有固定的几个\n\nhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\n\n\n\n其他\n事件委托的讲解以及事件委托的实际应用场景介绍\n\n&lt;ul id=&quot;mv&quot;&gt;    &lt;li class=&quot;one&quot;&gt;1&lt;/li&gt;    &lt;li class=&quot;two&quot;&gt;2&lt;/li&gt;    &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;li.onclick = function () &#123;&#125;\n\ndocument.querySelector(&#x27;#mv&#x27;).addEventListener(&#x27;click&#x27;, function (e) &#123;  // 判断是否匹配目标元素  if (e.target.nodeName.toLocaleLowerCase() === &#x27;li&#x27;) &#123;    console.log(&#x27;the content is: &#x27;, target.innerHTML)  &#125;&#125;)\n\n\n我想了解JavaScript到底有没有编译环节？part1-模块2-TypeScript语言-JavaScript类型系统特征中，老师说JavaScript没有编译环节。但是在《你不知道的JavaScript（上卷）》1.1中说“尽管通常将JavaScript归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。”JavaScript引擎进行编译的步骤和传统的编译语言非常相似，在某些环节可能比预想的要复杂。”\n\n变量提升只是解释器扫描代码，以及开辟内存空间的一个过程，没有对代码编译\nV8中的 JIT 会对执行一次以上的代码进行编译和优化处理\n\n\n在循环中将异步变成同步，除了原始for循环结合async await的方式实现，还有更好的实现方式么？例如：一个数组中全是Promise 但是数组的长度不定，数组中的每一个Promise的执行都要等前一个Promise的执行结果出来之后才能执行  \n\n\n\n异步迭代器：https://es6.ruanyifeng.com/#docs/async-iterator\n\nconst arr = [ fetch(&#x27;./index.html&#x27;), fetch(&#x27;./app.js&#x27;) ]async function fn () &#123;    for await (const res of arr) &#123;        console.log(res)        // console.log(await res.text())    &#125;&#125;fn()\n\n\nJS编程的设计模式讲解（例如：工厂模式、订阅模式等等）   \nhttps://gist.github.com/pissang/4d1cced7b7d32de41f9a815c27e4490e  以上链接中的“实现字符串 Query 的类型推导”部分代码看不大懂  希望能在课上帮助解释一下…\n\n相关内容关于 this 的回顾function foo () &#123;  console.log(this)&#125;foo() //window.foo() //foo.call(1) //\n\nconst obj1 = &#123;  foo: function () &#123;    console.log(this)  &#125;&#125;obj1.foo() //const fn = obj1.foofn() //\n\n\nconst obj2 = &#123;  foo: function () &#123;    function bar () &#123;      console.log(this)    &#125;    bar()  &#125;&#125;obj2.foo()\n\n关于 this 的总结：\n\n沿着作用域向上找最近的一个 function（不是箭头函数），看这个 function 最终是怎样执行的；\nthis 的指向取决于所属 function 的调用方式，而不是定义；\nfunction 调用一般分为以下几种情况：\n作为函数调用，即：foo()\n指向全局对象（globalThis），注意严格模式问题，严格模式下是 undefined\n\n\n作为方法调用，即：foo.bar() / foo.bar.baz() / foo[&#39;bar&#39;]() / foo[0]()\n指向最终调用这个方法的对象\n\n\n作为构造函数调用，即：new Foo()\n指向一个新对象 Foo &#123;&#125;\n\n\n特殊调用，即：foo.call() / foo.apply() / foo.bind()\n参数指定成员\n\n\n\n\n找不到所属的 function，就是全局对象\n箭头函数中的 this 指向\n\nfunction fn () &#123;    let arrFn = () =&gt; &#123;        console.log(this)    &#125;    arrFn()&#125;const obj = &#123;    name: &#x27;zs&#x27;,    fn: fn&#125;obj.fn()   fn()\t  \n\nthen:\nvar length = 10function fn () &#123;  console.log(this.length)&#125;const obj = &#123;  length: 5,  method (fn) &#123;    fn()   //    arguments[0]()  // 相当于 arguments.fn()  &#125;&#125;obj.method(fn, 1, 2)\n\n严格模式下原本应该指向全局的 this 都会指向 undefined\nES 2020/2021 新特性https://github.com/tc39/proposals/blob/master/finished-proposals.md\n// 空值合并运算符function foo (option) &#123;  // 只有 size = null 或者 undefined  option.size = option.size ?? 100    const mode = option.mode || &#x27;hash&#x27;   console.log(option)&#125;foo(&#123; size: 0 &#125;)// 可选链运算符const list = [  &#123;    title: &#x27;foo&#x27;,    author: &#123;      name: &#x27;zs&#x27;,      email: &#x27;zs@qq.com&#x27;    &#125;  &#125;,  &#123;    title: &#x27;bar&#x27;  &#125;]list.forEach(item =&gt; &#123;  console.log(item.author?.name)&#125;)  \n\n使用 TypeScript 的 Vue.js 项目差异1）基本操作\n\n安装 @vue/cli 最新版本\n\n使用 @vue/cli 创建一个项目（不选 TypeScript)\n\n使用 @vue/cli 安装 TypeScript 插件\nvue add typescript\n\n2）通过 Git Diff 对比介绍使用 TypeScript 的 Vue.js 项目差异\n\n安装了 @vue/cli-plugin-typescript 等插件\nshims-tsx.d.ts 文件的作用\n允许你以 .tsx 结尾的文件，在Vue项目中编写jsx代码\n\n\nshims-vue.d.ts 文件的作用\n用于 TypeScript 识别 .vue 文件\nTS 默认不支持 .vue 文件，这里 TS 导入.vue 文件都按 VueConstructor 处理\n\n\nd.ts 的问题\n该文件中定义的类型需要全局可用\n这个文件中不能在最外层书写 import 或者 export，如果书写这个文件会有自己的作用域\n如果这个文件中不写 import 或者 export，那么这个文件中定义的类型全局可用\n\n\n\nJavaScript 项目中的类型增强JavaScript 项目中如何有更好的类型提示：JSDoc + import-types\nhttps://www.typescriptlang.org/docs/handbook/type-checking-javascript-files.html\nhttps://www.typescriptlang.org/play/index.html?useJavaScript=truee=4#example/jsdoc-support\n类型检查@ts-check\n类型注解\n@type\n@typedef\n\n// 检查类型的错误// @ts-check/** * @summary 操作 DOM * @author zs * @param &#123; HTMLDivElement &#125; a1 要操作的div * @param &#123; string &#125; a2 字符串 * @returns &#123; HTMLDivElement &#125; 这是一个dom对象 */function fn (a1, a2) &#123;  return a1&#125;fn()/** @type &#123; string &#125; */let namename = 18/** @typedef &#123; &#x27;open&#x27; | &#x27;closed&#x27; &#125; Status  *//** @type &#123; Status &#125; */const s = &#x27;open&#x27;\n\n\n配置文件类型\nvue.config.js\nwebpack.config.js\n\n\n\n/** @type &#123;import(&#x27;@vue/cli-service&#x27;).ProjectOptions&#125; */module.exports = &#123;&#125;/** @type &#123;import(&#x27;webpack&#x27;).Configuration&#125; */module.exports = &#123;&#125;\n\n\nrouter 类型\n\n// Vue.js 3.0 中/** @type &#123; import(&#x27;vue-router&#x27;).RouteRecordRaw[] &#125; */const routes = []// Vue.js 2.x 中/** @type &#123; import(&#x27;vue-router&#x27;).RouteConfig[] &#125; */const routes = []\n\n\n\n\nstore 类型\n\n// Vue.js 3.0 和 Vue.js 2.x 一样/** @type &#123; import(&#x27;vuex&#x27;).MutationTree&lt;typeof import(&#x27;./state&#x27;).default&gt; &#125; */const mutations = &#123;  add (state) &#123;  &#125;&#125;export default mutations\n\n类型补充声明\ntypes.d.ts\n\n插件的类型扩展，使用类型补充声明\nimport &#123; AxiosInstance &#125; from &#x27;axios&#x27;declare module &#x27;vue/types/vue&#x27; &#123;  interface Vue &#123;    readonly axios: AxiosInstance  &#125;&#125;\n\nimport axios from &#x27;axios&#x27;export default &#123;  install (Vue) &#123;    const instance = axios.create(&#123;      baseURL: &#x27;http://127.0.0.1/api/v1&#x27;,      timeout: 10000    &#125;)    Vue.prototype.axios = instance  &#125;&#125;vm.axios\n\n\n\n定义组件的几种不同方式写法 1：使用 Options APIs\n组件仍然可以使用以前的方式定义（导出组件选项对象，或者使用 Vue.extend()）\n但是当我们导出的是一个普通的对象，此时 TypeScript 无法推断出对应的类型，\n至于 VSCode 可以推断出类型成员的原因是因为我们使用了 Vue 插件，\n这个插件明确知道我们这里导出的是一个 Vue 对象。\n所以我们必须使用 Vue.extend() 方法确保 TypeScript 能够有正常的类型推断\n\nimport Vue from &#x27;vue&#x27;export default Vue.extend(&#123;  name: &#x27;Button&#x27;,  data () &#123;    return &#123;      count: 1    &#125;  &#125;,  methods: &#123;    increment () &#123;      this.count++    &#125;  &#125;&#125;)\n\n写法 2：使用 Class APIs在 TypeScript 下，Vue 的组件可以使用一个继承自 Vue 类型的子类表示，这种类型需要使用 Component 装饰器去修饰\n装饰器函数接收的参数就是以前的组件选项对象（data、props、methods 之类）\nimport Vue from &#x27;vue&#x27;import Component from &#x27;vue-class-component&#x27; // 官方库@Component(&#123;  props: &#123;    size: String  &#125;&#125;)export default class Button extends Vue &#123;  private count: number = 1  private text: string = &#x27;Click me&#x27;  get content () &#123;    return `$&#123;this.text&#125; $&#123;this.count&#125;`  &#125;  increment () &#123; // 事件处理函数    this.count++  &#125;  mounted () &#123; // 生命周期函数    console.log(&#x27;button is mounted&#x27;)  &#125;&#125;\n\n\nData: 使用类的实例属性声明\nMethod: 使用类的实例方法声明\nComputed: 使用 Getter 属性声明\n生命周期: 使用类的实例方法声明\n\n其它特性：例如 components, props, filters, directives 之类的，则需要使用修饰器参数传入！！！！！\n使用这种 class 风格的组件声明方式并没有什么特别的好处，只是为了提供给开发者多种编码风格的选择性\n装饰器\n装饰器是 ES 草案中的一个新特性，提供一种更好的面向切面编程（AOP）的体验，不过这个草案最近有可能发生重大调整，所以并不推荐。\n\nTypeScript 中对装饰器的实现：https://www.staging-typescript.org/docs/handbook/decorators.html\n\n类装饰器\nfunction classDecorator (constructor: Function) &#123;  console.log(&#x27;源类型：&#x27;, constructor)&#125;\n方法装饰器\nfunction methodDecorator (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;  console.log(&#x27;目标对象：&#x27;, target)  console.log(&#x27;属性名称：&#x27;, propertyKey)  console.log(&#x27;属性描述符：&#x27;, descriptor)  // descriptor 指的就是 Object.definedProperty 传入的第三个参数&#125;\n访问器（getter/setter）装饰器\nfunction accessorDecorator (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;  console.log(&#x27;目标对象：&#x27;, target)  console.log(&#x27;属性名称：&#x27;, propertyKey)  console.log(&#x27;属性描述符：&#x27;, descriptor)&#125;\n属性装饰器\n\n参数装饰器\n\n\n写法 3：使用 Class APIs + vue-property-decoratorimport &#123; Vue, Component, Prop &#125; from &#x27;vue-property-decorator&#x27;@Componentexport default class Button extends Vue &#123;  private count: number = 1  private text: string = &#x27;Click me&#x27;  @Prop() readonly size?: string  get content () &#123;    return `$&#123;this.text&#125; $&#123;this.count&#125;`  &#125;  increment () &#123;    this.count++  &#125;  mounted () &#123;    console.log(&#x27;button is mounted&#x27;)  &#125;&#125;\n\n这种方式继续放大了 class 这种组件定义方法。\n推荐No Class APIs，只用 Options APIs。\n使用 Options APIs 最好是使用 export default Vue.extend(&#123; ... &#125;) 而不是 export default &#123; ... &#125;。\n其实 Vue.js 3.0 早期是想要放弃 Class APIs 的，不过无奈想要兼容，所以才保留下来了。\n"},{"url":"/2021/06/22/ts/vs%20code%E5%BF%AB%E6%8D%B7%E9%94%AE/","content":"vs code快捷键\nctrl+k  ctrl+0   快速折叠代码\nserve .   启动http窗口\n两个 script 标签，，会执行完第一个 script 标签里的同步代码和微任务才会去执行第二个 script 标签里的代码，，所以 script  相当于一个宏任务\nscript 标签1 的 同步代码 -》 script 标签1 的 微任务 -》script 标签2 的 同步代码 -》 script 标签2 的 微任务 -》script 标签1 与 script 标签2 的宏任务\n"},{"url":"/2021/06/22/ts/%E8%A7%84%E8%8C%83%E5%8C%96ESLint/","content":"ESLintESLint 介绍1. 最为主流的js lint工具，监测 js 代码质量\n 2. 很容易统一开发者的编码风格\n 3. 帮助开发者提升编码能力\n\nESLint 安装\n初始化项目：npm init –yes\n\n安装 ESLint 模块为开发依赖：npm install eslint –save-dev\n–save：将保存配置信息到pacjage.json。默认为dependencies节点中。\n–dev：将保存配置信息devDependencies节点中。\n\n通过 cli 命令验证安装结果\nnpx eslint –version —-查看版本\n\n\nESLint 快速上手\n编写”问题“代码\n\n使用 eslint 执行检测   —-    \n npx eslint .\\01-prepare.js\nnpx eslint –init    ——-添加配置文件\n npx eslint .\\01-prepare.js –fix      ——自动修复绝大多数代码风格的问题\n\n完成 eslint 使用配置  \n\n\nESLint 配置文件\n.eslintrc.js (npx eslint –init 生成 )\n// .eslintrc.jsmodule.exports = &#123;\t// 标记当前代码运行环境\tenv:&#123;\t\t// 每个选项对应着一组预定义的全局变量\t\tbrowser: true,\t\tes2020: true,\t\tes6: false\t&#125;,\t// 继承共享的配置\textends: [\t\t&#x27;standard&#x27;\t],\t// 设置语法解析器的配置，控制是否允许使用某个 es 版本的语法\t// 只代表语法检测\tparserOptions:&#123;\t\tecmaVersion: 2015\t&#125;,\t// 检测规则\trules:&#123;\t\t&#x27;no-alert&#x27;:&quot;off&quot;  // off:关闭，error:报错，warn:警告\t&#125;,\t// 最新版本已经没有体现了,额外声明代码中可以使用的全局成员\tglobals: &#123;\t\t&#x27;jquery&#x27;:&quot;readonly&quot;\t&#125;&#125;\n\neslint-env 配置\n\n\n\nESLint 配置注释http://eslint.cn/docs/user-guide/configuring#configuring-rules\n\n将配置通过注释的方式写到代码中\n\n忽略所有规则校验\nconst str1 = “${name} is a coder”   // eslint-disable-line\n\n忽略指定规则校验\nconst str1 = “${name} is a coder”  // eslint-disable-line no-template-curly-in-string\n\n\n\n\nESLint 结合自动化工具\n结合 gulp在 babel 转换前先检查\n// gulpfile.jsconst script = () =&gt; &#123;  return src(&#x27;src/assets/scripts/*.js&#x27;, &#123;      base: &#x27;src&#x27;    &#125;)    .pipe(plugins.eslint())    .pipe(plugins.eslint.format())    .pipe(plugins.eslint.failAfterError())    .pipe(plugins.babel(&#123;      presets: [&#x27;@babel/preset-env&#x27;]    &#125;))    .pipe(dest(&#x27;temp&#x27;))    .pipe(bs.reload(&#123;      stream: true    &#125;))&#125;\n\n\n结合 webpack\n\n// webpack.config.js&#123;    test: /\\.js$/,    exclude: /node_modules/,    use: &#x27;babel-loader&#x27;&#125;,&#123;    test: /\\.js$/,    exclude: /node_modules/,    use: &#x27;eslint-loader&#x27;,    enforce:&#x27;pre&#x27;   // 最开始执行&#125;\n\n\n解决引入 react ，未引用报错，使用插件  eslint-plugin-react，\n// .eslintrc.jsmodule.exports = &#123;  env: &#123;    browser: true,    es2021: true  &#125;,  extends: [    &#x27;standard&#x27;  ],  parserOptions: &#123;    ecmaVersion: 12  &#125;,  rules: &#123;  \t&#x27;react/jsx-uses-react&#x27;:2,  // eslint-plugin-react 插件中的规则  \t&#x27;react/jsx-uses-vars&#x27;:2   // eslint-plugin-react 插件中的规则  &#125;,  plugins:[    &#x27;react&#x27;    // 使用 eslint-plugin-react 插件，这样插件中所有的规则就可以用了  ]&#125;// 2.继承 eslint-plugin-react 插件 的所有规则配置，一般用这个module.exports = &#123;  env: &#123;    browser: true,    es2021: true  &#125;,  extends: [    &#x27;standard&#x27;,    &#x27;plugin:react/recommended&#x27;  // 继承 eslint-plugin-react 插件  ],  parserOptions: &#123;    ecmaVersion: 12  &#125;,  rules: &#123;  &#125;&#125;\n\n\nvue 项目中继承 ESLint\nESLint 检查 TypeScript\n\nnpx eslint –init  初始化时 选择 TypeScript\n指定语法解析器\n// .eslintrc.jsmodule.exports = &#123;  env: &#123;    browser: true,    es2021: true  &#125;,  extends: [    &#x27;standard&#x27;  ],  parser:&#x27;@typescript-eslint/parser&#x27;, // 语法解析器  parserOptions: &#123;    ecmaVersion: 12  &#125;,  rules: &#123;  &#125;&#125;\n\nStylelint 1. 对 css 代码 lint\n 2. 提供默认的代码检查规则\n 3. 提供 cli 工具，快速调用\n 4. 通过插件支持 Sass Less PostSCC\n 5. 支持 Gulp 或 Webpack 集成\n\n安装​    npm install stylelint -D\n运行\n添加配置文件 \n.stylelintrc.js\n\n添加配置，npm i stylelint-config-standard\n\n添加配置 sass 语法，npm install stylelint-config-sass-guidelines\n\n\n// .stylelintrc.jsmodule.exports = &#123;\textends:[\t\t&quot;stylelint-config-standard&quot;,  // 继承stylelint-config-standard，需要完成的名\t\t&quot;stylelint-config-sass-guidelines&quot;\t]\t&#125;\n\nPrettier所有类型的格式化\n\n安装\nnpm insatll prettier -D\n\n运行\nnpx prettier style.css                —》 默认将格式化后的代码输出到控制台\nnpx prettier style.css  –write   —》 将格式化后的代码输出到文件，覆盖原文件\nnpx prettier .   –write     —》将所有代码格式化并覆盖源文件\n\n\nGit Hooks 介绍\nGit Hook 也称为 git 钩子，每个钩子都对应一个任务\n\n通过 shell 脚本可以编写钩子任务触发时要具体执行的操作\n复制一份  pre-commit.sample\n删除后缀名 sample，就可以编写文件\n删除所有的内容，除了最上面的注释   #!/bin/sh\n// pre-commit#!/bin/shecho &quot;before commit&quot;\n\n\n\n\n\n\nESLint  结合 Git Hooks\n编写 shell 脚本\n\nHusky 可以实现 Git Hooks 的使用需求，可以检查代码\n\n安装\nnpm install husky -D\n// package.json 添加字段“husky&quot;&quot;scripts&quot;:&#123;\t&quot;test&quot;:&quot;eslint ./index.js&quot;&#125;,&quot;husky&quot;:&#123;\t&quot;hooks&quot;:&#123;\t\t&quot;pre-commit&quot;:&quot;npm run test&quot;\t&#125;&#125;\n\n\n  lint-staged 代码格式化\n\n\n安装\nnpm install lint-staged -D\n// package.json 添加字段“lint-staged&quot;&quot;scripts&quot;:&#123;\t&quot;test&quot;:&quot;eslint ./index.js&quot;,\t&quot;precommit&quot;:&quot;lint-staged&quot;&#125;,&quot;husky&quot;:&#123;\t&quot;hooks&quot;:&#123;\t\t&quot;pre-commit&quot;:&quot;npm run precommit&quot;\t&#125;&#125;,&quot;lint-staged&quot;:&#123;\t&quot;*.js&quot;:[\t\t&quot;eslint&quot;,\t\t&quot;git add&quot;\t]&#125;\n\n\n\n推荐使用 Husky  +   lint-staged"},{"title":"Nuxt.js","url":"/2021/05/31/vue/nuxtjs/","content":"1. 使用方式\n初始项目\n\n```bashnpm init nuxt-app * ```bash  mkdir &lt;project-name&gt;  cd &lt;project-name&gt;  touch package.json    // package.json  &#123;    &quot;name&quot;: &quot;my-app&quot;,    &quot;scripts&quot;: &#123;      &quot;dev&quot;: &quot;nuxt&quot;,      &quot;build&quot;: &quot;nuxt build&quot;,      &quot;generate&quot;: &quot;nuxt generate&quot;,      &quot;start&quot;: &quot;nuxt start&quot;    &#125;  &#125;    yarn add nuxt  mkdir pages  touch pages/index.vue  yarn dev\n\n\n已有的 Node.js 服务端项目\n\n直接把 Nuxt 当做一个中间件集成到 Node Web Server 中\n\n\n现有的 Vue.js 项目\n\n非常熟悉 Nuxt.js \n\n至少哦10% 的代码改动\n\n\n\n\n2. 异步数据 asyncData\nasyncData 只有页面组件中才调用，子组件不会触发调用，，要使用数据的话，需要页面组件传给子组件\n\nasyncData 中没有 this\n\n当你想要动态页面内容有利于 SEO 或者是提升首屏渲染速度的时候，就在 asyncData 中发请求拿数据\n\n上下文对象 \n\n获取路由参数 context.route.params 或者 context.params\n\nasync asyncData(context)&#123;      const &#123;data&#125; = await axios(&#123;        method:&#x27;GET&#x27;,        url:&#x27;http://localhost:3000/data.json&#x27;      &#125;)      const id = JSON.parse(context.params.id)      return &#123;        name:data.posts.find(item =&gt; item.id === id).name      &#125;    &#125;\n\n3. 生命周期\n服务端生效的钩子函数\nbeforeCreate\ncreated\nerrorCaptured\n\n\n\n4. nuxt 渲染流程\n5. nuxt 命令\n\n\n命令\n描述\n\n\n\nnuxt\n启动一个热加载的 web 服务器（开发模式）localhost:3000\n\n\nnuxt build\n利用 webpack 编译应用，压缩 JS 和 CSS 资源（发布用）\n\n\nnuxt start\n以生产模式启动一个 Web 服务器（需要先执行 nuxt build）\n\n\nnuxt generate\n编译应用，并依据路由配置生成对应的 HTML 文件（用于静态站点的部署）\n\n\n6. 最简单的部署方式\n配置 Host + Port\n// nuxt.config.js// 添加 server: &#123;    host: &#x27;0.0.0.0&#x27;, //     port: 3000  &#125;\n压缩发布包，压缩以下包上传\n\n.nuxt  打包生成的文件\n\nstatic 静态资源\n\nnuxt.config.js  配置\n\npackage.json\n\npackage-lock.json\n\n\n\n把发布包传到服务端\n\n连接到服务端，命令  ssh root@39.105.28.5\n查看  ls\n mkdir realworld-nuxtjs\ncd realworld-nuxtjs\n打印路径 pwd，复制路径\n退出 exit 服务端或者重新打开一个命令行窗口\n把本地的压缩包传到远程服务器，路径不能有中文名 scp ./realworld-nuxtjs.zip root@39.105.28.5:/root/realworld-nuxtjs\n连接服务器，查看ls\n解压 unzip realworld-nuxtjs.zip\nls 查看,-a查看隐藏目录 ls -a\n安装依赖 npm i\n启动服务 npm run start\n访问 公网IP + 端口号\n\n\n解压\n\n安装依赖\n\n启动服务\n\n\n连接服务器  ssh -o StrictHostKeyChecking=no &#x72;&#x6f;&#111;&#116;&#64;&#49;&#48;&#x36;&#x2e;&#55;&#53;&#46;&#49;&#56;&#50;&#46;&#x31;&#x31;&#53;  ls创建目录  mkdir realword-nuxtjs进入目录  cd realword-nuxtjs查看路径  pwd退出  exit\n7. 使用 PM2 启动 Node 服务，在后台运行应用\nhttps://github.com/Unitech/pm\n官方文档 https://pm2.io\n服务端 安装 npm install --global pm2\n启动 pm2 start 脚本路径 pm2 start npm -- start\n关闭 pm2 stop 6，6 是 id\n\n7.1 PM2 常用命令\n\n\n命令\n说明\n\n\n\npm2 list\n查看应用列表\n\n\npm2 start\n启动应用\n\n\npm2 stop\n停止应用\n\n\npm2 reload\n重载应用（原有实例慢慢消灭）\n\n\npm2 restart\n重启应用（原有程序杀死，再开启）\n\n\npm2 delete\n删除应用\n\n\n8. 自动化部署\n8.1 CI/CD 服务\nJenkins\nGitlab Ci\nGitHub Actions 本案例采用\nTravis CI\nCircle CI\n\n8.2 环境准备\nLinux 服务器\n把代码提交到 GitHub 远程仓库\n\n8.3 配置GitHub Access Tokengithub 的 token\n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\n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\ngridsome-blog token : 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\n\n\n生成： https://github.com/settings/tokens\n配置到项目的 Secrets 中：https://github.com/lipengzhou/realworld-nuxtjs/settings/secrets\n\n8.4 配置 GitHub Actions 执行脚本\n在项目根目录创建 .github/workflows 目录\n\n下载 main.yml 到 workflows 目录中\nhttps://gist.github.com/lipengzhou/b92f80142afa37aea397da47366bd872\n\n修改配置\n\n配置 PM2 配置文件\n// pm2.config.json&#123;\t&quot;apps&quot;:[\t\t&#123;\t\t\t&quot;name&quot;:&quot;RealWorld&quot;,\t\t\t&quot;script&quot;:&quot;npm&quot;,\t\t\t&quot;args&quot;:&quot;start&quot;\t\t&#125;\t]&#125;\n提交更新\n\n查看自动部署状态\n\n访问网站\n\n提交更新\n\ngit add .\ngit commit -m ‘部署更新测试’\ngit push\n\n\ngit add .\n\ngit tag v0.1.0  // 创建标签\n\ngit tag // 查看标签\n\ngit push origin v0.1.0 // 推送\n\n\n\n\n","categories":["vue"],"tags":["vue","服务端渲染"]},{"title":"Vue-Router","url":"/2021/05/31/vue/vue-Router/","content":"完整的导航解析流程\n导航被触发。\n在失活的组件里调用 beforeRouteLeave 守卫。\n调用全局的 beforeEach 守卫。\n在重用的组件里调用 beforeRouteUpdate 守卫 (2.2+)。\n在路由配置里调用 beforeEnter。\n解析异步路由组件。\n在被激活的组件里调用 beforeRouteEnter。\n调用全局的 beforeResolve 守卫 (2.5+)。\n导航被确认。\n调用全局的 afterEach 钩子。\n触发 DOM 更新。\n调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。\n\n1. 动态路由\n\n\n\n2. 命名视图3. 编程式导航this.$router.push(&#x27;/&#x27;)this.$router.push(&#123;name:&#x27;Home&#x27;&#125;)this.$router.replace(&#x27;/&#x27;)this.$router.go(-1)\n\n4. Hash 模式 与 History 模式的区别4.1 表现形式的区别​    1. hash 模式多了一个 #\n4.2 原理的区别\nHash 模式是基于锚点，以及 onhashchange 事件\n\nURL 中 # 后面的内容作为路径地址\n监听 hashchange 事件\n根据当前路由地址找到对应组件重新渲染\n\n\nHistory 模式是基于 HTML5 中的 History API\n\n通过 history.pushState() 方法改变地址栏\n监听 popState 事件\n根据当前路由地址找到对应组件重新渲染\n\nhistory.pushState()   // ie10以后才支持，所以兼容ie 9 需要使用 hashhistory.replaceState()\n\n4.3 History 模式使用需要服务器支持\n单页应用中，服务端不存在 http://www.testurl.com/login 这样的地址，刷新发送请求会返回 404 找不到该页面\n在服务端应该除了静态资源外都返回单页应用的 index.html\n\nnodejs 配置\n原生 nodejs\nconst http = require(&#x27;http&#x27;)const fs = require(&#x27;fs&#x27;)const httpPort = 80http.createServer((req, res) =&gt; &#123;  fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123;    if (err) &#123;      console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;)    &#125;    res.writeHead(200, &#123;      &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;    &#125;)    res.end(content)  &#125;)&#125;).listen(httpPort, () =&gt; &#123;  console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort)&#125;)\n\n\n\nexpress : 使用 connect-history-api-fallback 中间件\nconst path = require(&#x27;path&#x27;)const express = require(&#x27;express&#x27;)const history = require(&#x27;connect-history-api-fallback&#x27;)const app = express()app.use(history())app.use(express.static(path.join(__dirname,&#x27;../app/dist&#x27;)))app.listen(3000,() =&gt; &#123;  console.log(&#x27;服务器开启，端口：3000&#x27;)&#125;)\nNginx 配置\n\n从官网下载 Nginx 压缩包\n\n启动 start nginx重启 nginx -s reload停止 nginx -s stop\n\n// nginx.conflocation / &#123;  try_files $uri $uri/ /index.html;&#125;\n\n\n\n\nvue-router 实现原理vue-router 实现\ninstall\nconstructor\ncreateRouteMap\ninitComponents\ninit\ninitEvent\n\nlet _Vue = nullclass VueRouter &#123;  static install(Vue)&#123;    // 1. 判断当前插件是否已经被安装    if(VueRouter.install.installed &amp;&amp; _Vue === Vue)&#123;      return    &#125;    VueRouter.install.installed = true    // 2. 把 Vue 构造函数记录到全局变量    _Vue = Vue    // 3. 把创建 Vue 实例时候传入的 router 对象注入到 vue 实例上        // 混入    _Vue.mixin(&#123;      beforeCreate()&#123;        if(this.$options.router)&#123;          _Vue.prototype.$router = this.$options.router          this.$options.router.init()        &#125;      &#125;    &#125;)  &#125;    constructor(options)&#123;    this.options = options    this.routeMap = &#123;&#125;    this.data = _Vue.observable(&#123;      current:&#x27;/&#x27;    &#125;)  &#125;    init()&#123;    this.createRouteMap()    this.initComponents(_Vue)    this.initEvent()  &#125;    createRouteMap()&#123;    // 遍历所有的路由规则，把路由规则解析成键值对的形式，存储到 routeMap 中    this.options.routes.forEach(route =&gt; &#123;      this.routeMap[route.path] = route.component    &#125;)  &#125;    /*  initComponents(Vue)&#123;    Vue.component(&#x27;router-link&#x27;,&#123;      props:&#123;        to:String      &#125;,      template:&#x27;&lt;a :href=&quot;to&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/a&gt;&#x27;    &#125;)  &#125;  */    initComponents(Vue)&#123;    Vue.component(&#x27;router-link&#x27;,&#123;      props:&#123;        to:String      &#125;,      render(h)&#123;        return h(&#x27;a&#x27;,&#123;          attrs:&#123;            href:this.to          &#125;,          on:&#123;            click:this.clickHandler          &#125;        &#125;,[          this.$slots.default        ])      &#125;,      methods:&#123;        clickHandler(e)&#123;          history.pushState(&#123;&#125;,&#x27;&#x27;,this.to)          this.$router.data.current = this.to          e.preventDefault()        &#125;      &#125;    &#125;)        const self = this    Vue.component(&#x27;router-view&#x27;,&#123;      render(h)&#123;        const component = self.routeMap[self.data.current]        return h(component)      &#125;    &#125;)  &#125;    initEvent()&#123;    window.addEventListener(&#x27;popstate&#x27;,() =&gt; &#123;      this.data.current = window.location.pathname    &#125;)  &#125;&#125;export default VueRouter\n\n\n\n\n\n","categories":["vue"],"tags":["vue"]},{"title":"Vue","url":"/2021/05/31/vue/vue/","content":"vue 生命周期\n插值表达式vue指令计算属性和侦听器Class 和 Style 绑定条件渲染 / 列表渲染表单输入绑定组件插槽插件混入 mixin深入响应式原理不同构建版本的 Vue模板编译Vue2的路径：template-explorer.vuejs.org/#\nVue3的路径：vue-next-template-explorer.netlify.app/#\n组件注册全局组件\n局部组件\n","categories":["vue"],"tags":["vue"]},{"title":"vue3-小练习-todolist","url":"/2021/06/01/vue/vue3.0%E5%B0%8F%E7%BB%83%E4%B9%A0-todolist/","content":"项目创建仓库地址：https://gitee.com/endeavor1/todolist-vue3\n\n升级 Vue ClI 脚手架 Vue CLI v4.5\nyarn global add @vue/cli# ORnpm install -g @vue/cli\n脚手架创建项目\nvue create todolist-app\n使用 vite 快速构建 Vue 项目\n$ npm init @vitejs/app &lt;project-name&gt;$ cd &lt;project-name&gt;$ npm install$ npm run dev# OR$ yarn create @vitejs/app &lt;project-name&gt;$ cd &lt;project-name&gt;$ yarn$ yarn dev\n\n案例 ToDoList 功能列表\n添加待办事项\n\n删除待办事项\n\n编辑待办事项\n\n切换待办事项\n\n存储待办事项\n\n\n\n添加待办事项\n删除待办事项\n编辑待办事项\n双击待办事项，展示编辑文本框\n按回车或者编辑文本框失去焦点，修改数据\nli 绑定 key 值为 todo.text 会导致 编辑文本框时 key 值发生变化，导致重新渲染，所以 key 值改为绑定 todo\n\n\n按 esc 取消编辑\n把编辑文本框清空按回车，删除这一项\n显示编辑文本框的时候获取焦点\n自定义指令：获取焦点\n\n\n\n\n切换待办事项\n点击 checkbox ，改变所有待办事项状态\n具有 get 和 set 的计算属性\n\n\nAll / Active / Completed\n锚点：监视地址中 hash 的变化，当组件挂载完成，注册 hashchange 事件，当组件销毁时 移除  hashchange 事件，在 hashchange 事件中获取当前 锚点的值，根据 hash 过滤 todos 列表的数据\n创建一个对象，封装 过滤 todos 列表的 3 个函数\n\n\n显示未完成待办项个数\n移除所有完成的项目\n如果没有待办项，隐藏 main 和 footer\n\n\n存储待办事项\nwatch 监听 todos，localStorage 存储\n\n\n\n源码App.vue\n&lt;template&gt;  &lt;section id=&quot;app&quot; class=&quot;todoapp&quot;&gt;    &lt;header class=&quot;header&quot;&gt;      &lt;h1&gt;todos&lt;/h1&gt;      &lt;input          class=&quot;new-todo&quot;          placeholder=&quot;What needs to be done?&quot;          autocomplete=&quot;off&quot;          autofocus          v-model=&quot;input&quot;          @keyup.enter=&quot;addTodo&quot;      &gt;    &lt;/header&gt;    &lt;section class=&quot;main&quot; v-show=&quot;count&quot;&gt;      &lt;input id=&quot;toggle-all&quot; class=&quot;toggle-all&quot; type=&quot;checkbox&quot; v-model=&quot;allDone&quot;&gt;      &lt;label for=&quot;toggle-all&quot;&gt;Mark all as complete&lt;/label&gt;      &lt;ul class=&quot;todo-list&quot;&gt;        &lt;li            v-for=&quot;todo in filterTodos&quot;            :key=&quot;todo&quot;            :class=&quot;&#123; editing:todo === editingTodo, completed:todo.completed &#125;&quot;        &gt;          &lt;div class=&quot;view&quot;&gt;            &lt;input class=&quot;toggle&quot; type=&quot;checkbox&quot; v-model=&quot;todo.completed&quot;&gt;            &lt;label @dblclick=&quot;editTodo(todo)&quot;&gt;&#123;&#123; todo.text &#125;&#125;&lt;/label&gt;            &lt;button class=&quot;destroy&quot; @click=&quot;remove(todo)&quot;&gt;&lt;/button&gt;          &lt;/div&gt;          &lt;input              class=&quot;edit&quot;              type=&quot;text&quot;              v-model=&quot;todo.text&quot;              v-editing-focus=&quot;todo === editingTodo&quot;              @keyup.enter=&quot;doneEdit(todo)&quot;              @blur=&quot;doneEdit(todo)&quot;              @keyup.esc=&quot;cancelEdit(todo)&quot;          &gt;        &lt;/li&gt;      &lt;/ul&gt;    &lt;/section&gt;    &lt;footer class=&quot;footer&quot; v-show=&quot;count&quot;&gt;      &lt;span class=&quot;todo-count&quot;&gt;        &lt;strong&gt;&#123;&#123; remainingCount &#125;&#125;&lt;/strong&gt; &#123;&#123; remainingCount &gt; 1 ? &#x27;items&#x27; : &#x27;item&#x27; &#125;&#125; left      &lt;/span&gt;      &lt;ul class=&quot;filters&quot;&gt;        &lt;li&gt;&lt;a href=&quot;#/all&quot;&gt;All&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#/active&quot;&gt;Active&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=&quot;#/completed&quot;&gt;Completed&lt;/a&gt;&lt;/li&gt;      &lt;/ul&gt;      &lt;button class=&quot;clear-completed&quot; v-show=&quot;count &gt; remainingCount&quot; @click=&quot;removeCompleted&quot;&gt;        Clear completed      &lt;/button&gt;    &lt;/footer&gt;  &lt;/section&gt;  &lt;footer class=&quot;info&quot;&gt;    &lt;p&gt;Double-click to edit a todo&lt;/p&gt;    &lt;!-- Remove the below line ↓ --&gt;    &lt;p&gt;Template by &lt;a href=&quot;http://sindresorhus.com&quot;&gt;Sindre Sorhus&lt;/a&gt;&lt;/p&gt;    &lt;!-- Change this out with your name and url ↓ --&gt;    &lt;p&gt;Created by &lt;a href=&quot;https://www.lagou.com&quot;&gt;教瘦&lt;/a&gt;&lt;/p&gt;    &lt;p&gt;Part of &lt;a href=&quot;http://todomvc.com&quot;&gt;TodoMVC&lt;/a&gt;&lt;/p&gt;  &lt;/footer&gt;&lt;/template&gt;&lt;script&gt;import &#x27;./assets/index.css&#x27;import useLocalStorage from &#x27;./utils/useLocalStorage&#x27;import &#123; ref, computed, onMounted, onUnmounted, watchEffect &#125; from &#x27;vue&#x27;const storage = useLocalStorage()// 1. 添加待办事项const useAdd = todos =&gt; &#123;  const input = ref(&#x27;&#x27;)  const addTodo = () =&gt; &#123;    const text = input.value &amp;&amp; input.value.trim()    if(!text.length) return    todos.value.unshift(&#123;      text,      completed:false    &#125;)    input.value = &#x27;&#x27;  &#125;  return &#123;    input,    addTodo  &#125;&#125;// 2. 删除待办事项const useRemove = todos =&gt; &#123;  const remove = todo =&gt; &#123;    const index = todos.value.indexOf(todo)    todos.value.splice(index,1)  &#125;    // 删除已完成待办事项  const removeCompleted = () =&gt; &#123;    todos.value = todos.value.filter(todo =&gt; !todo.completed)  &#125;  return &#123;    remove,    removeCompleted  &#125;&#125;// 3. 编辑待办事项const useEdit = remove =&gt; &#123;  let beforeEditingText = &#x27;&#x27;  const editingTodo = ref(null)  // 双击待办事项，展示编辑文本框  const editTodo = todo =&gt; &#123;    beforeEditingText = todo.text    editingTodo.value = todo  &#125;  // 按回车或者编辑文本框失去焦点，修改数据  const doneEdit = todo =&gt; &#123;    if(!editingTodo.value) return    todo.text = todo.text.trim()    // 把编辑文本框清空按回车，删除这一项    todo.text || remove(todo)    editingTodo.value = null  &#125;  // 按 esc 取消编辑  const cancelEdit = todo =&gt; &#123;    editingTodo.value = null    todo.text = beforeEditingText  &#125;  return &#123;    editingTodo,    editTodo,    doneEdit,    cancelEdit  &#125;&#125;// 4. 切换待办项完成状态const useFilter = todos =&gt; &#123;  // 具有 get 和 set 的计算属性  const allDone = computed(&#123;    get()&#123;      return !todos.value.filter(todo =&gt; !todo.completed).length    &#125;,    set(val)&#123;      todos.value.forEach(todo =&gt; todo.completed = val)    &#125;  &#125;)    // 监视 hashchange 事件，监听 锚点 变化，过滤 todos  const filter = &#123;    all:list =&gt; list,    active:list =&gt; list.filter(todo =&gt; !todo.completed),    completed:list =&gt; list.filter(todo =&gt; todo.completed)  &#125;  const type = ref(&#x27;all&#x27;)  const filterTodos = computed(() =&gt; filter[type.value](todos.value))  // 未完成待办事项  const remainingCount = computed(() =&gt; filter.active(todos.value).length)  // 待办项总个数  const count = computed(() =&gt; todos.value.length)  const onHashChange = () =&gt; &#123;    const hash = window.location.hash.replace(&#x27;#/&#x27;,&#x27;&#x27;)    if(filter[hash])&#123;      type.value = hash // 响应式数据，数据变化时要重新渲染模板    &#125;else&#123;      type.value = &#x27;all&#x27;      window.location.hash = &#x27;&#x27;    &#125;  &#125;  onMounted(() =&gt; &#123;    window.addEventListener(&#x27;hashchange&#x27;,onHashChange)  &#125;)  onUnmounted(() =&gt; &#123;    window.removeEventListener(&#x27;hashchange&#x27;,onHashChange)  &#125;)        return &#123;    allDone,    filterTodos,    remainingCount,    count  &#125;&#125;// 5. 存储待办事项const useStorage = () =&gt; &#123;  const KEY = &#x27;TODOKEYS&#x27;  const todos = ref(storage.getItem(KEY) || [])  // watch(todos.value,(newVal,oldVal) =&gt; &#123;  //   console.log(newVal,oldVal)  //   storage.setItem(KEY, newVal.value)  // &#125;)  watchEffect((val,old) =&gt; &#123;    console.log(123,val,old)    let value = todos.value    storage.setItem(KEY, value)  &#125;)  return todos&#125;export default &#123;  name: &#x27;App&#x27;,  setup()&#123;    const todos = useStorage()    const &#123; remove, removeCompleted &#125; = useRemove(todos)    return &#123;      todos,      remove,      removeCompleted,      ...useAdd(todos),      ...useEdit(remove),      ...useFilter(todos)    &#125;  &#125;,  // 自定义指令，获取焦点  directives:&#123;    editingFocus:(el,bingding) =&gt; &#123;      bingding.value &amp;&amp; el.focus()    &#125;  &#125;&#125;&lt;/script&gt;&lt;style&gt;#app &#123;  font-family: Avenir, Helvetica, Arial, sans-serif;  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;  text-align: center;  color: #2c3e50;  margin-top: 60px;&#125;&lt;/style&gt;\n\n\n\nuseLocalStorage.js\nfunction parse(str) &#123;  let value  try&#123;    value = JSON.parse(str)  &#125;catch (e) &#123;    value = null  &#125;  return value&#125;function stringfy(obj) &#123;  let value  try&#123;    value = JSON.stringify(obj)  &#125;catch (e) &#123;    value = null  &#125;  return value&#125;export default function useLocalStorage() &#123;  function setItem(key, value) &#123;    value = stringfy(value)    window.localStorage.setItem(key, value)  &#125;  function getItem(key) &#123;    let value = window.localStorage.getItem(key)    if(value)&#123;      value = parse(value)    &#125;    return value  &#125;  return &#123;    setItem,    getItem  &#125;&#125;\n\n","categories":["vue"],"tags":["vue"]},{"title":"vue3响应式原理","url":"/2021/06/01/vue/vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86/","content":"项目地址：https://gitee.com/endeavor1/vue3-reactivity\nvue3 响应式系统\nProxy 对象实现属性监听\n多层属性嵌套，在访问属性过程中处理下一级属性\n默认监听动态添加的属性\n默认监听属性的删除操作\n默认监听数组索引和 length 属性\n可以作为单独的模块使用\n\n核心方法\nreactive / ref / toRefs / computed\neffect (watch 函数内部)\ntrack\ntrigger\n\n基础-Proxy 对象\nProxy\nconst target = &#123;    foo: &#x27;xxx&#x27;,    bar: &#x27;yyy&#x27;&#125;const proxy = new Proxy(target, &#123;    get (target, key, receiver) &#123;        return Reflect.get(target, key, receiver)    &#125;,    // set 和 deleteProperty 中需要返回布尔类型的值    // 在严格模式下，如果返回 false 的话会出现 Type Error 的异常    set (target, key, value, receiver) &#123;        // 不加 return,严格模式下会报错        return Reflect.set(target, key, value, receiver)    &#125;,    deleteProperty (target, key) &#123;        return Reflect.deleteProperty(target, key)    &#125;&#125;)\nProxy 和 Reflect 中使用的 receiver\n\nProxy 中 receiver：Proxy 或者继承 Proxy 的对象\nReflect 中 receiver：如果 target 对象中设置了 getter，getter 中的 this 指向 receiver\n\nconst obj = &#123;    get foo() &#123;        console.log(this)        return this.bar    &#125;&#125;const proxy = new Proxy(obj, &#123;    get (target, key, receiver) &#123;        if (key === &#x27;bar&#x27;) &#123;            return &#x27;value - bar&#x27;        &#125;        // 不加 receiver，上面 get 里this 是 obj 对象        // return Reflect.get(target, key)         // 加 receiver，上面 get 里this 是 Proxy 对象        return Reflect.get(target, key, receiver)    &#125;&#125;)console.log(proxy.foo)\n\n响应式-工具函数// 判断是否是对象const isObject = val =&gt; val !== null &amp;&amp; typeof val === &#x27;object&#x27;// 递归处理，如果是对象，继续调用reactive将其处理为响应式const convert = target =&gt; isObject(target) ? reactive(target) : target// 判断某个对象本身是否具有某个属性const hasOwnProperty = Object.prototype.hasOwnPropertyconst hasOwn = (target,key) =&gt; hasOwnProperty.call(target,key)\n\n\n\n响应式-reactive\n接收一个参数，判断这参数是否是对象\n创建拦截器对象 handler，设置 get / set / deleteProperty\n返回 Proxy 对象\n\nexport function reactive(target) &#123;  // 判断这参数是否是对象  if(!isObject(target)) return target    // 创建拦截器对象 handler，设置 get / set / deleteProperty  const handler = &#123;    get(target,key,receiver)&#123;      // 收集依赖      track(target,key)      const result =  Reflect.get(target,key,receiver)      // 判断得到的值是否是对象，如果是对象，会递归收集下一级的依赖      return convert(result)    &#125;,    set(target,key,value,receiver)&#123;      const oldValue = Reflect.get(target,key,receiver)      let result = true      // 判断新值是否与之前的值相同，如果相同就直接返回      if(oldValue !== value)&#123;        result = Reflect.set(target,key,value,receiver)        // 触发更新        trigger(target, key)      &#125;      return result    &#125;,    deleteProperty(target,key)&#123;      // 判断 target 中是否有 key 属性      const hadKey = hasOwn(target,key)      const result = Reflect.deleteProperty(target,key)      if(hadKey &amp;&amp; result)&#123;        // 触发更新        trigger(target, key)      &#125;      return result    &#125;  &#125;  // 返回 Proxy 对象  return new Proxy(target,handler)&#125;\n\n\n\n响应式-effect调用一次 effect 回调函数\n收集依赖-track —– reactive 中的 get 方法里\n触发更新-trigger —– reactive 中的 set 和 deleteProperty 方法里\n\ntargetMap  : 记录目标对象和一个字典(depsMap)\nnew WeakMap() 类型：key 就是目标对象，value 是 depsMap\n弱引用 Map，目标对象失去引用后可以销毁\n\n\ndepsMap ：\nnew Map() 类型：key 就是目标对象中的属性名称，value 是 dep \n\n\ndep ：\nnew Set() 类型：存储的 是 effect 函数，一个属性可能对应多个函数\n\n\n\n\nlet activeEffect = nullexport function effect(callbak) &#123;  activeEffect = callbak  // 调用 callback 时会访问响应式对象属性，去收集依赖，收集依赖过程中需要把 callback 存储起来  callbak()    // 依赖收集完之后，把 activeEffect 置为 null，方便下次依赖收集  activeEffect = null&#125;// 收集依赖let targetMap = new WeakMap()export function track(target, key) &#123;  if(!activeEffect) return  let depsMap = targetMap.get(target)  if(!depsMap)&#123;    // 创建一个 new Map() 存储到 depsMap 中，并且 把这个值存储到 targetMap 中    targetMap.set(target,(depsMap = new Map()))  &#125;  let dep = depsMap.get(key)  if(!dep)&#123;    depsMap.set(key,(dep = new Set()))  &#125;  dep.add(activeEffect)&#125;// 触发更新export function trigger(target, key) &#123;  const depsMap = targetMap.get(target)  if(!depsMap) return  const dep = depsMap.get(key)  if(!dep) return  dep.forEach(effect =&gt; effect())&#125;\n\n\n\n响应式-refexport function ref(raw) &#123;  // 判断 raw  是否是 ref 创建的对象，如果是的话直接返回  if(isObject(raw) &amp;&amp; raw.__v_isRef) return    // 判断 raw 是否是对象，如果是对象的话调用 reactive 创建响应式对象，否则的话返回 raw  let value = convert(raw)    // 创建 ref 对象 ,并且返回  const r = &#123;    __v_isRef:true,     get value()&#123;      track(r,&#x27;value&#x27;)      return value    &#125;,    set value(newValue)&#123;      if(newValue !== value)&#123;        raw = newValue        value = convert(raw)        trigger(r,&#x27;value&#x27;)      &#125;    &#125;  &#125;  return r&#125;\n\n\n\nref 与 reactive 的区别\nref 可以把基本数据类型数据，转成响应式对象\nref 返回的对象，重新赋值成对象也是响应式的（给value 重新赋值）\nreactive 返回的对象，重新赋值丢失响应式\nreactive 返回的对象不可以解构\n\n响应式-toRefs\n接收一个 reactive 返回的对象\n将reactive 返回的对象 内部的每个属性都转换为响应式\n把转换后的属性挂载到一个新的对象上返回\n\nexport function toRefs(proxy) &#123;  // 判断函数的参数是否是 reactive 创建的对象    // 遍历属性转换为 响应式，挂载到新的对象上返回  const ret = proxy instanceof Array ? new Array(proxy.length) : &#123;&#125;  for(const key in proxy)&#123;    ret[key] = toProxyRef(proxy, key)  &#125;  return ret&#125;function toProxyRef(proxy, key) &#123;  const r = &#123;    __v_isRef:true,    get value()&#123;      return proxy[key]    &#125;,    set value(newValue)&#123;      proxy[key] = newValue    &#125;  &#125;  return r&#125;\n\n\n\n响应式-computed\n接收一个参数 getter，获取结果的函数\n返回一个 ref 创建的 具有 value 属性的对象\n调用 effect，在 effect 里调用 getter，把 getter的结果存到 ref 的 value 中\n\nexport function computed(getter) &#123;  const result = ref()  effect(() =&gt; (result.value = getter()))  return result&#125;\n\n","categories":["vue"],"tags":["vue"]},{"title":"Vuex","url":"/2021/05/31/vue/vuex/","content":"状态管理\nstate，驱动应用的数据源； \n\nview，以声明方式将 state 映射到视图； \n\nactions，响应在 view 上的用户输入导致的状态变化。\n\n\n什么是 vuex\nvuex 是专门为 vue.js 设计的状态管理库\nvuex 采用集中式的方式存储需要共享的状态\nvuex 的作用是进行状态管理，解决复杂组件通信，数据共享\nvuex 集成到了 devtools 中，提供了 time-travel 时光旅行历史回滚功能\n\n\n\nstore\n仓库，vuex的核心，唯一的，容器，包含应用的大部分状态\n\nstate\nVuex 使用单一状态树，用一个对象就包含了全部的应用层级状态。\n\ngetter\nstore 的计算属性，就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\nmutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 **回调函数 (handler)**。这个回调函数就是我们实际进行状态更改的地方\n\naction\nAction 类似于 mutation，不同在于：\n\nAction 提交的是 mutation，而不是直接变更状态。\nAction 可以包含任意异步操作。\n\n\nmodule\n由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。为了解决以上问题，Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：\n\n\n使用\nmapState, mapGetters, mapMutations, mapActions，可传对象或数组\n传对象可重命名，还可以通过state计算得出其他值\ngetters定义时可返回一个函数，页面调用 countAdd(5)\nactions 异步，this.$store.dispatch(“decreateAsync”, num).then()\nmodules 命名空间设置 namespaced: true,，页面使用 …mapState(“product”, [“products”])，可直接使用products\n&lt;script&gt;import &#123; mapState, mapGetters, mapMutations, mapActions &#125; from &quot;vuex&quot;;export default &#123;  name: &quot;App&quot;,  data() &#123;    return &#123;      count: 2,      ass: 5    &#125;;  &#125;,  computed: &#123;    ...mapState([&quot;msg&quot;]), // count: state =&gt; state.count    ...mapState(&#123; num: &quot;count&quot;, message: &quot;msg&quot; &#125;), // 给state重命名    ...mapState(&#123;      addNum(state) &#123;        return state.count + this.ass; // 通过计算得出新的值      &#125;    &#125;),    ...mapGetters([&quot;reverseMsg&quot;]),    ...mapGetters(&#123; resMsg: &quot;reverseMsg&quot; &#125;),    ...mapGetters([&quot;countAdd&quot;]), // getter 在通过方法访问时，每次都会去进行调用，而不会缓存结果    ...mapState(&quot;product&quot;, [&quot;products&quot;]) // 命名空间  &#125;,  methods: &#123;    ...mapMutations([&quot;increate&quot;]),    ...mapMutations(&#123;      add: &quot;increate&quot;    &#125;),    ...mapActions([&quot;increateAsync&quot;]),    ...mapActions(&#123;      addAsync: &quot;increateAsync&quot;    &#125;),    decreate(num) &#123;      this.$store.dispatch(&quot;decreateAsync&quot;, num).then(res =&gt; &#123;        console.log(res, this.count++);      &#125;);    &#125;,    ...mapMutations([&quot;setProducts&quot;]),    ...mapMutations(&quot;product&quot;, [&quot;setProducts&quot;]) // 命名空间  &#125;&#125;;&lt;/script&gt;\n\nvuex 插件\nvuex 的插件就是一个函数\n\n这个函数接收一个 store 的参数\nconst myPlugin = store =&gt; &#123;  // 当 store 初始化后调用  store.subscribe((mutation, state) =&gt; &#123;    // 每次 mutation 之后调用    // mutation 的格式为 &#123; type, payload &#125;    // 如果是 cart 模块，则每次提交之后都更改 localStorage    if (mutation.type.startsWith(&#x27;cart/&#x27;)) &#123;      window.localStorage.setItem(&#x27;cart-products&#x27;, JSON.stringify(state.cart.cartProducts))  &#125;)&#125;// 用const store = new Vuex.Store(&#123;  // ...  plugins: [myPlugin]&#125;)\n\n手写 vuexlet _Vue = nullclass Store &#123;  constructor(options) &#123;    const &#123;      state = &#123;&#125;,        getters = &#123;&#125;,        mutations = &#123;&#125;,        actions = &#123;&#125;    &#125; = options    this.state = _Vue.observable(state)    this.getters = Object.create(null)    Object.keys(getters).forEach(key =&gt; &#123;      Object.defineProperty(this.getters, key, &#123;        get: () =&gt; getters[key](state)      &#125;)    &#125;)    this._mutations = mutations    this._actions = actions  &#125;  commit(type, payload) &#123;    this._mutations[type](this.state, payload)  &#125;  dispatch(type, payload) &#123;    this._actions[type](this, payload)  &#125;&#125;function install(Vue) &#123;  _Vue = Vue  _Vue.mixin(&#123;    beforeCreate() &#123;      if (this.$options.store) &#123;        _Vue.prototype.$store = this.$options.store      &#125;    &#125;  &#125;)&#125;export default &#123;  Store,  install&#125;\n\n","categories":["vue"],"tags":["vue"]},{"title":"Vue 响应式原理","url":"/2021/05/31/vue/vue%E5%93%8D%E5%BA%94%E5%BC%8F/","content":"数据驱动开发过程中仅需要关注数据本身，不需要关注数据是如何渲染到视图\n数据响应式数据模型仅仅是普通的 JavaScript 对象，而当我们修改数据时，视图会进行更新，避免了繁琐的 DOM 操作，提高开发效率\n\nvue2 Object.defineProperty\nlet data = &#123;    msg: &#x27;hello&#x27;&#125;  fn(data, &#x27;msg&#x27;, data.msg)function fn(obj, key, val) &#123;    Object.defineProperty(obj, key, &#123;      enumerable: true, // 可枚举（可遍历）      configurable: true, // 可配置（可以使用 delete 删除，可以通过 defineProperty 重新定义）      get() &#123;        return val      &#125;,      set(v) &#123;        if (v === val) &#123;          return        &#125;        val = v        document.getElementById(&#x27;app&#x27;).innerText = val      &#125;    &#125;)&#125;\nvue3 Proxy\nlet data = &#123;    msg: &#x27;hello&#x27;&#125;let vm3 = new Proxy(data, &#123;    get(target, key) &#123;      console.log(&#x27;get,target,key&#x27;, key, target)      return target[key]    &#125;,    set(target, key, v) &#123;      console.log(&#x27;set&#x27;, v)      if (v === target[key]) &#123;        return      &#125;      target[key] = v      document.getElementById(&#x27;app&#x27;).innerText = target[key]    &#125;&#125;)\n发布订阅模式\nclass EventEmitter &#123;  constructor() &#123;    // &#123;&#x27;clicl&#x27;:[fn1,fn2], &#x27;change&#x27;:[fn1]&#125;    this.subs = Object.create(null)  &#125;\t// 订阅  $on(eventType, handler) &#123;    this.subs[eventType] = this.subs[eventType] || []    this.subs[eventType].push(handler)  &#125;\t// 发布  $emit(eventType, data) &#123;    if (this.subs[eventType]) &#123;      this.subs[eventType].forEach(handler =&gt; &#123;        handler(data)      &#125;)    &#125;  &#125;&#125;\n观察者模式\n观察者（订阅者）– Watcher\n* update() : 当事件发生时，具体要做的事情\n\n目标（发布者）– Dep\n* subs ：存储所有的观察者\n* addSub() : 添加观察者\n* notify() : 当事件发生时，调用所有观察者的 update() 方法\n\n// 发布者-目标class Dep &#123;  constructor() &#123;    this.subs = [] // 记录所有的订阅者  &#125;  addSub(sub) &#123;    if (sub &amp;&amp; sub.update) &#123;      this.subs.push(sub)    &#125;  &#125;  notify() &#123;    this.subs.forEach(sub =&gt; &#123;      sub.update()    &#125;)  &#125;&#125;// 订阅者-观察者class Watcher &#123;  update() &#123;    console.log(&#x27;update&#x27;)  &#125;&#125;\n发布订阅模式 与 观察者模式区别\n\n观察者模式是由具体目标调度，比如当事件触发，Dep就会去调用观察者的方法，所以观察者模式的订阅者与发布者之间是存在依赖的\n发布/订阅模式由统一调度中心调用，因此发布者与订阅者不需要知道对方的存在\n\n\n\n\n\nvue 响应式原理模拟\n\n\nVue \n记录传入的选项，设置 $data/$el \n把 data 的成员注入到 Vue 实例 负责调用 \nObserver 实现数据响应式处理（数据劫持） \n负责调用 Compiler 编译指令/插值表达式等 \n\n\nObserver \n数据劫持 \n负责把 data 中的成员转换成 getter/setter \n负责把多层属性转换成 getter/setter \n如果给属性赋值为新对象，把新对象的成员设置为 getter/setter \n\n\n添加 Dep 和 Watcher 的依赖关系 \n数据变化发送通知 \n\n\nCompiler \n负责编译模板，解析指令/插值表达式 \n负责页面的首次渲染过程 \n当数据变化后重新渲染 \n\n\nDep \n收集依赖，添加订阅者(watcher) \n通知所有订阅者 \n\n\nWatcher \n自身实例化的时候往dep对象中添加自己 \n当数据变化dep通知所有的 Watcher 实例更新视图\n\n\n\n\n\n双向绑定数据改变，视图改变；视图改变，数据也随之改变\n我们可以使用 v-model 在表单元素上创建双向数据绑定\n","categories":["vue"],"tags":["vue"]},{"title":"服务端渲染","url":"/2021/05/31/vue/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/","content":"渲染什么是渲染： 把（数据+模板）拼接到一起\n请求后端接口数据，然后将数据同构模板绑定到语法绑定到页面中，最终呈现给用户。\n1. SPA 单页面应用优点\n\n用户体验好\n开发效率高\n渲染性能好\n可维护性好\n\n缺点\n\n首屏渲染时间长\n\n不利于 SEO\n\n\n\n2. 传统的服务端渲染\n缺点\n\n应用的前后端部分完全耦合在一起，在前后端协同开发方面会有非常大的阻力\n前端没有足够的发挥空间，无法充分利用现在前端状态下的一些更优秀的方案\n由于内容都是在服务端动态生成的，所以服务端的压力较大\n相比目前流行的 SPA 应用来说，用户体验一般\n\n3. 同构渲染（现代化的服务端渲染）同构应用：基于 react 、vue 框架，客户端渲染和服务器端渲染的结合，在服务器端执行一次，用于实现服务器端渲染（首屏直出），在客户端再执行一次，用于接管页面交互，核心解决 SEO 和首屏渲染慢的问题\n\n\n客户端发起请求\n服务端渲染首屏内容 + 生成客户端 SPA 相关资源\n服务端将生成的首屏资源发送给客户端\n客户端直接展示服务端渲染好的首屏内容\n首屏中的 SPA 相关资源执行之后会激活客户端 Vue\n之后客户端所有的交互都由客户端 SPA 处理\n\n优点：首屏渲染速度快、有利于 SEO\n缺点：\n\n开发成本高\n设计构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序（SPA）不同，服务器渲染应用程序，需要处于 Node.js server 运行环境\n更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源（CPU-intensive - CPU 秘籍），因此如果你预料在高流量环境（high traffic）下使用，请准备相应的服务器负载，并明智地采用缓存策略\n\n","categories":["vue"],"tags":["vue","服务端渲染"]},{"title":"虚拟Dom","url":"/2021/05/31/vue/%E8%99%9A%E6%8B%9FDOM/","content":"1. 什么是虚拟Domvirtual DOM (虚拟DOM)，是由普通的 js 对象来描述 DOM 对象\n&#123;\tsel:&#x27;div&#x27;,\ttext:&#x27;hello world&#x27;&#125;\n\n2. 虚拟 DOM 的作用\n维护视图和状态的关系\n复杂视图情况下提升渲染性能\n跨平台\n浏览器平台渲染DOM\n服务端渲染SSR（Nuxt.js/Next.js)\n原生应用（Weex/React Native)\n小程序（mpvue/uni-app）\n\n\n虚拟 DOM 库\nSnabbdom\n通过模块可扩展\n源码使用 ts 开发\n\n\nvirtual-dom\n\n\n\n3. Snabbdom\n安装 parcel\nmd snabbdom-democd snabbdom-demonpm init -ynpm install parcel-bundler -D\n配置 scripts\n&quot;scripts&quot;:&#123;\t&quot;dev&quot;:&quot;parcel index.html --open&quot;,\t&quot;build&quot;:&quot;parcel build index.html&quot;&#125;\n目录结构\n\n\n3.1 基本使用\n模块\n作用：\n\nSnabbdom 的核心库并不能处理 DOM 元素的属性/ 样式/ 事件等，可以通过注册 Snabbdom 默认提供的模块来实现\nSnabbdom 中的模块可以用来扩展 Snabbdom 的功能\nSnabbdom 中的模块的实现是通过注册全局的钩子函数来实现的\n\n官方提供的模块\n\nattributes\nprops\ndataset\nclass : 切换类样式\nstyle\neventlisteners\n\n使用步骤\n\n导入需要的模块\ninit() 中注册模块\nh()函数的第二个参数处处理模块\n\n\n\n3.2 源码函数重载：函数名相同，参数个数不同或者参数类型不同（js中没有，ts中有）\npatch 整体过程分析：\n\npatch(oldVnode, newVnode)\n把新节点中变化的内容渲染到真实 DOM，最后返回新节点作为下一次处理的旧节点\n对比新旧节点 Vnode 是否相同节点（节点的 key 和 sel 相同）\n如果不是相同节点，删除之前的内容，重新渲染\n如果是相同节点，再判断新的 VNode 是否有 text，如果有并且和 oldVnode 的 text 不同，直接更新文本内容\n如果新的 VNode 有children，判断子节点是否有变化\n\n","categories":["vue"],"tags":["vue"]},{"url":"/2021/06/22/webpack/FIS/","content":"基本使用\n特点：高度集成拥有内置的任务，开发只需要配置调试\n安装：yarn global add fis3 \n构建：\n\n\n会自动将资源的引入路径变为绝对路径\nfis3 release\nfis3 release -d output\nfis-conf.js文件配置fis.match(&#x27;*.&#123;js,css,png&#125;&#x27;,&#123;  release:&#x27;/assets/$0&#x27;&#125;)fis.match(&#x27;**/*.scss&#x27;,&#123;  rExt:&#x27;.css&#x27;,  parser:fis.plugin(&#x27;node-sass&#x27;),  optmizer:fis.plugin(&#x27;clean-css&#x27;)&#125;)fis.match(&#x27;**/*.js&#x27;,&#123;  parser:fis.plugin(&#x27;babel-6.x&#x27;),  optmizer:fis.plugin(&#x27;uglify-js&#x27;)&#125;)\n\n\n编译与压缩\n\n\nyarn add fis-parser-node-sass –dev\nyarn add fis-parser-babel-6.x –dev\n\n\nfis3 inspect\n\n"},{"url":"/2021/06/22/webpack/Parcel/","content":"Parcel\n安装\nyarn add parcel-bundler –dev\n\n入口文件\n\nsrc/index.html   (官方推荐，支持是任意类型的文件)\n\n运行\n\nyarn parcel src/index.html\n根据命令找到 index.html 文件，再根据 script 标签找到 main.js 文件，再根据 import 语句找到对应的 foo 模块，从而完成整体项目的打包\n\n不仅打包了应用，还开启了一个服务器（相当于 server . )，可以使用自动刷新\n\n支持模块热替换\n\n\n// main.jsif(module.hot)&#123;\t// accept只接收一个参数（callback），当前模块更新或当前模块依赖的模块更新后会自动执行\tmodule.hot.accept(() =&gt; &#123;\t\tconsole.log(&#x27;hmr&#x27;)\t&#125;)&#125;\n\n\n自动安装依赖\n\n不用手动依赖，直接导入，文件保存后parcel会自动帮我们安装这个依赖\nimport $ from &#x27;jquery&#x27;....\n\n\n可以加载其他资源文件，直接导入使用，不用具体配置\n\n支持动态导入，内部会自动拆分代码\n\n\nimport(&#x27;jquery&#x27;).then(() =&gt; &#123;....&#125;)\n\n\nparcel 以生产模式运行打包\n\nyarn parcel build src/index.html\n\n\nparcel 与 webpack\nparcel 构建速度比webpack 快很多，因为parcel 内部实现了多进程同时去工作\n\n"},{"url":"/2021/06/22/webpack/grunt/","content":"Grunt\n安装yarn add grunt\n添加gruntfile.js文件\n\n\ngrunt.registerTask 用来注册任务\ngrunt.registerTask(‘default’,[‘foo’,’bar’]) 默认任务，可以默认执行多个任务\n异步任务/* Grunt入口文件*  用于定义一些需要 Grunt 自动执行的任务*  需要导出一个函数*  此函数接收一个grunt的形参，内部提供一些创建任务时可以用到的 API** */module.exports = grunt =&gt; &#123;  grunt.registerTask(&#x27;foo&#x27;, () =&gt; &#123;    console.log(&#x27;heoo&#x27;)    return false  // 任务执行失败  &#125;)  grunt.registerTask(&#x27;bar&#x27;, &#x27;任务描述&#x27;,() =&gt; &#123;    console.log(&#x27;other&#x27;)  &#125;)  // grunt默认任务  /*grunt.registerTask(&#x27;default&#x27;,() =&gt; &#123;    console.log(&#x27;default&#x27;)  &#125;)*/  // 默认执行数组中的任务 [&#x27;foo&#x27;,&#x27;bar&#x27;]，前面的任务执行失败，后面的任务就不会执行  grunt.registerTask(&#x27;default&#x27;,[&#x27;foo&#x27;,&#x27;bar&#x27;])  // 异步任务  grunt.registerTask(&#x27;async-task&#x27;,function () &#123;    const done = this.async()    setTimeout(() =&gt; &#123;      console.log(&#x27;async task&#x27;)      // done()  // 任务已经完成，done完，grunt才会结束      done(false) // 标记异步任务失败    &#125;,1000)  &#125;)&#125;\n\n\n运行 yarn grunt bar\n查看grunt帮助信息 yarn grunt –help\n执行默认任务 yarn grunt  //yarn grunt default\n异步任务 \n\n\n需要调用 this.async() 标识任务执行完了\n\n\n标记任务失败： return false\n\n\n通过default执行多个任务时，前面的任务失败了，后面的就不会执行了\n强制全部执行  yarn grunt default –force\n异步任务标记失败 done(false)\n\n配置\ngrunt.initConfig 配置\n获取配置 grunt.config(‘foo’)module.exports = grunt =&gt; &#123;  // 配置  grunt.initConfig(&#123;    // foo:&#x27;bar&#x27;    foo:&#123;      bar:123    &#125;  &#125;)  grunt.registerTask(&#x27;foo&#x27;,() =&gt; &#123;    // 获取配置    // console.log(grunt.config(&#x27;foo&#x27;))    console.log(grunt.config(&#x27;foo.bar&#x27;))    const foo = grunt.config(&#x27;foo&#x27;)    console.log(foo.bar)  &#125;)&#125;\n\ngrunt多目标任务\n运行目标任务  yarn grunt build\n运行某个目标任务 yarn grunt build:foo// 多目标任务module.exports = grunt =&gt; &#123;  grunt.initConfig(&#123;    build:&#123;      // options 是配置，，其他的都是目标任务      options:&#123;        foo:&#x27;bar&#x27;,        ddd:&#x27;34&#x27;      &#125;,      foo:&#123;        // 目标任务里的配置同个属性会覆盖build的配置        options: &#123;          foo:123,          css:&#x27;abc&#x27;        &#125;      &#125;,      bar:&#x27;abc&#x27;    &#125;  &#125;)  // 多目标模式，可以让任务根据配置生成多个任务  grunt.registerMultiTask(&#x27;build&#x27;,function () &#123;    console.log(this.options())  // 获取配置    console.log(`target: $&#123;this.target&#125;,data: $&#123;this.data&#125;`) // this.target 当前执行的目标任务，this.data 目标任务的值  &#125;)&#125;\n\ngrunt插件的使用\n安装插件yarn add grunt-contrib-clean  // 自动清除项目在开发过程中产生的临时文件\n加载任务grunt.loadNpmTasks(‘grunt-contrib-clean’) 方法加载\n为任务添加配置选项module.exports = grunt =&gt; &#123;  grunt.initConfig(&#123;    clean:&#123;      // temp:&#x27;temp/app.js&#x27;      // temp:&#x27;temp/*.txt&#x27;  // 所有的txt文件      temp:&#x27;temp/**&#x27;  // 所有的子目录及子目录里的文件,连同temp文件夹删除    &#125;  &#125;)  grunt.loadNpmTasks(&#x27;grunt-contrib-clean&#x27;)&#125;\ngrunt常用插件\ngrunt-sass  \n\n\n安装 yarn add grunt-sass sass –dev\n\n\ngrunt-babel  \n\n\nyarn add grunt-babel  @babel/core @babel/preset-env –dev\n\n\nload-grunt-tasks  \n\n\nyarn add load-grunt-tasks –dev  自动加载所有的 grunt 插件中的任务\nloadGruntTasks(grunt)\n\n\ngrunt-contrib-watch\n\n\nyarn add grunt-contrib-watch –dev\n监听文件变化\n\nconst sass = require(&#x27;sass&#x27;)const loadGruntTasks = require(&#x27;load-grunt-tasks&#x27;)module.exports = grunt =&gt; &#123;  grunt.initConfig(&#123;    clean:&#123;      // temp:&#x27;temp/app.js&#x27;      // temp:&#x27;temp/*.txt&#x27;  // 所有的txt文件      temp:&#x27;temp/**&#x27;  // 所有的子目录及子目录里的文件,连同temp文件夹删除    &#125;,    sass:&#123;      options:&#123;        sourceMap:true,        implementation:sass      &#125;,      main:&#123;        files:&#123;          &#x27;dist/css/main.css&#x27;:&#x27;src/scss/main.scss&#x27; // 键：输出路径，值：源码路径        &#125;      &#125;    &#125;,    babel:&#123;      options:&#123;        sourceMap:true,        presets:[&#x27;@babel/preset-env&#x27;]      &#125;,      main:&#123;        files:&#123;          &#x27;dist/js/app.js&#x27;:&#x27;src/js/app.js&#x27;// 键：输出路径，值：源码路径        &#125;      &#125;    &#125;,    watch:&#123;      js:&#123;        files:[&#x27;src/js/app.js&#x27;],        tasks:[&#x27;babel&#x27;]      &#125;,      css:&#123;        files:[&#x27;src/scss/*.scss&#x27;],        tasks:[&#x27;sass&#x27;]      &#125;    &#125;  &#125;)  // grunt.loadNpmTasks(&#x27;grunt-contrib-clean&#x27;)  // grunt.loadNpmTasks(&#x27;grunt-sass&#x27;)  loadGruntTasks(grunt)  // 自动加载所有的 grunt 插件中的任务  grunt.registerTask(&#x27;default&#x27;,[&#x27;sass&#x27;,&#x27;babel&#x27;,&#x27;watch&#x27;])&#125;\n"},{"url":"/2021/06/22/webpack/rollup/","content":"Rollup更为小巧，仅仅是一款 ESM 打包器\n不支持 HMR 模块热替换等功能\n\n安装 \nyarn add rollup –dev\n\n运行\nyarn rollup   ——–不传递参数的情况下会打印出帮助信息\nyarn rollup ./src/index.js –format iife   ——format 指定输出格式（iife自调用函数）\nyarn rollup ./src/index.js –format iife –file dist/bundle.js  —–file 指定输出路径\n\nrollup   默认会开启 tree-shaking 优化\n\n配置文件\nyarn rollup –config    ——运行读取配置文件\nyarn rollup –config rollup.config.js\n// rollup.config.jsexport default &#123;\tinput:&#x27;src/index.js&#x27;,   // 入口\toutput:&#123;\t\tfile:&#x27;dist/bundle.js&#x27;,  // 输出文件名\t\tformat:&#x27;iife&#x27;   // 输出格式\t&#125;&#125;\n使用插件\n插件是 Rollup 的唯一扩展途径\n\nrollup-plugin-json  —–在代码中通过 import 导入 json 文件\nrollup-plugin-node-resolve —–加载 npm 模块\nrollup-plugin-commonjs   ——- 加载 commonjs 模块\n\nimport json from &#x27;rollup-plugin-json&#x27;import resolve from &#x27;rollup-plugin-node-resolve&#x27;import commonjs from &#x27;rollup-plugin-commonjs&#x27;export default &#123;\tinput:&#x27;src/index.js&#x27;,   // 入口\toutput:&#123;\t\tfile:&#x27;dist/bundle.js&#x27;,  // 输出文件名\t\tformat:&#x27;iife&#x27;   // 输出格式\t&#125;,\tplugins:[\t\tjson(),        resolve(),        commonjs()\t]&#125;\n代码拆分\n动态导入-按需加载\n* 必须使用 AMD 或者 commonjs 的标准\n* 需要输出多个文件，需要修改配置文件\n\nimport(&#x27;./logger&#x27;).then(&#123; log &#125;) =&gt; &#123;\tlog(&#x27;code&#x27;)&#125;// rollup.config.jsexport default &#123;\tinput:&#x27;src/index.js&#x27;,   // 入口\toutput:&#123;\t\tdir:&#x27;dist&#x27;,  // 输出文件路径\t\tformat:&#x27;amd&#x27;   // 输出格式\t&#125;,\tplugins:[\t\tjson(),        resolve(),        commonjs()\t]&#125;\n多入口打包\n会将公共的地方提取出来作为单独的bundle\n将 input 设置为 数组[ ] ,或者对象 { }，此时输出格式不能为 iife,,可以设置成 amd\namd 格式的文件不能直接引用到页面上，而是需要专门的库去加载\n​    \n// rollup.config.jsexport default &#123;\tinput:[&#x27;src/index.js&#x27;,&#x27;logger.js&#x27;],   // 多入口\toutput:&#123;\t\tdir:&#x27;dist&#x27;,  // 输出文件路径\t\tformat:&#x27;amd&#x27;   // 输出格式\t&#125;,\tplugins:[\t\tjson(),        resolve(),        commonjs()\t]&#125;\n\nrollup 与 webpack 选用原则\nrollup 优点：\n\n输出结果更加扁平\n自动移除未引用代码\n打包结果依然完全可读\n\n\nrollup 缺点：\n\n加载非 ESM 的第三方模块比较复杂\n模块最终被打包到一个函数中，无法实现 HMR\n浏览器环境中，代码拆分功能依赖 AMD\n\n\n如果我们正在开发应用程序 ：webpack\n\n如果我们正在开发一个框架或者类库 ： rollup\n例如：vue、react\n\nwebpack 大而全，rollup 小而美\n\n\n"},{"url":"/2021/06/22/webpack/tapable/","content":"tapable本身是一个独立的库\n工作流程\n实例化 hook 注册事件监听\n通过 hook 触发事件监听\n执行懒编译生成的可执行代码\n\nhook本质是 tapable 实例对象\nhook 执行机制可分为 同步 和 异步，异步 存在 并行 和 串行 两种模式\nhook 执行特点\nHook：普通钩子，监听器之间互相独立不干扰\nBailHook：熔断钩子，监听某个钩子返回非 undefined 时后续不执行\nWaterfallHook：瀑布钩子，上一个监听的返回值可传递至下一个\nLoopHook：循环钩子，如果当前未返回 false或者undefined 则一直执行\n\ntapable 同步钩子\nSyncHook\nSyncBailHook\nSyncWaterfallHook\nSyncLoopHook\n\ntapable 异步串行钩子\nAsyncSeriesHook\nAsyncSeriesBailHook\nAsyncSeriesWaterfallHook\n\ntapable 异步并行钩子\nAsyncParalleHook\nAsyncParalleBailHook\n\n同步钩子使用\nSyncHook\n// 导入钩子类const &#123; SyncHook &#125; = require(&#x27;tapable&#x27;)// 实例化类实例let hook = new SyncHook([&#x27;name&#x27;, &#x27;age&#x27;])// 添加事件监听hook.tap(&#x27;fn1&#x27;, function (name, age) &#123;  console.log(&#x27;fn1---&gt;&#x27;, name, age)&#125;)hook.tap(&#x27;fn2&#x27;, function (name, age) &#123;  console.log(&#x27;fn2---&gt;&#x27;, name, age)&#125;)hook.tap(&#x27;fn3&#x27;, function (name, age) &#123;  console.log(&#x27;fn3---&gt;&#x27;, name, age)&#125;)// 触发事件监听hook.call(&#x27;bom&#x27;, 18)\nSyncBailHook\n监听某个钩子返回非 undefined 时后续不执行\n// 导入钩子类const &#123; SyncBailHook &#125; = require(&#x27;tapable&#x27;)// 实例化类实例let hook = new SyncBailHook([&#x27;name&#x27;,&#x27;age&#x27;])// 添加事件监听hook.tap(&#x27;fn1&#x27;,function (name, age) &#123;  console.log(&#x27;fn1---&gt;&#x27;,name,age)&#125;)hook.tap(&#x27;fn2&#x27;,function (name, age) &#123;  console.log(&#x27;fn2---&gt;&#x27;,name,age)  return undefined&#125;)hook.tap(&#x27;fn3&#x27;,function (name, age) &#123;  console.log(&#x27;fn3---&gt;&#x27;,name,age)&#125;)// 触发事件监听hook.call(&#x27;lg&#x27;,18)\nSyncWaterfallHook\n上一个监听的返回值可传递至下一个\n// 实例化类实例let hook = new SyncWaterfallHook([&#x27;name&#x27;,&#x27;age&#x27;])// 添加事件监听hook.tap(&#x27;fn1&#x27;,function (name, age) &#123;  console.log(&#x27;fn1---&gt;&#x27;,name,age)  return &#x27;ret1&#x27;&#125;)hook.tap(&#x27;fn2&#x27;,function (name, age) &#123;  console.log(&#x27;fn2---&gt;&#x27;,name,age)  return &#x27;ret2&#x27;&#125;)hook.tap(&#x27;fn3&#x27;,function (name, age) &#123;  console.log(&#x27;fn3---&gt;&#x27;,name,age)  return &#x27;ret3&#x27;&#125;)// 触发事件监听hook.call(&#x27;lg&#x27;,33)\nSyncLoopHook\n如果当前未返回 false或者undefined 则一直执行\n// 导入钩子类const &#123; SyncLoopHook &#125; = require(&#x27;tapable&#x27;)// 实例化类实例let hook = new SyncLoopHook([&#x27;name&#x27;,&#x27;age&#x27;])let count1 = 0let count2 = 0let count3 = 0// 添加事件监听hook.tap(&#x27;fn1&#x27;,function (name, age) &#123;  console.log(&#x27;fn1---&gt;&#x27;,name,age)  if(++count1 === 1)&#123;    count1 = 0    return undefined  &#125;  return true&#125;)hook.tap(&#x27;fn2&#x27;,function (name, age) &#123;  console.log(&#x27;fn2---&gt;&#x27;,name,age)  if(++count2 === 2)&#123;    count2 = 0    return undefined  &#125;  return true&#125;)hook.tap(&#x27;fn3&#x27;,function (name, age) &#123;  console.log(&#x27;fn3---&gt;&#x27;,name,age)&#125;)// 触发事件监听hook.call(&#x27;lg&#x27;,12)\n\n异步钩子使用对于异步钩子的使用，在添加事件监听时会存在三种方式：tap tapAsync tapPromise\n异步并行\nAsyncParalleHook\nconst &#123; AsyncParallelHook &#125; = require(&#x27;tapable&#x27;)let hook = new AsyncParallelHook([&#x27;name&#x27;])// 对于异步钩子的使用，在添加事件监听时会存在三种方式：tap tapAsync tapPromise\n\n// 01 tapconsole.time(&#x27;time&#x27;)hook.tap(&#x27;fn1&#x27;,function (name) &#123;  console.log(&#x27;fn1---&gt;&#x27;,name)&#125;)hook.tap(&#x27;fn2&#x27;,function (name) &#123;  console.log(&#x27;fn2---&gt;&#x27;,name)&#125;)hook.callAsync(&#x27;lg&#x27;,() =&gt; &#123;  console.log(&#x27;lg-last&#x27;)  console.timeEnd(&#x27;time&#x27;)&#125;)\n\n// 02 tapAsyncconsole.time(&#x27;time&#x27;)hook.tapAsync(&#x27;fn1&#x27;,function (name,callback) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;fn1---&gt;&#x27;,name)    callback()  &#125;,1000)&#125;)hook.tapAsync(&#x27;fn2&#x27;,function (name,callback) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;fn2---&gt;&#x27;,name)    callback()  &#125;,2000)&#125;)hook.callAsync(&#x27;lg&#x27;,() =&gt; &#123;  console.log(&#x27;lg-last&#x27;)  console.timeEnd(&#x27;time&#x27;)&#125;)\n\n// 03 tapPromiseconsole.time(&#x27;time&#x27;)hook.tapPromise(&#x27;fn1&#x27;,function (name) &#123;  return new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#x27;fn1---&gt;&#x27;,name)      resolve()    &#125;,1000)  &#125;)&#125;)hook.tapPromise(&#x27;fn2&#x27;,function (name) &#123;  return new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#x27;fn2---&gt;&#x27;,name)      resolve()    &#125;,2000)  &#125;)&#125;)hook.promise(&#x27;foo&#x27;).then(() =&gt; &#123;  console.log(&#x27;end&#x27;)  console.timeEnd(&#x27;time&#x27;)&#125;)\nAsyncParalleBailHook\nconst &#123; AsyncParallelBailHook &#125; = require(&#x27;tapable&#x27;)let hook = new AsyncParallelBailHook([&#x27;name&#x27;])// 对于异步钩子的使用，在添加事件监听时会存在三种方式： tap tapAsync tapPromise// tapAsyncconsole.time(&#x27;time&#x27;)hook.tapAsync(&#x27;fn1&#x27;,function (name,callback) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;fn1---&gt;&#x27;,name)    callback()  &#125;,1000)&#125;)hook.tapAsync(&#x27;fn2&#x27;,function (name,callback) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;fn2---&gt;&#x27;,name)    callback(&#x27;err&#x27;)  &#125;,2000)&#125;)hook.tapAsync(&#x27;fn3&#x27;,function (name,callback) &#123;  setTimeout(() =&gt; &#123;    console.log(&#x27;fn3---&gt;&#x27;,name)    callback()  &#125;,3000)&#125;)hook.callAsync(&#x27;zce&#x27;,() =&gt; &#123;  console.log(&#x27;lg-last&#x27;)  console.timeEnd(&#x27;time&#x27;)&#125;)\n\n异步串行\nAsyncSeriesHook\nconst &#123; AsyncSeriesHook &#125; = require(&#x27;tapable&#x27;)let hook = new AsyncSeriesHook([&#x27;name&#x27;])// 对于异步钩子的使用，在添加事件监听时会存在三种方式： tap tapAsync tapPromise// tapPromiseconsole.time(&#x27;time&#x27;)hook.tapPromise(&#x27;fn1&#x27;,function (name) &#123;  return new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#x27;fn1---&gt;&#x27;,name)      resolve()    &#125;,1000)  &#125;)&#125;)hook.tapPromise(&#x27;fn2&#x27;,function (name) &#123;  return new Promise((resolve,reject) =&gt; &#123;    setTimeout(() =&gt; &#123;      console.log(&#x27;fn2---&gt;&#x27;,name)      resolve()    &#125;,2000)  &#125;)&#125;)hook.promise(&#x27;aqs&#x27;).then(() =&gt; &#123;  console.log(&#x27;aqs-end&#x27;)  console.timeEnd(&#x27;time&#x27;)&#125;)\n\n手写 SyncHook// Hook.jsclass Hook &#123;  constructor(args = [])&#123;    this.args = args    this.taps = [] // 将来用于存放组装好的 &#123;&#125;    this._x = undefined // 将来在代码工厂函数中会给 _x = [f1,f2,f3,...]  &#125;    tap(options,fn)&#123;    if(typeof options === &#x27;string&#x27;)&#123;      options = &#123;        name:options      &#125;    &#125;    options = Object.assign(&#123;fn&#125;,options) // &#123; fn: ... name:fn1 &#125;        // 调用以下方法将组装好的 options  添加至 []    this._insert(options)  &#125;    tapAsync(options,fn)&#123;    if(typeof options === &#x27;string&#x27;)&#123;      options = &#123;        name:options      &#125;    &#125;    options = Object.assign(&#123;fn&#125;,options) // &#123; fn: ... name:fn1 &#125;      // 调用以下方法将组装好的 options  添加至 []    this._insert(options)  &#125;    _insert(options)&#123;    this.taps[this.taps.length] = options  &#125;    call(...args)&#123;    // 01 创建将来要具体执行的函数代码结构    let callFn = this._createCall()    // 02 调用上述的函数（传参）args传入进去    return callFn.apply(this,args)  &#125;    callAsync(...args)&#123;    let callFn = this._createCall()    return callFn.apply(this,args)  &#125;    _createCall()&#123;    return this.compile(&#123;      taps:this.taps,      args:this.args    &#125;)  &#125;&#125;module.exports = Hook\n\n// SyncHook.jslet Hook = require(&#x27;./Hook&#x27;)class HookCodeFactory &#123;  args()&#123;    return this.options.args.join(&#x27;,&#x27;)  // [&quot;name&quot;,&quot;age&quot;]  ==》name,age  &#125;  head()&#123;    return `var _x = this._x;`  &#125;  content()&#123;    let code = ``    for(var i = 0; i &lt; this.options.taps.length; i++)&#123;      // code += `var _fn0 = _x[0];_fn[0](name,age)`      code += `var _fn$&#123;i&#125; = _x[$&#123;i&#125;];_fn$&#123;i&#125;($&#123;this.args()&#125;);`    &#125;    return code  &#125;  setup(instance,options)&#123;    this.options = options // 这里的操作在源码中是通过 init 方法实现的    instance._x = options.taps.map( o =&gt; o.fn)  &#125;  create(options)&#123; // 创建一段可执行的代码体然后返回    let fn    // fn = new Function(&#x27;name,age&#x27;,&#x27;var _x = this._x;var_fn0 = _x[0]; _fn0(name,age);&#x27;)    fn = new Function(      this.args(),      this.head() + this.content()    )    return fn  &#125;&#125;let factory = new HookCodeFactory()class SyncHook extends Hook&#123;  constructor(args)&#123;    super(args)  &#125;    compile(options)&#123; // &#123;taps:[&#123;&#125;,&#123;&#125;], args:[name,age]&#125;    factory.setup(this,options)    return factory.create(options)  &#125;&#125;module.exports = SyncHook\n\n\n\n\n\n手写 AsyncParalleHook// .AsyncParalleHooklet Hook = require(&#x27;./Hook&#x27;)class HookCodeFactory &#123;  args(&#123;after,before&#125; = &#123;&#125;)&#123;    let allArgs = this.options.args    if(before)allArgs = [before].concat(allArgs)    if(after) allArgs = allArgs.concat(after)    return allArgs.join(&#x27;,&#x27;)  // [&quot;name&quot;,&quot;age&quot;]  ==》name,age  &#125;  head()&#123;    return `&quot;use strict&quot;;var _context;var _x = this._x;`  &#125;  content()&#123;    let code = `var _counter = $&#123;this.options.taps.length&#125;; var _done = (function () &#123;      _callback();    &#125;);`    for(var i = 0; i &lt; this.options.taps.length; i++)&#123;      code += `var _fn$&#123;i&#125; = _x[$&#123;i&#125;];_fn$&#123;i&#125;(name, (function () &#123;        if (--_counter === 0) _done();      &#125;));`    &#125;    return code  &#125;  setup(instance,options)&#123;    this.options = options // 这里的操作在源码中是通过 init 方法实现的    instance._x = options.taps.map( o =&gt; o.fn)  &#125;  create(options)&#123; // 创建一段可执行的代码体然后返回    let fn    // fn = new Function(&#x27;name,age&#x27;,&#x27;var _x = this._x;var_fn0 = _x[0]; _fn0(name,age);&#x27;)    fn = new Function(      this.args(&#123; after:&#x27;_callback&#x27; &#125;),      this.head() + this.content()    )    return fn  &#125;&#125;let factory = new HookCodeFactory()class AsyncParalleHook extends Hook&#123;  constructor(args)&#123;    super(args)  &#125;    compile(options)&#123; // &#123;taps:[&#123;&#125;,&#123;&#125;], args:[name,age]&#125;    factory.setup(this,options)    return factory.create(options)  &#125;&#125;module.exports = AsyncParalleHook\n\n"},{"title":"vite","url":"/2021/06/01/webpack/vite/","content":"项目地址：https://gitee.com/endeavor1/q-vite-cli\nVite 概念\nVite 是一个面向现代浏览器的一个更轻、更快的 Web 应用开发工具\n它基于 ECMAScript 标准原生模块系统（ES Module）实现\n解决 webpack 在开发阶段 使用 dev-server 冷启动时间过长，另外 热更新 反应慢的问题\n\nVite 项目依赖\nVite\n@vue/compiler-sfc\n\nVite 创建项目\n使用 npm \n$ npm init @vitejs/app &lt;project-name&gt;$ cd &lt;project-name&gt;$ npm install$ npm run dev\n使用 yarn\n$ yarn create @vitejs/app &lt;project-name&gt;$ cd &lt;project-name&gt;$ yarn$ yarn dev\n\n基础使用vite serve\n编译是在服务器端\n模块的处理是在请求到服务器端处理的\n采用即时编译，按需编译\n\n\n\nvue-cli-service serve 对比\n先打包，打包结果存储到内存中才会启动 web serve ，不管模块是否使用到，都会打包到 bundle里，项目体积大，打包速度就会变慢\n\n\n\n\n\nHMR\nVite HMR\n\n立即编译当前所修改的文件\n\n\nWebpack HMR\n\n会自动以这个文件为入口重写 build 一次，所有涉及到的依赖也都会被加载一遍\n\n\n\n\n\nvite build\nRollup\nDynamic import (代码切割)\nPolyfill\n\n\n\n打包 or 不打包：\n使用 Webpack 打包的两个原因：\n\n浏览器环境并不支持模块化\n\n零散的模块文件会产生大量的 HTTP 请求\n\n\nVite 特性\n快速冷启动\n模块热更新\n按需编译\n开箱即用\n\nVite 核心功能\n静态 Web 服务器\n编译单文件组件\n拦截浏览器不识别的模块，并处理\n\n\nHMR\n\nVite 实现原理\nvite 通过对请求路径劫持获取资源的内容返回给浏览器\nvite 热更新实现在 client 端，webSocket 监听了一些更新的类型\nvite 热更新实现在 server 端，通过 watcher 监听页面改动\n\n使用 koa 开启一个 服务器\n\npackage.json 文件中添加 bin 字段，作为 cli 工具的入口\n&quot;name&quot;: &quot;q-vite-cli&quot;,&quot;bin&quot;: &quot;index.js&quot;,\nindex.js 文件里开启 Koa 服务器\n#!/usr/bin/env nodeconst Koa = require(&#x27;koa&#x27;)const send = require(&#x27;koa-send&#x27;)const app = new Koa()// 1. 开启静态文件服务器app.use(async (ctx,next) =&gt; &#123;  await send(ctx, ctx.path, &#123; root: process.cwd(), index: &#x27;index.html&#x27;&#125;)  await next()&#125;)app.listen(3000)console.log(&#x27;Server running @ http://localhost:3000&#x27;)\nnpm link \n\nvue 3 项目中 使用  q-vite-cli ,启动项目\n\n报错： Uncaught TypeError: Failed to resolve module specifier &quot;vue&quot;. Relative references must start with either &quot;/&quot;, &quot;./&quot;, or &quot;../&quot;.\n原因：main.js 请求中  import &#123; createApp &#125; from &#39;vue&#39;时报错\n\n\n\n修改第三方模块的路径\n需要创建两个中间件：\n\n一个中间件用来修改 node_modules 模块的引入路径，修改为 /@modules/模块名称\n// 把流转换为字符串const streamToString = stream =&gt; new Promise((resolve,reject) =&gt; &#123;  const chunks = []  stream.on(&#x27;data&#x27;,chunk =&gt; chunks.push(chunk))  stream.on(&#x27;end&#x27;,() =&gt; resolve(Buffer.concat(chunks).toString(&#x27;utf-8&#x27;)))  stream.on(&#x27;error&#x27;,reject)&#125;)// 2. 修改第三方模块的路径app.use(async (ctx,next) =&gt; &#123;  if(ctx.type === &#x27;application/javascript&#x27;)&#123;    // ctx.body 是一个流    const contents = await streamToString(ctx.body)    // import Vue from &#x27;vue&#x27;    // import App from &#x27;./App.vue&#x27; || &#x27;/App.vue&#x27;    ctx.body = contents.replace(/(from\\s+[&#x27;&quot;])(?![\\.\\/])/g,&#x27;$1/@modules/&#x27;)  &#125;&#125;)\n\n更改配置后需关闭服务器，重新启动  q-vite-cli \n\n另一个中间件是当请求处理回来后判断请求中是否有 /@modules/模块名称\n\n需要放在 开启静态文件服务器 中间件之前\n\n\n\n**加载第三方模块 **\n\n需要放在 开启静态文件服务器 中间件之前\nconst path = require(&#x27;path&#x27;)// 3. 加载第三方模块app.use(async (ctx,next) =&gt; &#123;  // ctx.path --&gt; /@modules/vue  if(ctx.path.startsWith(&#x27;/@modules&#x27;))&#123;    const moduleName = ctx.path.substr(10)    const pkgPath = path.join(process.cwd(),&#x27;node_modules&#x27;,moduleName,&#x27;package.json&#x27;)    const pkg = require(pkgPath)    ctx.path = path.join(&#x27;/node_modules&#x27;,moduleName,pkg.module)  &#125;  console.log(ctx.path)  await next()&#125;)\n\n编译单文件组件\n\n开启静态文件服务器中间件 和 修改第三方模块的路径中间件 之间\n\n需要使用 @vue/compiler-sfc npm i @vue/compiler-sfc\nconst &#123; Readable &#125; = require(&#x27;stream&#x27;)const compilerSFC = require(&#x27;@vue/compiler-sfc&#x27;)// 把字符串转换为流const stringTostream = text =&gt; &#123;  const stream = new Readable()  stream.push(text)  stream.push(null)  return stream&#125;// 4. 处理单文件组件app.use(async (ctx,next) =&gt; &#123;  if(ctx.path.endsWith(&#x27;.vue&#x27;))&#123;    const contents = await streamToString(ctx.body)    const &#123; descriptor &#125; = compilerSFC.parse(contents)    let code    if(!ctx.query.type)&#123;      // 单文件组件第一次请求      code = descriptor.script.content      code = code.replace(/export\\s+default\\s+/g,&#x27;const __script = &#x27;)      code += `        import &#123; render as __render &#125; from &quot;$&#123;ctx.path&#125;?type=template&quot;        __script.render = __render        export default __script      `    &#125;else if(ctx.query.type === &#x27;template&#x27;)&#123;      // 单文件组件第二次请求      const templateRender = compilerSFC.compileTemplate(&#123; source: descriptor.template.content &#125;)      code = templateRender.code    &#125;    ctx.type = &#x27;application/javascript&#x27;    ctx.body = stringTostream(code)  &#125;  await next()&#125;)\n报错：process is not defined，解决：\n// 2. 修改第三方模块的路径app.use(async (ctx,next) =&gt; &#123;  if(ctx.type === &#x27;application/javascript&#x27;)&#123;    // ctx.body 是一个流    const contents = await streamToString(ctx.body)    // import Vue from &#x27;vue&#x27;    // import App from &#x27;./App.vue&#x27;    ctx.body = contents      .replace(/(from\\s+[&#x27;&quot;])(?![\\.\\/])/g,&#x27;$1/@modules/&#x27;)      .replace(/process\\.env\\.NODE_ENV/g,&#x27;&quot;development&quot;&#x27;)  &#125;&#125;)\n\n","categories":["打包"],"tags":["vue","vite"]},{"url":"/2021/06/22/webpack/webpack%E4%BC%98%E5%8C%96/","content":"内置优化DefinePlugin\nwebpack内置插件\n\nproduction环境下默认启用\n\n为代码注入全局成员\n\nprocess.env.NODE_ENV\n\n使用\nconst webpack = require(&#x27;webpack&#x27;)plugins: [\tnew webpack.DefinePlugin(&#123;\t\tAPI_BASE_URL:&#x27;&quot;https://api.example.com&quot;&#x27;，\t\tAPI_BASE_URL:JSON.stringfy(&#x27;https://api.example.com&#x27;)，\t\t// 要求一段代码片段，如果是值的话需要 JSON.stringfy()转换\t&#125;)]// main.jsconsole.log(API_BASE_URL)   =&gt; 将“https://api.example.com”直接替换到代码中，没有引号\n\nTree Shaking\n移除未引用代码（console等，未引用的代码）\n\nproduction环境下默认启用\n\n不是某个配置选项，是一组功能搭配使用后的优化效果\n// 集中配置 webpack 内置的优化功能optimization:&#123;\tusedExports:true,  // Tree-shaking 输出结果中只导出外部使用了的成员\tminimize:true   // 开启压缩功能，移除掉没有引用的代码&#125;\n\n合并模块\n尽可能将所有模块合并输出到一个函数中\n\n既提升了运行效率，又减少了代码的体积\n\nScope Hositing 作用域提升\n// 集中配置 webpack 内置的优化功能optimization:&#123;\tusedExports:true,  // 输出结果中只导出外部使用了的成员\tconcatenateModules:true, // 合并模块&#125;\n\nTree-shaking 与 Babel\n Tree-shaking 前提是 ES Modules 打包代码，即交给 webpack 打包的代码必须使用 ESM 模块化\n\n使用 babel-loader 的插件 ‘@babel/preset-env’ 会使 ES Module 转换为 CommonJS ,所以 Tree-shaking 失效\n\n在最新版本的  babel-loader  已经关闭了将 ES Module 转换为 CommonJS ，所以 Tree-shaking 不会失效\n\n为了确保，可以强制 [‘@babel/preset-env’,{ modules: false }]\n// 试验 开启转换为 CommonJS ，Tree-shaking 失效&#123;    test:/.js$/,    use:&#123;        loader:&#x27;babel-loader&#x27;,        options:&#123;        // presets里边是数组套数组        \tpresets:[        \t\t[&#x27;@babel/preset-env&#x27;,&#123; modules: &#x27;commonjs&#x27; &#125;]        \t\t// [&#x27;@babel/preset-env&#x27;,&#123; modules: false &#125;] 确保不会转换        \t]        &#125;    &#125;&#125;\n\nsideEffects\nsideEffects 一般用于 npm 包标记是否有副作用\n\n解决 index 文件中引入了所有的依赖，这样就会都打包，但是只想打包其中一个，可以开启sideEffects\n\nproduction环境下默认启用\n\n会根据 package.json 文件中配置的 “sideEffects” 判断这个模块是否有副作用，如果没有副作用，那么没有引用到的模块就不会打包\n// 集中配置 webpack 内置的优化功能optimization:&#123; \tsideEffects:true  // 开启这个功能&#125;// package.json&#123;\t...\t&quot;sideEffects&quot;:false  // 以此判断这个模块是否有副作用，false-没有副作用&#125;\n副作用代码\n\n一个模块里给给数组 对象啥的扩展方法\n导入 css 代码\n解决， package.json 文件中配置 “sideEffects” \n\n// package.json&#123;\t...\t&quot;sideEffects&quot;:[\t\t&quot;./src/extend.js&quot;,\t\t&quot;*.css&quot;\t]&#125;\n\nWebpack 优化代码分割 Code Splitting\nwebpack 所有代码都打包一起，导致打包结果体积过大\n\n并不是每个模块在启动时都是必要的\n\n所以需要分包，按需加载\n\n分包方式：\n\n多入口打包：适用于多页面应用程序，不同页面不同打包结果，公共部分单独提取\n缺点：有公共的部分，这样会导致不同的打包结果中会有相同的模块\n解决：提取公共模块\n\n动态导入：按需加载\n需要用到某个模块时再去加载，节省带宽和流量\n动态导入的模块会被自动分包，公共的模块会自动提取到单独的包\n\n\n// 1.多入口打包 -多页面应用程序// entry 定义为数组的话，会把多个页面打包到一起，所入口需要是个对象// 不使用插件配置 chunks，会导致每个 HTML 把所有打包好的 js 文件都引入了// new HtmlWebpackPlugin 里 chunks 里指定需要引入的 bundle// 提取公共模块module.exports = &#123;\tentry:&#123;\t\tindex:&#x27;./src/index.js&#x27;,\t\talbum:&#x27;./src/album.js&#x27;\t&#125;,\toutput:&#123;\t\tfilename:&#x27;[name].bundle.js&#x27; // name 动态获取入口文件的名称\t&#125;,\toptimization:&#123;\t\tsplitChunks:&#123;\t\t\tchunks:&#x27;all&#x27;  // 将公共模块都提取到单独的bundle中\t\t&#125;\t&#125;,\tplugins:[\t\tnew HtmlWebpackPlugin(&#123;\t\t\ttitle:&#x27;Multi Entry&#x27;,\t\t\ttemplate:&#x27;./src/index.html&#x27;,\t\t\tfilename:&#x27;index.html&#x27;,\t\t\tchunks:[&#x27;index&#x27;]\t\t&#125;),\t\tnew HtmlWebpackPlugin(&#123;\t\t\ttitle:&#x27;Multi Entry&#x27;,\t\t\ttemplate:&#x27;./src/album.html&#x27;,\t\t\tfilename:&#x27;album.html&#x27;,\t\t\tchunks:[&#x27;album&#x27;]\t\t&#125;)\t]&#125;\n\n// 动态导入 - 按需加载// 不需要修改配置，只需要将文件导入方式改变动态导入// 比如动态导入实现路由懒加载// 之前是 import posts from &#x27;./posts/posts&#x27;// 改为在用到的地方动态导入import(&#x27;./posts/posts&#x27;).then((&#123; default: posts &#125;) =&gt; &#123;\tmainElement.appendChild(posts())&#125;)\n\n魔法注释\n动态导入的文件产生的打包结果文件名称默认只是一个序号\n\n使用魔法注释可以给这些 bundle 命名，动态导入时添加 /* webpackChunkName:’posts’ */\n\n如果给相同的 webpackChunkName 的话，模块会被打包到一起\nimport(/* webpackChunkName:&#x27;posts&#x27; */&#x27;./posts/posts&#x27;).then((&#123; default: posts &#125;) =&gt; &#123;\tmainElement.appendChild(posts())&#125;)\n\nMiniCssExtractPlugin 提取CSS 到单个文件\n实现 css 模块的按需加载\n\nstyle-loader 将样式通过 style 标签注入，使用 MiniCssExtractPlugin  的话就不需要使用 style-loader ，直接 link 引入，需要使用 MiniCssExtractPlugin.loader\n\n如果样式文件 超过 150kb左右才会考虑 提取CSS 到单个文件，否则样式文件太小的话会适得其反\n// MiniCssExtractPlugin // style-loader 将样式通过 style 标签注入，使用 MiniCssExtractPlugin  的话就不需要使用 style-loader ，需要使用 MiniCssExtractPlugin.loaderconst MiniCssExtractPlugin = require(&#x27;mini-css-extract-plugin&#x27;)module:&#123;\t&#123;        test: /\\.css$/,        use: [            MiniCssExtractPlugin.loader,            &#x27;css-loader&#x27;        ]    &#125;,&#125;,plugins:[\tnew MiniCssExtractPlugin()]\n\nOptimizeCssAssetsWebpackPlugin\n生产模式下只会自动压缩js代码，不会自动压缩其他文件代码\n\noptimize-css-assets-webpack-plugin 压缩 css\n\nconst OptimizeCssAssetsWebpackPlugin = require(&#x27;optimize-css-assets-webpack-plugin&#x27;)const TerserWebpackPlugin = require(&#x27;terser-webpack-plugin&#x27;)// 配置到plugins中，任何情况下都会压缩plugins:[\tnew OptimizeCssAssetsWebpackPlugin()]// 配置到 optimization 的minimizer 数组中,通过 minimize 选项统一控制// 生产环境中 minimize 会自动开启// 设置了 minimizer 后，webpack 不会自动压缩 js 代码，因为webpack认为我们要自定义 压缩器，内部的js压缩器就会被覆盖掉,需要手动添加optimization:&#123; \tminimizer:[\t\tnew TerserWebpackPlugin()  // js 压缩器\t\tnew OptimizeCssAssetsWebpackPlugin()  // css 压缩器\t]&#125;\n\n输出文件名 hash\n解决 缓存 问题，生产模式下，文件名使用 Hash\n\nfilename 都支持 hash  值\n\nhash\n项目级别的，项目有任何一个地方发生改变，hash 值都会变\n\nchunkhash\n\nchunk 级别的，同一路的打包，他的 chunkhash 就相同\n\ncontenthash\n\n根据输出文件的内容生成 hash 值，不同的文件就会有不同的 hash 值\n\n执行 hash 的长度\n\ncontenthash:8  – 指定长度为 8\noutput:&#123;\t\tfilename:&#x27;[name]-[contenthash:8].bundle.js&#x27; // name 动态获取入口文件的名称\t&#125;,plugins:[\tnew MiniCssExtractPlugin(&#123;\t\tfilename:&#x27;[name]-[contenthash:8].bundle.css&#x27;\t&#125;)]\n\n"},{"url":"/2021/06/22/webpack/webpack%E5%8A%9F%E8%83%BD%E5%87%BD%E6%95%B0/","content":"简单打包分析\n01 打包后的文件就是一个函数自调用，当前函数调用时传入一个对象\n\n02 这个对象我们为了方便将之称为是模块定义，他就是一个键值对\n\n03 这个键名就是当前被加载模块的文件名与某个目录的拼接\n\n04 这个键值就是一个函数，和 node.js 里的模块加载有一些类似，会将被加载模块中的内容包裹于一个函数中\n\n05 这个函数在将来某个时间点上会被调用，同时会接收到一定的参数，利用这些参数就可以实现模块的加载操作\n\n06 针对于上述代码就相当于是将 {}（模块定义）传递给了 modules \n\n\n功能函数分析当我们使用 webpack 进行打包的时候，最终都会产生一个或多个 js 文件，在这些文件中最终都会生成一个 自调用函数， 它接收一个对象作为参数（模块定义），它的键作为要查询的模块id，它的值作为要执行的函数，在执行函数过程中完成了当前模块id对应的模块内容加载。\n针对于不同的模块类型，webpack 会使用不同的方法\n\n __webpack_require__.t\n\n 01 接收二个参数，一个是 value 一般用于表示被加载的模块 id， 第二个值 mode 是一个二进制的数值\n\n02 t 方法内部做的第一件事就是调用自定义的 __webpack_require__ 方法加载 value 对应的模块导出，重新赋值给 value \n\n03 当获取到 value 值之后，余下的 8 4 ns 2 都是对当前的内容加工处理，然后返回使用\n\n04 当 mode &amp; 8 成立时直接将 value 返回 ()\n\n4-1 当 mode &amp; 1  mode &amp; 8 同时成立，相当于加载的是一个 commonjs 规范，可以直接使用的导出内容，直接将value 返回\n\n\n05 当 mode &amp; 4 成立时直接将 value 返回 ()\n\n5-2 当 mode &amp; 1  mode &amp; 4 同时成立，相当于加载的是一个 es module 规范，直接将value 返回\n\n\n06 当 mode &amp; 8  mode &amp; 4 都不成立，还要继续处理 value，定义一个 ns{}\n\n6-1 如果拿到的 value 是一个可以直接使用的内容，例如是一个字符串，将它挂载到 ns 的 default 属性上\n\n6-2 如果是一个对象，就会调用  __webpack_require__.d 给 ns 上添加每个属性，并给每个属性添加一个 getter\n\n\n\n\n\n\ncommonjs模块打包分析\nrequire 加载 commonjs 规范，默认支持\n只会调用__webpack_require__方法来获得值\n\nes module 模块打包分析\nes module文件的导入\n\n 调用__webpack_require__.r标记\n调用__webpack_require__方法来获得值\n 将值传给__webpack_require__.n，里面调用 __webpack_require__.d方法给exports身上添加一个 a 属性，值就是 exports\n\n\ncommonjs 引入 es module 导出的文件\n\nes module文件的导出 会调用 __webpack_require__.r方法，给其添加一个标记，标记为 es module\nes module文件的导出 会调用 __webpack_require__.d方法，给 exports 身上添加属性，给这个属性添加一个 getter\n\n\n\n懒加载实现\n01 import（）可以实现指定模块的懒加载操作\n02 当前懒加载的核心原理就是 jsonp\n03 调用__webpack_require__.e 生成一个 promise，.then 里调用__webpack_require__.t方法，第二个 .then 就是懒加载时我们写的 .then\n03  __webpack_require__.t 方法可以针对于内容进行不同的处理（处理方式取决于传入的数值 8  6  7  3  2  1  ）\n\n手写功能函数(function (modules) &#123;  // 14 定义 webpackJsonpCallback 实现：合并模块定义，改变 promise 状态执行后续行为  function webpackJsonpCallback(data) &#123;    // 01 获取需要被动态加载的模块 id    let chunkIds = data[0]    // 02 获取需要被动态加载的模块依赖关系对象    let moreMoudles = data[1]    // 03 循环判断 chunkIds 里对应的模块内容是否已经完成了加载    let chunkId, resolves = []    for (let i = 0; i &lt; chunkIds.length; i++) &#123;      chunkId = chunkIds[i]      if (Object.prototype.hasOwnProperty.call(installedChunks, chunkId) &amp;&amp; installedChunks[chunkId]) &#123;        resolves.push(installedChunks[chunkId][0])      &#125;      // 更新当前的 chunk 状态      installedChunks[chunkId] = 0    &#125;    for (moduleId in moreMoudles) &#123;      if (Object.prototype.hasOwnProperty.call(moreMoudles, moduleId)) &#123;        modules[moduleId] = moreMoudles[moduleId]      &#125;    &#125;    while (resolves.length) &#123;      resolves.shift()()    &#125;  &#125;  // 01 定义对象用于将来缓存被加载过的模块  let installedModules = &#123;&#125;  // 15 定义 installedChunks 用于标识某个 chunkId 对应的 chunk 是否完成了加载  let installedChunks = &#123;    main: 0  &#125;  // 02 定义一个 __webpack_require__ 方法来提换 import require 加载操作  function __webpack_require__(moduleId) &#123;    // 2-1 判断当前缓存中是否存在要被加载的模块内容，如果存在则直接返回    if (installedModules[moduleId]) return installedModules[moduleId].exports    // 2-2 如果当前缓存中不存在，则需要我们自己定义 &#123;&#125;，执行被导入的模块内容加载    let module = installedModules[moduleId] = &#123;      i: moduleId,      l: false,      exports: &#123;&#125;    &#125;    // 2-3 调用当前 moduelId 对应的函数完成对应内容的加载    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__)    // 2-4 当上述的方法调用完成之后，我们就可以修改 l 的值用于标识当前模块已经加载完成了    module.l = true    // 2-5 加载工作完成之后，要将拿回来的内容返回至调用的位置    return module.exports  &#125;  // 03 定义 m 属性用于保存 modules  __webpack_require__.m = modules  // 04 定义 c 属性用于保存 cache  __webpack_require__.c = installedModules  // 05 定义 o 方法用于判断对象的身上是否存在指定的属性  __webpack_require__.o = function (object, property) &#123;    return Object.prototype.hasOwnProperty(object, property)  &#125;  // 06 定义 d 方法用于在对象的身上添加指定的属性，同时给该属性提供一个 getter  __webpack_require__.d = function (exports, name, getter) &#123;    if (!__webpack_require__.o(exports, name)) &#123;      Object.defineProperty(exports, name, &#123;        enumerable: true,        get: getter      &#125;)    &#125;  &#125;  // 07 定义 r 方法用于标识当前模块是  es6  __webpack_require__.r = function (exports) &#123;    if (typeof Symbol !== &quot;undefined&quot; &amp;&amp; Symbol.toStringTag) &#123;      Object.defineProperty(exports, Symbol.toStringTag, &#123;        value: &#x27;Module&#x27;      &#125;)    &#125;    Object.defineProperty(exports, &#x27;__esModule&#x27;, &#123;      value: true    &#125;)  &#125;  // 08 定义 n 方法用于设置具体的 getter  __webpack_require__.n = function (module) &#123;    let getter = module &amp;&amp; module.__esModule ?      function getDefault() &#123;        return module[&#x27;default&#x27;]      &#125; :      function getModuleExports() &#123;        return module      &#125;    __webpack_require__.d(getter, &#x27;a&#x27;, getter)  &#125;  // 17 定义 jsonpScriptSrc 实现 src 的处理  function jsonpScriptSrc(chunkId) &#123;    return __webpack_require__.p + &quot;&quot; + chunkId + &#x27;.built.js&#x27;  &#125;  // 16 定义 e 方法用于实现： 实现json来加载内容，利用 promise 来实现异步加载操作  __webpack_require__.e = function (chunkId) &#123;    // 01 定义一个数组用于存放 promise    let promises = []    // 02 获取 chunkId 对应的 chunk 是否已经完成了加载    let installedChunkData = installedChunks[chunkId]    // 03 依据当前是否已完成加载的状态来执行后续的逻辑    if (installedChunkData !== 0) &#123;      if (installedChunkData) &#123;        promises.push()      &#125; else &#123;        let promise = new Promise((resolve, reject) =&gt; &#123;          installedChunkData = installedChunks[chunkId] = [resolve, reject]        &#125;)        promises.push(installedChunkData[2] = promise)        // 创建标签        let script = document.createElement(&#x27;script&#x27;)        // 设置 src        script.src = jsonpScriptSrc(chunkId)        // 写入 script 标签        document.head.appendChild(script)      &#125;    &#125;    // 执行 promise    return Promise.all(promises)  &#125;  // 11 定义 t 方法，用于加载指定 value 的模块内容，之后对内容进行处理再返回  __webpack_require__.t = function (value, mode) &#123;    // 01 加载 value 对应的模块内容（value 一般就是模块id）    // 加载之后的内容又重新赋值给 value    if (mode &amp; 1) &#123;      value = __webpack_require__(value)    &#125;    // 如果成立，加载了可以直接返回使用的内容(commonjs)    if (mode &amp; 8) &#123;      return value    &#125;    // 如果成立，加载了可以直接返回使用的内容(es module)    if ((mode &amp; 4) &amp;&amp; typeof value === &#x27;object&#x27; &amp;&amp; value &amp;&amp; value.__esModule) &#123;      return value    &#125;    // 如果 8  和  4  都没有成立，则需要自定义 ns 来通过 default 属性返回内容    let ns = Object.create(null)    __webpack_require__.r(ns)    Object.defineProperty(ns, &#x27;default&#x27;, &#123;      enumerable: true,      value: value    &#125;)    if (mode &amp; 2 &amp;&amp; typeof value !== &#x27;string&#x27;) &#123;      for (let key in value) &#123;        __webpack_require__.d(ns, key, function (key) &#123;          return value[key]        &#125;.bind(null, key))      &#125;    &#125;    return ns  &#125;  // 09 定义 p 属性用于保存资源访问路径  __webpack_require__.p = &#x27;&#x27;  // 11 定义变量存放数组  let jsonpArray = window[&#x27;webpackJsonp&#x27;] = window[&#x27;webpackJsonp&#x27;] || []  // 12 保存原生的 push 方法  let oldJsonpFunction = jsonpArray.push.bind(jsonpArray)  // 13 重写原生的 push 方法  jsonpArray.push = webpackJsonpCallback  // 10 调用 __webpack_require__ 方法，执行模块导入与加载操作  return __webpack_require__(__webpack_require__.s = &#x27;./src/index.js&#x27;)&#125;)(&#123;  &quot;./src/index.js&quot;: (function (module, exports, __webpack_require__) &#123;    let oBtn = document.getElementById(&#x27;btn&#x27;)    oBtn.addEventListener(&#x27;click&#x27;, function () &#123;      __webpack_require__.e( /*! import() | login */ &quot;login&quot;).then(__webpack_require__.t.bind(null, /*! ./login.js */ &quot;./src/login.js&quot;, 7)).then((login) =&gt; &#123;        console.log(login)      &#125;)    &#125;)    console.log(&#x27;index.js&#x27;)  &#125;)&#125;);\n\n"},{"url":"/2021/06/22/webpack/webpack%E5%9F%BA%E7%A1%80/","content":"webpack一、快速上手1. yarn init\n2. yarn add webpack webpack-cli --dev\n3. yarn webpack   (打包)默认将 ‘src/index.js&#39; 文件作为打包入口输出到 ’dist/main.js&#39;\n\n二、配置文件​    webpack.config.js\n\nentry 打包入口\n字符串：单入口  ， 相对路径的话  ./  不能省略\n数组：会把多个文件打包到一起\n对象：多入口打包，代码分包\n\noutput  打包输出路径\noutput.path  必须是绝对路径\n\nmode\n\nproduction\ndevelopment\nnone\n\n\nmodule\n\nloader —  webpack的核心特性\n借助于loader就可以加载任何类型的资源\n\n\n\nplugins\n\n解决除了资源加载的其他自动化工作\n\n清除dist目录\n\n拷贝静态文件至输出目录\n\n压缩输出代码\n\n实现前端工程化\n\n\n\n\nconst path = require(&#x27;path&#x27;)module.exports = &#123;  entry:&#x27;./src/index.js&#x27;, // 相对路径的话  ./  不能省略  output:&#123;    filename:&#x27;bundle.js&#x27;,    path:path.join(__dirname,&#x27;output&#x27;) // 必须是绝对路径  &#125;&#125;// module.exports也可以是一个数组，每一项都是单独的打包配置module.exports = [\t&#123;\t\tentry:&#x27;./src/main.js&#x27;,\t\toutput:&#123;\t\t\tfilename:&#x27;a.js&#x27;\t\t&#125;\t&#125;,\t&#123;\t\tentry:&#x27;./src/main.js&#x27;,\t\toutput:&#123;\t\t\tfilename:&#x27;b.js&#x27;\t\t&#125;\t&#125;]// module.exports也可以导出一个函数，返回配置对象// env 环境参数，argv 运行cli过程中传递的所有参数module.exports = (env,argv) =&gt; &#123;\tconst config = &#123;&#125;\tif(env === &#x27;production&#x27;)&#123;\t\tconfig.mode = &#x27;production&#x27;\t\tconfig.devtool = false\t\tconfig.plugins = [\t\t\t...config.plugins,\t\t\tnew CleanWebpackPlugin(),\t\t\tnew CopyWebpackPlugin([&#x27;public&#x27;])\t\t]\t&#125;\treturn config&#125;\n\n\n资源加载器\n\n编译转换类：加载的资源模块转换为 js 模块\n\n文件操作类：加载的资源模块拷贝的输出目录，将访问路径向外导出\n\n代码检查类：代码校验，统一代码风格，提高代码质量\n\n样式：css-loader / style-loader    \n\n文件：file-loader\n问题：404资源找不到，j解决：配置 output 的 publicPath：’dist/‘, / 不能省略\n文件加载器工作过程：webpack在打包时遇到了图片，然后根据配置文件中的配置匹配到对应的文件加载器，文件加载器就开始工作，先将导入的文件拷贝到输出的目录，再将拷贝到输入目录的路径作为当前的模块的返回值返回，对于应用来说，所需要的资源就被发布出来了，可以通过模块的导出成员拿到这个成员的访问路径\n\nURL加载器（图片）：url-loader\n配置选项 options 中的 limit 来限制大小，小文件使用 Data URLs, 减少请求次数\n大文件单独提取存放，提高加载速度\n&#123;    test:/\\.png$/,    use:&#123;        loader:&#x27;url-loader&#x27;,        options:&#123;        \tlimit:10 * 1024 // 10 kb    \t&#125;    &#125;&#125;// 这种使用方式必须安装 file-loader,超出大小限制的会使用file-loader\n代码转换：babel-loader  （@babel/core  @babel/preset-env)\nwebpack只是打包工具\n加载器可以用来编译转换代码（将es6语法编译转换为es5）\n&#123;    test:/\\.js$/,    use:&#123;        loader:&#x27;babel-loader&#x27;,        options:&#123;        \tpresets:[&#x27;@babel/preset-env&#x27;]        &#125;    &#125;&#125;\nhtml：html-loader\n&#123;    test:/\\.html$/,  // 必须有，用来匹配文件路径    use:&#123;        loader:&#x27;html-loader&#x27;,        options:&#123;        \tattrs:[&#x27;img:src&#x27;,&#x27;a:href&#x27;] // 配置打包资源        &#125;    &#125;&#125;\n\n\n常用插件\n\n清除 dist 输出目录：clean-webpack-plugin\n\n自动生成 Html  文件：html-webpack-plugin\n自动将打包的 文件 添加到 html 文件中，路径引用是动态的\n创建多个 HtmlWebpackPlugin 实例对象就可以生成多个 html 文件\n\n拷贝文件：copy-webpack-plugin\n开发阶段一般不会用，会在上线前使用\n\n提取公共代码：commons-chunk-plugin\n\n压缩 es6 代码：uglifyjs-webpack-plugin\n\n定义环境变量：define-plugin\nplugins:[      new CleanWebpackPlugin(),      // 用于生成 index.html      new HtmlWebpackPlugin (&#123;        title:&#x27;Webpack Plugin Sample&#x27;,        meta:&#123;          viewport:&quot;width=device-width&quot;        &#125;,        template:&#x27;./src/index.html&#x27;      &#125;),      // 用于生成 about.html      new HtmlWebpackPlugin (&#123;        filename:&#x27;about.html&#x27;      &#125;),   new CopyWebpackPlugin([        // &#x27;public/**&#x27;        &#x27;public&#x27;      ])  ]\n\n\n\n三、打包结果运行原理\n定义给一个对象 webpack_module_cache = {}  缓存加载后的模块\n\n定义一个  webpack_require 函数，专门加载模块，给模块上定义了一些功能\n\n定义了一个____webpack_exports____ = {} \n\n 调用____webpack_require____（ webpack_require.s = 0)，\n\n\n0 =》 模块数组下标，开始加载源代码中定义的入口模块\n\n5. 调用____webpack_require____.r 方法，给模块加了一个 ‘__esModule&#39; 的标记\n\n6. 调用____webpack_require____（ ____webpack_require____.s = 0)，正式加载第一个模块\n\n7. 最后document.body.append(heading)\n\n四、webpack 加载资源的方式\n遵循 ES Module 标准的 import 声明\n\n遵循 CommonJS 标准的 require 函数\n\n遵循 AMD 标准的 define 函数 和 require 函数\n\n样式代码中的 @import 指令和 url 函数\n\nHTML 代码中图片标签的 src 属性\nHTML 代码中 a 标签的 href 属性不会默认处理，需要配置  options{attrs[‘img:src’,’a:href’]}\nimport footerHtml from &#x27;./footer.html&#x27; // 接收到的是字符串document.write(footerHtml)\n\n五、webpack 核心工作原理根据配置的入口文件，顺着入口文件的代码，根据import或者require的语句，解析其依赖的资源模块，分别解析每个资源模块对应的依赖，形成了所有文件的依赖树，webpack递归遍历依赖数树，找到每个节点对应的资源文件，根据配置的rules属性找到这个模块对应的加载器，加载器去加载这个模块，将加载到的结果放到打包结果中。\n六、Loader 工作原理​    loader 负责资源文件从输入到输出的转换，类似一个管道，对于同一个资源可以依次使用多个 loader\n七、开发一个 markdown-loader\n得到的结果是 markdown 转换过后的 html 字符串\n\nuse:’./markdown-loader’    // use 可以使用模块的路径\n\nwebpack最终的结果 必须是一段 JavaScript 代码，可以最后使用加载器转换 html-loader\n因为其将loader最后加载的结果直接拼接到 打包结果中，所以不是 js 代码的话会导致语法不通过\n\n安装 marked 模块 解析 markdown 为 html 字符串\n\n将 html 变为 js 代码 \n// markdown-loader.jsconst marked = require(&#x27;marked&#x27;)module.exports = source =&gt; &#123;\tconst html = marked(source)\t// return `module.exports = &quot;$&#123;html&#125;&quot;` // 会导致html字符串里的一些换行符，引号出错\t// return `module.exports = $&#123;JSON.stringfy(html)&#125;` // 第一种方法\t// return `export default = $&#123;JSON.stringfy(html)&#125;` // 第二种方法\treturn html // 第三种方法，直接返回 html 字符串，安装 html-loader 解析&#125;// webpack.config.js&#123;    test:/.md$/,  // 必须有，用来匹配文件路径    use:[    \t&#x27;html-loader&#x27;,    \t&#x27;./marked-loader&#x27;    ]&#125;\n\n八、plugins插件工作原理​    Plugin 通过钩子机制实现，webpack给每个节点都预先定义了钩子。\n​    1. plugin 是一个函数或者是一个包含 apply 方法的对象\n九、开发一个 plugins\n通过在生命周期的钩子中挂载函数实现扩展\n// 实现清除bundle.js文件的注释class MyPlugin &#123;  apply (compiler) &#123;    console.log(&#x27;MyPlugin启动&#x27;)    // emit钩子：输出 asset 到 output 目录之前执行。    compiler.hooks.emit.tap(&#x27;MyPlugin&#x27;,compilation =&gt; &#123;      // compilation 可以理解为此次打包的上下文      for(const name in compilation.assets)&#123;        // console.log(compilation.assets[name].source())        if(name.endsWith(&#x27;.js&#x27;))&#123;          const contents = compilation.assets[name].source()          const withoutComments = contents.replace(/\\/\\*\\*+\\*\\//g,&#x27;&#x27;)          compilation.assets[name] = &#123;            source:() =&gt; withoutComments,            size:() =&gt; withoutComments.length          &#125;        &#125;      &#125;    &#125;)  &#125;&#125;\n\n"},{"url":"/2021/06/22/webpack/webpack%E6%89%93%E5%8C%85/","content":"定位 webpack 打包入口\n cmd 文件核心的作用就是组装了 node ***/webpack/bin/webpack.js\n\n webpack.js 中核心的操作就是 require 了 node_modules/webpack-cli/bin/cli.js\n\n cli.js\n\n\n\n当前文件一般有二个操作，处理参数，将参数交给不同的逻辑（分发业务）\noptions\ncompiler\ncompiler.run(  )\n\nwebpack 打包流程\nwebpack 钩子\nbeforeRun\n\nrun\n\nthisCompilation\n\ncompilation\n\nbeforeCompile\n\ncompile\n\nmake\n\nafterCompile\n\n\n实现一个 webpack"},{"url":"/2021/06/22/webpack/webpack%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","content":"不同环境不同配置\n中小型项目\nyarn webpack –mode production\n// module.exports也可以导出一个函数，返回配置对象// env 环境参数，argv 运行cli过程中传递的所有参数module.exports = (env,argv) =&gt; &#123;\tconst config = &#123;        mode: &#x27;development&#x27;,        entry: &#x27;./src/main.js&#x27;,        output: &#123;          filename: &#x27;js/bundle.js&#x27;        &#125;,        devtool: &#x27;cheap-eval-module-source-map&#x27;,        devServer: &#123;          hot: true,          contentBase: &#x27;public&#x27;        &#125;,        module: &#123;          rules: [            &#123;              test: /\\.css$/,              use: [                &#x27;style-loader&#x27;,                &#x27;css-loader&#x27;              ]            &#125;,            &#123;              test: /\\.(png|jpe?g|gif)$/,              use: &#123;                loader: &#x27;file-loader&#x27;,                options: &#123;                  outputPath: &#x27;img&#x27;,                  name: &#x27;[name].[ext]&#x27;                &#125;              &#125;            &#125;          ]        &#125;,        plugins: [          new HtmlWebpackPlugin(&#123;            title: &#x27;Webpack Tutorial&#x27;,            template: &#x27;./src/index.html&#x27;          &#125;),          new webpack.HotModuleReplacementPlugin()        ]      &#125;\tif(env === &#x27;production&#x27;)&#123;\t\tconfig.mode = &#x27;production&#x27;\t\tconfig.devtool = false\t\tconfig.plugins = [\t\t\t...config.plugins,\t\t\tnew CleanWebpackPlugin(),\t\t\tnew CopyWebpackPlugin([&#x27;public&#x27;])\t\t]\t&#125;\treturn config&#125;\n大型项目 不同环境对应不同配置文件\n**yarn webpack –config webpack.prod.js **    指定所使用的配置文件\n\nwebpack.common.js\nconst HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123;  entry: &#x27;./src/main.js&#x27;,  output: &#123;    filename: &#x27;js/bundle.js&#x27;  &#125;,  module: &#123;    rules: [      &#123;        test: /\\.css$/,        use: [          &#x27;style-loader&#x27;,          &#x27;css-loader&#x27;        ]      &#125;,      &#123;        test: /\\.(png|jpe?g|gif)$/,        use: &#123;          loader: &#x27;file-loader&#x27;,          options: &#123;            outputPath: &#x27;img&#x27;,            name: &#x27;[name].[ext]&#x27;          &#125;        &#125;      &#125;  &#125;,  plugins: [    new HtmlWebpackPlugin(&#123;      title: &#x27;Webpack Tutorial&#x27;,      template: &#x27;./src/index.html&#x27;    &#125;)  ]&#125;\nwebpack.dev.js\nconst webpack = require(&#x27;webpack&#x27;)const &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const common = require(&#x27;./webpack.common&#x27;)module.exports = merge(common, &#123;  mode: &#x27;development&#x27;,  devtool: &#x27;cheap-eval-module-source-map&#x27;,  devServer: &#123;    hot: true,    contentBase: &#x27;public&#x27;  &#125;,  plugins: [    new webpack.HotModuleReplacementPlugin()  ]&#125;)\nwebpack.prod.js\nconst &#123; merge &#125; = require(&#x27;webpack-merge&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)const CopyWebpackPlugin = require(&#x27;copy-webpack-plugin&#x27;)const common = require(&#x27;./webpack.common&#x27;)module.exports = merge(common, &#123;  mode: &#x27;production&#x27;,  plugins: [    new CleanWebpackPlugin(),    new CopyWebpackPlugin([&#x27;public&#x27;])  ]&#125;)\n\n\n\n"},{"url":"/2021/06/22/webpack/webpack%E8%BF%9B%E9%98%B6/","content":"webpackwebpack 自动编译+自动刷新浏览器#### 1. watch + BrowserSync\n\n\n监听文件变化，自动重新打包\nyarn webpack --watch\nBrowserSync 自动刷新浏览器\nbrowser-sync dist --files &quot;**/*&quot;   // 启动服务，监听dist目录下的文件变化\n\n2. webpack-dev-server\n提供用于开发的HTTP Server\n\nj将自动编译和自动刷新浏览器等功能集成在一起\n\n将打包记录暂时存放在内存中，不会生成 dist 文件\nyarn webpack-dev-serveryarn webpack-dev-server --open   // 自动打开浏览器\n\n\n只要是被 webpack 打包输出的文件，都可以正常访问监听到，额外的静态资源主要告诉webpack-dev-server，配置如下（使用了copy-webpack-plugin就不需要，但是copy-webpack-plugin一般只在上线前使用）\n\ndevServer: &#123;\tcontentBase: &#x27;./public&#x27; ,      // 可以是字符串也可以是数组&#125;\n\n\n代理 API（跨域）\n\ndevServer: &#123;\tcontentBase: &#x27;./public&#x27; ,      // 可以是字符串也可以是数组\tproxy: &#123;\t\t&#x27;/api&#x27;:&#123;\t\t\ttarget:&#x27;https://api.github.com&#x27;,  // 代理目标服务器\t\t\tpathRewrite:&#123;\t\t\t\t&#x27;^/api&#x27;:&#x27;&#x27;,   // 将 /api 替换\t\t\t&#125;,\t\t\tchangeOrigin: true  \t\t\t// 默认将浏览器主机名作为请求 GitHub 的主机名，服务器会根据主机名判断这个请求属于哪个网站，changeOrigin: true 会已实际代理请求这次发生的主机名请求\t\t&#125;\t&#125;&#125;\n\nSource MaP 源代码地图\n映射转换过后的代码与源代码之间的关系\n\n解决前端编写的源代码与运行代码不一致所产生的问题\n// jquery-3.4.2.min.mapversion:&#x27;&#x27; --  // source map的版本sources:[] -- // 源文件的名称names:[]   -- // 原始变量的名称mappings:&#x27;&#x27;-- base64/vlq 字符串，转换过后的代码与源代码映射关系添加注释引入source map 文件//# sourceMapplingURL=jquery-3.4.2.min.map\n\n\n配置 source map\ndevtool:&#x27;source-map&#x27;/**eval:将模块代码放入eval执行，没有生成map,只能定位源代码具体文件的名称，没有具体的行列信息eval-source:可以定位到文件，行列信息,生成了mapcheap-eval-source-map:只能定位到行,定位到的是经过loader转换后的代码cheap-module-eval-source-map:只能定位到行，定位到的是源代码即loader转换前的代码inline-source-map:使用dataurl的方式将dataurl嵌入到代码当中（代码体积变大，不用）hidden-source-map:生成了map文件，但是没引入，通常用于第三方包开发的时候用nosources-source-map:没有源代码，但是有行列信息，生产模式下使用，保护源代码*//**eval:是否使用eval执行模块代码cheap:是否包含行信息module:是否能够得到Loader处理之前的源代码*/\n\n\n\n选择 source-map\n开发：cheap-module-eval-source-map生产：none -- 防止暴露源代码\n\nHMR 模块热替换（热更新）\n只将修改的模块实时替换至应用中\n\n开启HMR\n\n已经集成在 webpack-dev-server 中了\n\n需要手动处理模块热替换逻辑\n\n样式文件模块热替换可以了，js文件热替换不行，因为样式文件经过 style-loader 处理，style-loader 里已经处理了 HMR\n// 方式1.运行命令yarn webpack-dev-server --hot// 方式2.配置文件const webpack = reuqire(&#x27;webpack&#x27;)devserver:&#123;\thot:true&#125;,plugins:[\tnew webpack.HotModuleReplacementPlugin()]// 运行 yarn webpack-dev-server\nAPI 处理 \nJS 模块热替换 ：需要对应处理\n处理图片热替换：直接将图片 src 替换为新的\nmodule.hot.accept(&#x27;./editor&#x27;,() =&gt; &#123;\tconsole.log(&#x27;editor 模块更新了，需要这里手动处理热替换逻辑&#x27;)&#125;)// hot --- HMR 的核心对象// accept --- 注册某个模块更新后的处理函数（路径，依赖路径更新后的处理函数）// 这样 editor 模块更新了，不会导致自动刷新\n\n\n注意事项\n\n\n处理 HMR 的代码报错会导致自动刷新：将 hot 修改为 hotOnly 模式\ndevserver:&#123;\thotOnly:true&#125;\n没启用 HMR 的情况下，HMR API 报错：先判断 module.hot 再处理\nif(module.hot)&#123;\tmodule.hot.accept(&#x27;./editor&#x27;,() =&gt; &#123;        console.log(&#x27;editor 模块更新了，需要这里手动处理热替换逻辑&#x27;)    &#125;)&#125;\n代码中多了一些与业务无关的代码：关闭 HMR ，打包后文件里 处理热替换的代码都移除了，剩下了   if（false）{}  这样没有意义的代码，代码压缩时也会去掉\n\n\n\n\n"},{"url":"/2021/06/22/webpack/%E5%B7%A5%E7%A8%8B%E5%8C%96/","content":""},{"url":"/2021/06/22/webpack/%E6%A8%A1%E5%9D%97%E5%8C%96/","content":"模块化\n模块化演变过程\nstage1 : 文件划分方式 — 模块划分成不同的文件\n\n污染全局作用域\n命名冲突问题\n无法管理模块依赖关系\n完全依靠约定\n\nstage2 ：命名空间方式，将每个模块包裹成全局对象，减少命名冲突问题\nstage3：IIFE    实现了私有成员，立即调用函数参数可以进行依赖声明    \n\n模块化规范\n模块化标准+模块加载器\ncommonJS规范* 以同步模式加载模块\n\n\n一个文件就是一个模块\n\n每个模块都有单独的作用域\n\n通过module.exports导出成员\n\n通过require函数载入模块\n\n\nAMD（Asynchronous Module Definition)\nRequire.js 模块加载器\n\ndefine函数定义\ndefine(&#x27;module1&#x27;,[&#x27;jquery&#x27;,&#x27;./module2&#x27;],function($, module2)&#123;\treturn &#123;\t\tstart: function()&#123;\t\t\t$(&#x27;body&#x27;).animate(&#123; margin: &#x27;200px&#x27; &#125;)\t\t\tmodule2()\t\t&#125;\t&#125;&#125;)// &#x27;module1&#x27; -- 模块的名字，加载模块的时候使用// [&#x27;jquery&#x27;,&#x27;./module2&#x27;] -- 声明模块的依赖项// function($, module2) -- 与模块的依赖项一一对应，每一个都是依赖项的导出成员// return 向外部导出成员\nrequire载入一个模块\nrequire([&#x27;./module1&#x27;],function(module1)&#123;\tmodule1.start()&#125;)// 内部会定义一个script标签去请求这个模块，加载相应的代码\n目前绝大多数第三方库都支持AMD规范\n\n使用起来相对复杂\n\n模块JS文件请求频繁\n\n\nSea.js + CMD\nCMD规范类似于CommonJS规范\n\nrequire引入依赖\n\nexports或者module.exports对外暴露成员\ndefine(function(require,exports,module)&#123;\tvar $ = require(&#x27;jquery&#x27;)\tmodule.exports = function()&#123;\t\t$(&#x27;body&#x27;).append(&#x27;&lt;p&gt;module2&lt;/p&gt;&#x27;)\t&#125;&#125;)\n\n​    浏览器环境中统一用 ES module 规范，nodejs 环境中用 CommonJS 规范\nES Module\n基本特性\n\n通过给 script 添加 type = module 的属性，就可以以 ES Module 的标准执行其中的 JS 代码了\n&lt;script type=&quot;module&quot;&gt;\tconsole.log(&#x27;es module&#x27;)&lt;/script&gt;\n\n\nESM 自动采用严格模式，忽略 ‘ use strict’\n\n每个 ES Module 都是运行在单独的私有作用域中\n\nESM 是通过 CORS 的方式请求外部地址的（需要支持跨域）\n\nCORS 不支持文件的形式去访问，必须使用 http-server的形式\n\n\nESM 的script 标签会延迟执行脚本\n\n网页渲染会后再去执行脚本，不会阻塞网页渲染，相当于 defer\n\n\n\n\n导入和导出\n\nexport 导出\n\n导出的成员是一个只读成员\n\n导出的不是值，是值得的引用\n\n\n\nimport 导入\n\n必须是完整的路径，不能省略 .js，不能省略 Index.js 默认文件\n相对路径必须以 ./ 开头  — ./module.js\n可以使用绝对路径  — /04-import/module.js\n可以使用url路径 ’http://….‘\n\n只需要执行某个模块，不需要引入其中的成员\nimport &#123;&#125; from &#x27;./module.js&#x27;//或import &#x27;./module.js&#x27;\n*导入所有的成员，as重命名\nimport * as mod from &#x27;./module.js&#x27;console.log(mod)\n动态导入模块\nimport(&#x27;./module.js&#x27;).then((module) =&gt; &#123;\t// moduel --&gt; 模块对象&#125;)\n同时导入命名成员及匿名成员\nimport &#123; foo, fooAge，default as name &#125; from &#x27;./module.js&#x27;// 或import name &#123; foo, fooAge &#125; from &#x27;./module.js&#x27;\n\n\n将导入的成员直接作为当前模块的导出成员\n在 index 文件中将该目录下所有的 模块汇总导出\nexport &#123; foo,bar &#125; from &#x27;./module.js&#x27;\n小栗子\n// ./module.jsconst foo = &#x27;es modules&#x27;const name = &#x27;es&#x27;const age = 18export &#123; \tfoo,\tage as fooAge,  // 重命名\tname as default, // 默认导出  &#125; // 固定语法，并不是对象字面量// ./app.jsimport &#123; foo, fooAge，default as name &#125; from &#x27;./module.js&#x27;console.log(foo, fooAge, name)// 默认导出export default const a = &#x27;bdc&#x27;import a from &#x27;./module.js&#x27;\n\n\n兼容性问题\n\nPolyfill 浏览器\n// browser-es-module-loader 的polyfill将不支持的es module转换// browser-es-module-loader会使得支持模块语法的会导致执行两次，需要使用 script标签的 nomodule来解决，script标签中的内容只有在不支持es module的浏览器中执行&lt;script nomodule src=&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/babel-browser-build.js&quot;&gt;&lt;/script&gt;&lt;script nomodule src=&quot;https://unpkg.com/browser-es-module-loader@0.4.1/dist/browser-es-module-loader.js&quot;&gt;&lt;/script&gt;// ie 还需要再引入一个 promise的 polyfill &lt;script nomodule src=&quot;https://unpkg.com/promise-polyfill@8.1.3/dist/polyfill.min.js&quot;&gt;&lt;/script&gt;\nnodejs中兼容性\nnode –experimental-modules module.js\n可以在 es module 模块中载入 commonjs 的成员， commonjs 始终只会导出一个默认成员，es module 只能采用 默认方式载入\n不允许在 commonjs 模块载入 es module 的成员\n\nbabel兼容\nyarn add @babel/node @babel/core @babel/preset-env –dev   \n// @babel/preset-env插件的集合\nyarn babel-node index.js –presets=@babel/preset-env\n// .babelrc&#123;\t&quot;presets&quot;:[&quot;@babel/preset-env&quot;]&#125;// 执行命令：  yarn babel-node index.js\n\n\n\n\n\nCommonJS 与 ES Module 的区别\ncommonjs 中的模块全局成员：require、module、exports、__filename、 __dirname\n\nes module 中没有，代替 import、export\n// import.meta.url 当前工作的文件路径// 替代 __filename import &#123; fileURLToPath &#125; from &#x27;url&#x27;const __ filename = fileURLToPath(import.meta.url)// 替代 __dirnameimport &#123; dirname &#125; from &#x27;path&#x27;const __dirname = dirname(__filename)\n可以在 es module 模块中载入 commonjs 的成员， commonjs 始终只会导出一个默认成员\n\n不允许在 commonjs 模块载入 es module 的成员\n\n\n"},{"url":"/2021/06/22/webpack/%E8%84%9A%E6%89%8B%E6%9E%B6/","content":"脚手架的本质作用\n创建项目基础架构、提供项目规范和约定\n相同的组织结构\n相同的开发范式\n相同的模块依赖\n相同的工具配置\n相同的基础代码\n\n\n\n前端脚手架脚手架作用常用的脚手架工具\ncreate-react-app\nvue-cli\nangular-cli\nYeoman –根据一套模板生成对应的脚手架结构\nplop — 在项目开发过程中创建特定类型的文件通用脚手架剖析Yeoman –  https://yeoman.io\n安装：\n在全局范围安装yo—-   yarn global add yo  \n安装对应的generator—-  yarn global add generator-node\n\n\n创建目录 mkdir my-module\nmy-module下运行 ：\nyo node报错：’yo’ 不是内部或外部命令，也不是可运行的程序 或批处理文件。解决：npm安装yo npm install -g yo常见问题\n\n\n\n\n\n\nyo generatorName 运行生成器时报错–’This generator (vueG:app) requires yeoman-environment at least 3.0.0-beta.1, current version is 2.10.3’\n\n\n报错原因:yeoman-generator 版本更新造成 最新更新至5.0.0\n解决方案:\n方案1：降低yeoman-environment版本之4.0–  npm install –save-dev &#121;&#101;&#x6f;&#109;&#x61;&#110;&#x2d;&#103;&#x65;&#110;&#x65;&#114;&#x61;&#116;&#111;&#x72;&#64;&#x34;&#46;&#48;\n方案2：全局安装yeoman-environment，运行生成器命令：yoe run generatorNamenpm install -g yeoman-environmentyoe run generatorName\n\n\n\n\n安装yeoman-generator 5.0  yoe run generatorName 文件读写报错– Error: Error parsing namespace vueG    at Environment.requireNamespace (C:\\Program Files\\nodejs\\node_modules\\yeoman-environment\\lib\\namespace.js:68:13)\n\n\n报错原因：yeoman-generator 版本更新造成 最新更新至5.0.0并全局安装yeoman-environment\n解决方案：\n方案1:降低当前 yeoman-generator  至 4.0.0\n方案2: 检查generator-name, name中不要包含大写字母,不要使用特殊符号\n\n\n\n\nyarn link  command cant find 问题解决\n\n\n报错原因：yarn的安装 为 npm 安装 yarn 的环境变量或者安装路径或者权限问题\n解决方案：\n方案1:  不用yarn 来运行生成器  而用 npm 来运行  (windows &amp; mac 均适用)npm link\n方案2: window 为 yarn 配置环境变量 具体如果在windows上配置环境变量 可自行百度sub generator（子级generator）\n\n\n运行sub generator：yo node:cli常规使用步骤\n\n\n明确你的需求\n找到合适的generator\n全局范围安装找到的generator\n通过yo运行对应的generator\n通过命令行交互填写选项\n生成你所需要的项目结构自定义generator –基于yeoman搭建自己的脚手架\n\n\n本质上是一个npm模块\n名称 ： generator-name\nmkdir generator-sample\ncd generator-sample\nyarn init\nyarn add yeoman-generator\n添加目录结构 generators/app/index.js\n根据模板创建文件\napp/templates/….  里面存放各个模板文件\n\n\n注册模块：npm link\n使用：yo sample\n报错解决：全局安装npm install -g yeoman-environment，运行生成器yoe run generatorName\n\n\n\n\n根据模板创建文件/** 此文件作为Generator的核心入口* 需要导出一个继承自Yeoman Generator 的类型* Yeoman Generator 在工作时会自动调用我们在此类型中定义的一些生命周期方法* 我们在这些方法中可以通过父类提供的一些工具方法来实现一些功能，例如文件导入* */const Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator &#123;  // 根据模板创建文件  writing()&#123;    // Yeoman 自动在生成文件阶段调用此方法    // 我们这里尝试往项目目录中写入文件    // this.fs（父类当中的）两个参数：写入文件路径、写入文件内容    /*this.fs.write(      this.destinationPath(&#x27;temp.txt&#x27;),      Math.random().toString()    )*/        // 通过模板方式写入文件到目标目录    // 模板文件路径    const tmpl = this.templatePath(&#x27;foo.txt&#x27;)    // 输出文件路径    const output = this.destinationPath(&#x27;foo.txt&#x27;)    // 模板数据上下文    const context = &#123; title:&#x27;Hello qiao&#x27;, success:false&#125;        this.fs.copyTpl(tmpl,output,context)  &#125;&#125;\n接收用户收入const Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator &#123;  // 接收用户收入  promiting()&#123;    // Yeoman 在询问用户环节自动调用此方法    // 在此方法中可以调用父类的 prompt()方法发出对用户的命令行询问    return this.prompt([      &#123;        type:&#x27;input&#x27;,        name:&#x27;name&#x27;,        message:&#x27;Your project name&#x27;,        default:this.appname  // 当前生成项目目录的文件夹名字      &#125;    ]).then(answers =&gt; &#123;      // 用户输入的结果 &#123; name:&#x27;user input value&#x27;&#125;      this.answers = answers    &#125;)  &#125;  // 根据模板创建文件  writing()&#123;        // 通过模板方式写入文件到目标目录    // 模板文件路径    const tmpl = this.templatePath(&#x27;bar.html&#x27;)    // 输出文件路径    const output = this.destinationPath(&#x27;bar.html&#x27;)    // 模板数据上下文    const context = this.answers        this.fs.copyTpl(tmpl,output,context)  &#125;&#125;\nvue 脚手架案例\n使用数组遍历的方式生成模板文件const Generator = require(&#x27;yeoman-generator&#x27;)module.exports = class extends Generator &#123;  prompting()&#123;    return this.prompt([      &#123;        type:&#x27;input&#x27;,        name:&#x27;name&#x27;,        message:&#x27;Your project name&#x27;,        default:this.appname      &#125;    ]).then(answers =&gt; &#123;      this.answers = answers    &#125;)  &#125;    writing()&#123;    // 数组循环批量生成文件    const templates = [      &#x27;.browserslistrc&#x27;,      &#x27;.editorconfig&#x27;,      &#x27;.env.development&#x27;,      &#x27;.env.production&#x27;,      &#x27;.eslintrc.js&#x27;,      &#x27;.gitignore&#x27;,      &#x27;babel.config.js&#x27;,      &#x27;package.json&#x27;,      &#x27;postcss.config.js&#x27;,      &#x27;README.md&#x27;,      &#x27;public/favicon.ico&#x27;,      &#x27;public/index.html&#x27;,      &#x27;src/App.vue&#x27;,      &#x27;src/main.js&#x27;,      &#x27;src/router.js&#x27;,      &#x27;src/assets/logo.png&#x27;,      &#x27;src/components/HelloWorld.vue&#x27;,      &#x27;src/store/actions.js&#x27;,      &#x27;src/store/getters.js&#x27;,      &#x27;src/store/index.js&#x27;,      &#x27;src/store/mutations.js&#x27;,      &#x27;src/store/state.js&#x27;,      &#x27;src/utils/request.js&#x27;,      &#x27;src/views/About.vue&#x27;,      &#x27;src/views/Home.vue&#x27;    ]    templates.forEach(item =&gt; &#123;      this.fs.copyTpl(        this.templatePath(item),        this.destinationPath(item),        this.answers      )    &#125;)  &#125;&#125;\nnpm link\n\n\n发布generator模块\n项目源代码托管git\necho node_modules &gt; .gitignore  // 忽略node_modules\n\n\n发布\nnpm publish 发布到npm上\nyarn publish –registry=https://registry.yarnpkg.com（镜像）\n\n\n\n\n\nPlop—一个小而美的脚手架工具\nreact项目中使用Plop\n将plop模块作为项目开发依赖安装  yarn add plop –dev\n在项目根目录下创建一个plopfile.js文件\n在plopfile.js文件中定义脚手架任务// Plop 入口文件，需要导出一个函数// 此函数接收一个plop对象，用于创建生成器任务module.exports = plop =&gt; &#123;  plop.setGenerator(&#x27;component&#x27;,&#123;    description:&#x27;create a component&#x27;,    prompts:[      &#123;        type:&#x27;input&#x27;,        name:&#x27;name&#x27;,        message:&#x27;component name&#x27;,        default:&#x27;MyComponent&#x27;      &#125;    ],    actions:[      &#123;        type:&#x27;add&#x27;,        path:&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;,        templateFile:&#x27;plop-templates/component.hbs&#x27;      &#125;    ],    actions:[      &#123;        type:&#x27;add&#x27;,        path:&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.js&#x27;,        templateFile:&#x27;plop-templates/component.hbs&#x27;      &#125;,      &#123;        type:&#x27;add&#x27;,        path:&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.css&#x27;,        templateFile:&#x27;plop-templates/component.css.hbs&#x27;      &#125;,      &#123;        type:&#x27;add&#x27;,        path:&#x27;src/components/&#123;&#123;name&#125;&#125;/&#123;&#123;name&#125;&#125;.test.js&#x27;,        templateFile:&#x27;plop-templates/component.test.hbs&#x27;      &#125;    ]  &#125;)&#125;\n编写用于生成特定类型文件的模板  plop-template/component.hbs\n通过plop提供的CLI运行脚手架任务  yarn plop component\n\n\n\n脚手架工作原理通过nodejs一个小的脚手架\n创建一个目录 mkdir sample-scaffolding\ncd sample-scaffolding\nyarn init\n在package.json中添加一个bin字段，，用于去指定CLI应用的入口文件 — “bin”: “cli.js”\n创建 cli.js 文件#!/usr/bin/env node// Node CLI应用入口文件必须要有这样的文件头// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755// 具体就是通过 chmod 755 cli.js 实现修改console.log(&#x27;cli working&#x27;)\nnpm link 注册到全局\n运行 sample-scaffolding\n询问用户问题\nyarn add inquirer\n\n\n\n #!/usr/bin/env node// Node CLI应用入口文件必须要有这样的文件头// 如果是 Linux 或者 macOS 系统下还需要修改此文件的读写权限为 755// 具体就是通过 chmod 755 cli.js 实现修改/* 脚手架的工作过程：* 1. 通过命令行交互询问用户问题* 2. 根据用户回答的结果生成文件* */const fs = require(&#x27;fs&#x27;)const path = require(&#x27;path&#x27;)const inquirer = require(&#x27;inquirer&#x27;)const ejs = require(&#x27;ejs&#x27;)inquirer.prompt([  &#123;    type:&#x27;input&#x27;,    name:&#x27;name&#x27;,    message:&#x27;Project name?&#x27;  &#125;]).then(answers =&gt; &#123;  // console.log(answers)  // 根据用户回答的结果生成文件    // 模板目录  const tmplDir = path.join(__dirname,&#x27;templates&#x27;)  // 目标目录  const destDir = process.cwd()  // 命令行执行的目录（在哪个目录执行）  // 将模板下的文件全部转换到目标目录  fs.readdir(tmplDir,(err,files) =&gt; &#123;    if(err) throw err    files.forEach(file =&gt; &#123;      // file =&gt; 相对tmplDir的相对路径      // 通过模板引擎渲染文件      ejs.renderFile(path.join(tmplDir,file),answers,(err,result) =&gt; &#123;        if(err) throw err        // 将结果写入目标文件        fs.writeFileSync(path.join(destDir,file),result)      &#125;)    &#125;)  &#125;)&#125;)\n\n\n使用\nmkdir demo\ncd demo\nsample-scaffolding\n\n\n\n"},{"url":"/2021/06/22/webpack/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%9E%84%E5%BB%BA/","content":"自动化构建工作流：源代码 自动化构建 成生产代码\nlet aaa = &#123;  &quot;name&quot;: &quot;my-web-app&quot;,  &quot;version&quot;: &quot;0.1.0&quot;,  &quot;main&quot;: &quot;index.js&quot;,  &quot;author&quot;: &quot;zce &lt;w@zce.me&gt; (https://zce.me)&quot;,  &quot;license&quot;: &quot;MIT&quot;,  &quot;scripts&quot;: &#123;    // &quot;build&quot;: &quot;sass scss/main.scss css/style.css&quot;,   // 运行sass    &quot;build&quot;: &quot;sass scss/main.scss css/style.css --watch&quot;, // 监听sass变化，会导致serve命令不能正常运行，需要    &quot;preserve&quot;: &quot;yarn build&quot;, // 钩子，在执行yarn browser-sync命令前自动执行，需要借助 npm-run-all 这个模块实现同时执行这两个命令    // &quot;serve&quot;: &quot;browser-sync .&quot;,// 启动browser-sync启动一个web服务，刷新浏览器    &quot;serve&quot;: &quot;browser-sync . --files \\&quot;css/*.css\\&quot;&quot;, // 会将文件内容自动同步到浏览器，从而更新浏览器界面    &quot;start&quot;: &quot;run-p build serve&quot; // 同时执行两个命令  &#125;,  &quot;devDependencies&quot;: &#123;    &quot;npm-run-all&quot;: &quot;^4.1.5&quot;,    &quot;sass&quot;: &quot;^1.32.8&quot;,    &quot;browser-sync&quot;: &quot;^2.26.14&quot;  &#125;&#125;\n\n常用的自耦的那个花构建工具\nGrunt  –磁盘读写，构建速度相对较慢\nGulp   –基于内存实现，可以同时执行多个任务\nFIS    –大而全，模块化编译，性能优化\n\n"},{"title":"hexo博客搭建","url":"/2021/06/22/%E5%8D%9A%E5%AE%A2/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"前言采用 hexo + keep + github 搭建自己的博客\nhexo 需要本地编译后，再把编译文件推送到 Github\n开始搭建\n安装 node， 地址 Nodejs\n\n安装 hexo\n   npm install hexo-cli -g3. 初始化博客目录   ```bash   hexo init candy-qlr.github.io (candy-qlr替换成自己的)\n进入目录\ncd candy-qlr.github.io\n安装\nnpm install\nclean一下，然后生成静态页面\nhexo cleanhexo g (g就是generate,生成的意思)\n运行博客网站\nhexo s  (s就是server,在服务器运行的意思)\n打开浏览器，输入 localhost:4000。自此，个人网站搭建成功\n\n\n发布到GitHub\ngithub 创建一个账号 candy-qlr\n\ngithub 上创建一个 candy-qlr.github.io 的 public仓库\nxxx写你的名字，到时就可以通过 xxx.github.io 来访问你的博客了   xxx 必须与你的 github  账号一致3. 安装 ```hexo-deployer-git```   ```bash   npm install hexo-deployer-git --save\n配置_config.yml\ndeploy:  type: git  repo: https://github.com/candy-qlr/candy-qlr.github.io.git // 输入你的git地址\n推送网站到 Github 上\nhexo d\t(d就是 deploy，部署上去的意思)\n访问博客\n浏览器输入 xxx.github.io，就可以访问了\n\n\n域名绑定\n添加 CNAME 文件\n# 进入sourcescd sources# 创建CNAME文件，写入自己的域名，如：www.iwkxk.comtouch CNAME复制代码\n在你的域名商后台进行 DNS 解析添加两条记录：\n1. 主机记录： @    记录类型：A    记录值：192.30.252.154 或者 192.30.252.1532. 主机记录： www    记录类型： CNAME    记录值： xxx.github.io  (这里就是你的github仓库名称)复制代码\nGitHub 设置域名\n在你的 GitHub 设置域名，在你的 GitHub 博客项目中点击 Settings，在 GitHub Pages 下的 Custom domain 写上你的域名，然后 save。\n\n\n网站优化\n_config.yml 文件配置网站信息\ntitle: q&#x27;s Blogsubtitle: q的个人博客description: q的个人笔记keywords: JavaScript,Vue,Webpack,node,reactauthor: qlrlanguage: zhtimezone: \n主题修改\n\n选择一个主题 https://hexo.io/themes/\n\n将主题源码 fork 到自己仓库，下载安装主题\nnpm install hexo-theme-keep\n根目录 _config.yml 文件中，修改 theme 为你的主题名字：\ntheme: keep\n根据 keep 官网配置keep\n添加标签\n添加分类\n添加评论\n\n配置 scripts 指令\n&quot;scripts&quot;: &#123;  &quot;dev&quot;: &quot;hexo clean &amp;&amp; hexo g &amp;&amp; hexo s&quot;&#125;,\n运行\nnpm run dev\n\n\n\n博客文章\n创建\nhexo new hello （这里的article写上你的文章的名称）\n打上标签与分类，文章开头\n---title: Nuxt.jsdate: 2021-05-31 10:38:06tags: [vue, 服务端渲染]categories: [vue]---\n\n自动化部署 Travis CIhexo 官方推荐 Travis \n\n登录 travis,使用 github 账号登录\n\nGithub 配置 Travis CI 权限\n点击 按钮Activate all repositories using GitHub Apps\n\n进入授权页面 点击 APProve Install\n\n创建 Personal Access Token\n登录 github.com ，点击 settings  -  Developer settings - Personal access tokens , 点击 Generate new token，输入 token 名称（GH_TOKEN），勾选 repo 选项，左下角Generate token Token生成成功 复制新生成的Token（一定要复制，只会看到这一次）\n\n\n Travis CI 配置 Environment Variables 对应的项目仓库配置环境变量\n\n\n\n回到 Travis CI主页 右侧选择选项目仓库 点击右上角 More options  下拉选择Settings\n\n滚动 至 Environment Variables\n\n新建环境变量  Name为GH_Token VALUE为我们在 GitHub 生成的 Token\nps：保证 DISPLAY VALUE IN BUILD LOG 不被勾选 避免你的 Token 泄漏。\n\n\n   \n\n项目配置 CI\n\n创建 .travis.yml 文件\n\n// .travis.ymlsudo: falselanguage: node_jsnode_js:  - 12 # use nodejs v12 LTScache: npmbranches:  only:    - master # build master branch onlyscript:  - hexo generate # generate static filesdeploy:  provider: pages  skip-cleanup: true  github-token: $token // 创建的token名称  keep-history: true  on:    branch: master  local-dir: public\n\n\n提交本地代码至远端\n\ngit add .git commit -m &#x27;add travis config&#x27;git push origin master\n\nTravis CI 应该会自动开始运行，并将生成的文件推送到同一 repository 下的 gh-pages 分支下\n回到Travis CI 官网 如下图所示 完成部署\n\n\n修改 GitHubPages 部署分支\n\n回到Github对应项目主页 点击 Settings\n右侧侧边栏 选择 Pages Source 下 选择分支为 gh-pages (默认部署 为master分支) 点击Save\n\n\n浏览器 访问 xxxx.github.io\n\n\n自动化部署 GitHub Actions\n准备服务器\n\n创建 GitHub仓库\n\n创建一个私有仓库用来存储 Hexo 项目源代码\n公共仓库用来存储编译之后的静态页面\n当私有仓库的 master 有内容 push 进来时（例如：主题文件，文章 md 文件、图片等）， 会触发 GitHub Actions 自动编译并部署到公共仓库的 master分支。\n\n\n创建 GitHub Token\n创建一个有 repo 和 workflow 权限的 GitHub Token 。\n\n\n\n\n创建 repository secret\n将上面生成的 Token 添加到私有仓库的 Secrets 里，并将这个新增的 secret 命名为 HEXO_DEPLOY （名字无所谓，看你喜欢）。\n\n步骤：私有仓库 -&gt; settings -&gt; Secrets -&gt; New repository secret。\n\n\n新创建的 secret HEXO_DEPLOY 在 Actions 配置文件要用到，需跟配置文件保持一致！\n\n\n\n添加 Actions 配置文件\n在你的 Hexo 项目根目录下创建 .github 文件夹。\n\n在 .github 文件夹下创建 workflows 文件夹。\n\n在 workflows 文件夹下创建 hexo-deploy.yml 文件。\nname: deploying Hexo project to GitHub pageson:  push:    branches:      - master # master 分支有 push 行为时就触发这个 actionjobs:  build-and-deploy:    runs-on: ubuntu-latest    steps:      - name: Checkout        uses: actions/checkout@master      - name: Build and Deploy        uses: theme-keep/hexo-deploy-github-pages-action@master # 使用专门部署 Hexo 到 GitHub pages 的 action        env:          PERSONAL_TOKEN: $&#123;&#123; secrets.HEXO_DEPLOY &#125;&#125; # secret 名          PUBLISH_REPOSITORY: wkxk/wkxk.github.io # 公共仓库，格式：GitHub 用户名/仓库名          BRANCH: master # 分支，我这里是推送到wkxk/wkxk.github.io仓库里的master分支(根据自己的仓库进行填写)          PUBLISH_DIR: ./public # 部署 public 目录下的文件\n\n\n自动部署触发流程\n修改你的 Hexo 博客源代码。\n\n把你修改过的 Hexo 项目内容 push 到 GitHub 私有仓库的 master 分支。\n\nGitHub Actions 检测到 master 分支有内容 push 进来，会自动执行 action 配置文件的命令，将 Hexo 项目编译成静态页面，然后部署到公共仓库的 master 分支。\n\n在私有仓库的 Actions 可以查看到你配置的 action。\n\n\n\n\n","categories":["博客"],"tags":["博客"]},{"title":"vuepress博客搭建","url":"/2021/06/22/%E5%8D%9A%E5%AE%A2/vuepress%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","content":"前言采用 VuePress 搭建博客\nVuePress 由两部分组成：第一部分是一个极简静态网站生成器 (opens new window)，它包含由 Vue 驱动的主题系统和插件 API，另一个部分是为书写技术文档而优化的默认主题，它的诞生初衷是为了支持 Vue 及其子项目的文档需求。\n官网：https://vuepress.vuejs.org/zh/guide/\ngithub地址：https://github.com/vuejs/vuepress\n本文参考自：https://github.com/BlogGuide/vuepress.blog.github.io\n","categories":["博客"],"tags":["博客"]},{"url":"/2021/06/22/js/img/this/","content":"1.\nfunction foo() &#123;  console.log(this)&#125;foo()  // windowwindow.foo()  // windowfoo.call(1) // Number\n2.\nconst obj1 = &#123;    foo:function()&#123;        console.log(this)    &#125;&#125;obj1.foo()  // obj1const fn = obj1.foofn() // window\n3.\nconst obj2 = &#123;    foo:function()&#123;        function bar()&#123;            console.log(this)        &#125;        bar()    &#125;&#125;obj2.foo() // window\n4.\nlet length = 10function fn1()&#123;    console.log(this.length)&#125;const obj3 = &#123;    length:5,    method(fn1)&#123;        fn1()        arguments[0]()    &#125;&#125;obj3.method(fn,1,2)  // 10  3\n总结1.沿着作用域向上找最近的一个function（不是箭头函数），看这个function最终是怎样执行的2.this的指向取决于所属function的调用方式，而不是定义3.function调用一般分为以下几种情况：  1.作为函数调用，即：foo()    * 指向全局对象（globalThis),注意严格模式下是undefined  2.作为方法调用，即：foo.bar() / foo.bar.baz() / foo‘bar / foo0    * 指向最终调用这个方法的对象  3.作为构造函数调用，即：new Foo()    * 指向一个新的对象 Foo{}  4.特殊调用，即：foo.call() / foo.apply() / foo.bind()    * 参数指定成员4.找不到所属的function，就是全局对象5.箭头函数中的this指向\n\n继承自离他最近的作用域的this\n\ncall、apply、bind联系：都能改变this指向\n\n区别：\ncall / apply 会立即调用当前函数，并修改函数的this指向，而 bind 不会调用函数，也没有改变原函数的this指向，但是返回一个新函数，新函数的this指向改变了。\ncall / bind 方法传参一样，第一个是要改变函数this指向的对象，第二个以后的参数，将作为函数的实参传入。而 apply，第一个是要改变函数this指向的对象，第二个是一个数组或者类数组，数组里面的每一个值，将作为函数的实参传入// callFunction.prototype.myCall = function (ctx,...args) &#123;  ctx = ctx || window  ctx.fn = this  const result = ctx.fn(...args)  delete ctx.fn  return result&#125;// applyFunction.prototype.myApply = function (ctx,args=[]) &#123;  ctx = ctx || window  ctx.fn = this  const result = ctx.fn(...args)  delete ctx.fn  return result&#125;// bindFunction.prototype.myBind = function (ctx,...args) &#123;  ctx = ctx || window  return function(...args2)&#123;    ctx.fn = this    const result = ctx.fn(...args)    delete ctx.fn    return result  &#125;&#125;\n\n\n\n"},{"title":"动态规划算法","url":"/2020/04/07/suanfa/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/","content":"动态规划算法​     一般满足以下条件之一，大概率就是 动态规划 题目\n\n求最大值，最小值\n判断方案是否可行\n统计方案个数\n\n动态规划问题性质* 重叠子问题\n* \n\n动态规划固定流程* 递归的暴力解法\n* 带备忘录的递归解法\n* 非递归的动态规划解法\n\n案例1：斐波那契数列数列：0、1、1、2、3、5、8、13、21、34、…、n-2、n-1、n-2+n-1\n\n暴力的递归算法\n递归算法的时间复杂度\n子问题个数乘以解决一个子问题需要的时间\nfunction fib(n) &#123;  if(n &lt;= 0) return 0  if(n &lt;= 2) return 1  return fib(n - 1) + fib(n - 2)&#125;\n\n\n递归树\n\n\n\n递归算法的时间复杂度 —– 子问题个数乘以解决一个子问题需要的时间\n子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)\n解决一个子问题的时间，在本算法中，没有循环，只有 f(n-1) + f(n-2) 一个加法操作，时间为O(1)\n所以这个算法的时间复杂度为 **O(2^n)，指数级别\n\n\n\n\n带备忘录的递归解法\n\n造一个备忘录，每次算出某个子问题的答案后先记到 备忘录 里再返回，每个遇到一个子问题先去 备忘录 里查一查\nfunction fib2(n) &#123;  if(n &lt; 1) return 0  let arr = new Array(n + 1)  return helper(arr,n)&#125;function helper(arr,n) &#123;  if(n &lt;= 2) return 1  if(arr[n]) return arr[n]  arr[n] = helper(arr, n - 1) + helper(arr, n - 2)  return arr[n]&#125;\n\n\n递归树\n\n\n时间复杂度\n\n子问题个数，由于本算法中不存在冗余计算，子问题就是f(1),f(2),f(3)…f(n),数量和输入规模成正比，所以子问题个数为O(n)\n解决一个子问题的时间，没有循环，时间为**O(1)\n所以本算法的时间复杂度是**O(n)\n\n\n带备忘录的递归解法的效率已经和动态规划一样了。实际上，这种解法和动态规划的思想已经差不多了，只不过这种方法叫做【自顶向下】，动态规划叫做【自底向上】\n\n【自顶向下】是从上向下延伸，都是从一个规模较大的原问题比如说 f(20),向下逐渐分解规模，直到 f(1) 和 f(2) 触底，然后逐层返回答案\n【自底向上】直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20),这就是动态规划的思路，所以动态规划一般脱离了递归，由循环迭代完成计算\n\n\n\n\n动态规划\n\nfunction fib3(n) &#123;  let arr = new Array(n + 1)  arr[0] = 0  arr[1] = arr[2] = 1  for(let i = 3; i &lt;= n; i++)&#123;    arr[i] = arr[i-1] + arr[i-2]  &#125;  return arr[n]&#125;\n\n\n树\n\n\n动态转移方程–暴力解\n把 f(n) 想做一个状态 n,这个状态 n 是由状态 n-1 和状态 n-2 相加转移而来，这就叫状态转移\n\n\n\n动态规划优化\n\n当前状态只和之前的两个状态有关，所以不需要那么长的arr 来存储所有状态，只要想办法存储之前的两个状态就行了，所以可以进一步优化，把空间复杂度降为  O(1)\nfunction fib4(n) &#123;  if(n &lt; 2) return n  let pre = 0  let cur = 1  for(let i = 0; i &lt; n - 1; i++)&#123;    let sum = pre + cur    pre = cur    cur = sum  &#125;  return cur&#125;\n\n案例2：凑零钱问题题目：给你 k 种面值的硬币，面值分为 c1,c2,…ck，再给一个总金额 n，问你最少需要几枚硬币凑出这个金额，如果不可能凑出，则回答 -1\n比如，，k = 3，面值分别为 1，2，5，总金额 n = 11，那么最少需要 3 枚硬币，即 11 = 5 + 5 + 1 。\n​    这个时候我们分别假设 1，2，5 三种面值的币分别为最后一个硬币的情况：\n\n最后一枚硬币的面额为 1: min = f(11-1) + 1\n\n最后一枚硬币的面额为 2: min = f(11-2) + 1\n\n最后一枚硬币的面额为 5: min = f(11-5) + 1\nf(11) = min( f(11-1),f(11-2),f(11-5) ) + 1\n\nf(n) = min{f(n-1), f(n-5), f(n-11)} + 1\nf(n-1) = min{f(n-1-1), f(n-1-5), f(n-1-11)} + 1\n\n\n\n\n暴力解法-递归\n\n最优子结构，子问题间必须互相独立\n\nfunction coin(coins, amount) &#123;  if(amount === 0) return 0  let min = Number.MAX_SAFE_INTEGER  for(let i of coins)&#123;    if(amount - i &lt; 0) continue    min = Math.min(coin(coins,amount - i),min)  &#125;  return min + 1&#125;\n\n\n递归树\n\n\n时间复杂度\n\n子问题总数，O(n^k)\n每个子问题中含有一个for循环，复杂度为 O(k)\n所以总时间复杂度为 O(k*n^k)\n\n\n\n\n带备忘录的递归算法\n\nfunction coin2(coins, amount) &#123;  let arr = new Array(amount + 1)  return coinHelper(coins, amount,arr)&#125;function coinHelper(coins, amount,arr) &#123;  if(amount === 0) return 0  if(arr[amount]) return arr[amount]  let min = Number.MAX_SAFE_INTEGER  for(let i of coins)&#123;    if(amount - i &lt; 0) continue    min = Math.min(coinHelper(coins, amount-i,arr),min)  &#125;  arr[amount] = min + 1  return arr[amount]&#125;\n\n\n动态规划\n\nfunction coin3(coins, amount) &#123;  let arr = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER)  arr[0] = 0  for(let i = 1; i &lt;= amount; i++)&#123;    for(let j of coins)&#123;      if(i &lt; j) continue      arr[i] = Math.min(arr[i-j],arr[i])+1    &#125;  &#125;  return arr[amount]&#125;\n\n\n树\n\n\n\n\n\n案例3：双蛋问题\n\n递归解法\n假设从 i 层开始扔鸡蛋\nf(还要尝试的楼层，剩下的鸡蛋)\n* 鸡蛋碎了 f(i-1,e-1) \n* 鸡蛋没碎 f(f-i,e)\n* max(f(i-1,e-1),  f(f-i,e)) + 1\n\nfunction egg(f,e) &#123;  if(f &lt;= 1 || e === 1) return f  let min = Number.MAX_SAFE_INTEGER  for(let i = 1; i &lt;= f; i++)&#123;    min = Math.min(Math.max(egg(i-1,e-1),egg(f-i,e))+1,min)  &#125;  return min&#125;\n\n\n递归树\n\n\n\n\n动态规划\n\nfunction egg2(f,e) &#123;  if(f &lt;= 1 || e === 1) return f  // 二维数组,初始填充0  let arr = Array.from(new Array(f+1), () =&gt; new Array(e + 1).fill(0))  // 边界处理，只有一个鸡蛋，i 层就要扔 i 次  for(let i = 1; i &lt;= f; i++)&#123;    arr[i][1] = i  &#125;  // 边界处理，只有一层，i不论多少个鸡蛋，只要扔一次  for(let j = 1; j &lt;= e; j++)&#123;    arr[1][j] = 1  &#125;  for(let i = 2; i &lt;= f; i++)&#123;    for(let j = 2; j &lt;= e; j++)&#123;      let min = Number.MAX_SAFE_INTEGER      for(let k = 1; k &lt; i; k++)&#123;        min = Math.min(Math.max(arr[k-1][j-1],arr[i-k][j])+1,min)      &#125;      arr[i][j] = min    &#125;  &#125;  return arr[f][e]&#125;\n\n案例4：石头游戏题目：你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。\n石头的堆数可以是任意正整数，石头的总数也可以是任意正整数，这样就能打破先手必胜的局面了。比如有三堆石头 piles = [1, 100, 3]，先手不管拿 1 还是 3，能够决定胜负的 100 都会被后手拿走，后手会获胜。\n假设两人都很聪明，请你设计一个算法，返回先手和后手的最后得分（石头总数）之差。比如上面那个例子，先手能获得 4 分，后手会获得 100 分，你的算法应该返回 -96。\n这样推广之后，这个问题算是一道 Hard 的动态规划问题了。博弈问题的难点在于，两个人要轮流进行选择，而且都贼精明，应该如何编程表示这个过程呢？\n还是强调多次的套路，首先明确 dp 数组的含义，然后和股票买卖系列问题类似，只要找到「状态」和「选择」，一切就水到渠成了。\n一、定义 dp 数组的含义定义 dp 数组的含义是很有技术含量的，同一问题可能有多种定义方法，不同的定义会引出不同的状态转移方程，不过只要逻辑没有问题，最终都能得到相同的答案。\n介绍 dp 数组的含义之前，我们先看一下 dp 数组最终的样子：\n\n下文讲解时，认为元组是包含 first 和 second 属性的一个类，而且为了节省篇幅，将这两个属性简写为 fir 和 sec。比如按上图的数据，我们说 dp[1][3].fir = 10，dp[0][1].sec = 3。\n先回答几个读者可能提出的问题：\n这个二维 dp table 中存储的是元组，怎么编程表示呢？这个 dp table 有一半根本没用上，怎么优化？很简单，都不要管，先把解题的思路想明白了再谈也不迟。\n以下是对 dp 数组含义的解释：\ndp[i][j].fir 表示，对于 piles[i...j] 这部分石头堆，先手能获得的最高分数。dp[i][j].sec 表示，对于 piles[i...j] 这部分石头堆，后手能获得的最高分数。举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。复制代码\n\n我们想求的答案是先手和后手最终分数之差，按照这个定义也就是 dp[0][n-1].fir - dp[0][n-1].sec，即面对整个 piles，先手的最优得分和后手的最优得分之差。\n二、状态转移方程写状态转移方程很简单，首先要找到所有「状态」和每个状态可以做的「选择」，然后择优。\n根据前面对 dp 数组的定义，状态显然有三个：开始的索引 i，结束的索引 j，当前轮到的人。\ndp[i][j][fir or sec]其中：0 &lt;= i &lt; piles.lengthi &lt;= j &lt; piles.length\n\n对于这个问题的每个状态，可以做的选择有两个：选择最左边的那堆石头，或者选择最右边的那堆石头。 我们可以这样穷举所有状态：\nn = piles.lengthfor 0 &lt;= i &lt; n:    for j &lt;= i &lt; n:        for who in &#123;fir, sec&#125;:            dp[i][j][who] = max(left, right)\n\n上面的伪码是动态规划的一个大致的框架，股票系列问题中也有类似的伪码。这道题的难点在于，两人是交替进行选择的，也就是说先手的选择会对后手有影响，这怎么表达出来呢？\n根据我们对 dp 数组的定义，很容易解决这个难点，写出状态转移方程：\ndp[i][j].fir = max(piles[i] + dp[i+1][j].sec, piles[j] + dp[i][j-1].sec)dp[i][j].fir = max(选择最左边的石头堆, 选择最右边的石头堆) # 解释：我作为先手，面对 piles[i...j] 时，有两种选择： # 要么我选择最左边的那一堆石头，然后面对 piles[i+1...j] # 但是此时轮到对方，相当于我变成了后手； # 要么我选择最右边的那一堆石头，然后面对 piles[i...j-1] # 但是此时轮到对方，相当于我变成了后手。if 先手选择左边:dp[i][j].sec = dp[i+1][j].firif 先手选择右边:dp[i][j].sec = dp[i][j-1].fir# 解释：我作为后手，要等先手先选择，有两种情况：# 如果先手选择了最左边那堆，给我剩下了 piles[i+1...j]# 此时轮到我，我变成了先手；# 如果先手选择了最右边那堆，给我剩下了 piles[i...j-1]# 此时轮到我，我变成了先手。复制代码\n\n根据 dp 数组的定义，我们也可以找出 base case，也就是最简单的情况：\ndp[i][j].fir = piles[i]dp[i][j].sec = 0其中 0 &lt;= i == j &lt; n# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]# 那么显然先手的得分为 piles[i]# 后手没有石头拿了，得分为 0复制代码\n\n\n\n\n这里需要注意一点，我们发现 base case 是斜着的，而且我们推算 dp[i][j] 时需要用到 dp[i+1][j] 和 dp[i][j-1]：\n\n所以说算法不能简单的一行一行遍历 dp 数组，而要斜着遍历数组：\n\n说实话，斜着遍历二维数组说起来容易，你还真不一定能想出来怎么实现，不信你思考一下？这么巧妙的状态转移方程都列出来了，要是不会写代码实现，那真的很尴尬了。。。\n三、代码实现如何实现这个 fir 和 sec 元组呢，你可以用 python，自带元组类型；或者使用 C++ 的 pair 容器；或者用一个三维数组 dp[n][n][2]，最后一个维度就相当于元组；或者我们自己写一个 Pair 类：\nclass Pair &#123;    int fir, sec;    Pair(int fir, int sec) &#123;        this.fir = fir;        this.sec = sec;    &#125;&#125;复制代码\n\n然后直接把我们的状态转移方程翻译成代码即可，可以注意一下斜着遍历数组的技巧：\n/* 返回游戏最后先手和后手的得分之差 */int stoneGame(int[] piles) &#123;    int n = piles.length;    // 初始化 dp 数组    Pair[][] dp = new Pair[n][n];    for (int i = 0; i &lt; n; i++)         for (int j = i; j &lt; n; j++)            dp[i][j] = new Pair(0, 0);    // 填入 base case    for (int i = 0; i &lt; n; i++) &#123;        dp[i][i].fir = piles[i];        dp[i][i].sec = 0;    &#125;    // 斜着遍历数组    for (int l = 2; l &lt;= n; l++) &#123;        for (int i = 0; i &lt;= n - l; i++) &#123;            int j = l + i - 1;            // 先手选择最左边或最右边的分数            int left = piles[i] + dp[i+1][j].sec;            int right = piles[j] + dp[i][j-1].sec;            // 套用状态转移方程            if (left &gt; right) &#123;                dp[i][j].fir = left;                dp[i][j].sec = dp[i+1][j].fir;            &#125; else &#123;                dp[i][j].fir = right;                dp[i][j].sec = dp[i][j-1].fir;            &#125;        &#125;    &#125;    Pair res = dp[0][n-1];    return res.fir - res.sec;&#125;复制代码\n\n动态规划解法，如果没有状态转移方程指导，绝对是一头雾水，但是根据前面的详细解释，读者应该可以清晰理解这一大段代码的含义。\n而且，注意到计算 dp[i][j] 只依赖其左边和下边的元素，所以说肯定有优化空间，转换成一维 dp，想象一下把二维平面压扁，也就是投影到一维。但是，一维 dp 比较复杂，可解释性很差，大家就不必浪费这个时间去理解了。\n四、最后总结本文给出了解决博弈问题的动态规划解法。博弈问题的前提一般都是在两个聪明人之间进行，编程描述这种游戏的一般方法是二维 dp 数组，数组中通过元组分别表示两人的最优决策。\n之所以这样设计，是因为先手在做出选择之后，就成了后手，后手在对方做完选择后，就变成了先手。这种角色转换使得我们可以重用之前的结果，典型的动态规划标志。\n读到这里的朋友应该能理解算法解决博弈问题的套路了。学习算法，一定要注重算法的模板框架，而不是一些看起来牛逼的思路，也不要奢求上来就写一个最优的解法。不要舍不得多用空间，不要过早尝试优化，不要惧怕多维数组。dp 数组就是存储信息避免重复计算的，随便用，直到咱满意为止。\n3. 动态规划设计方法：归纳思想了解了动态规划的套路，也不会写状态转移方程，没有思路，怎么办？本文就借助「最长递增子序列」来讲一种设计动态规划的通用技巧：数学归纳思想。\n最长递增子序列（Longest Increasing Subsequence，简写 LIS）是比较经典的一个问题，比较容易想到的是动态规划解法，时间复杂度 O(N^2)，我们借这个问题来由浅入深讲解如何写动态规划。比较难想到的是利用二分查找，时间复杂度是 O(NlogN)，我们通过一种简单的纸牌游戏来辅助理解这种巧妙的解法。\n先看一下题目，很容易理解：\n\n注意「子序列」和「子串」这两个名词的区别，子串一定是连续的，而子序列不一定是连续的。下面先来一步一步设计动态规划算法解决这个问题。\n动态规划解法 动态规划的核心设计思想是数学归纳法。\n相信大家对数学归纳法都不陌生，高中就学过，而且思路很简单。比如我们想证明一个数学结论，那么我们先假设这个结论在 k&lt;nk&lt;n 时成立，然后想办法证明 k=nk=n 的时候此结论也成立。如果能够证明出来，那么就说明这个结论对于 k 等于任何数都成立。\n类似的，我们设计动态规划算法，不是需要一个 dp 数组吗？我们可以假设 dp[0…i-1]dp[0…i−1] 都已经被算出来了，然后问自己：怎么通过这些结果算出 dp[i]？\n直接拿最长递增子序列这个问题举例你就明白了。不过，首先要定义清楚 dp 数组的含义，即 dp[i] 的值到底代表着什么？\n我们的定义是这样的：dp[i] 表示以 nums[i] 这个数结尾的最长递增子序列的长度。\n举两个例子：\n\n算法演进的过程是这样的，：\n\n根据这个定义，我们的最终结果（子序列的最大长度）应该是 dp 数组中的最大值。\nint res = 0;for (int i = 0; i &lt; dp.size(); i++) &#123;    res = Math.max(res, dp[i]);&#125;return res;\n\n读者也许会问，刚才这个过程中每个 dp[i] 的结果是我们肉眼看出来的，我们应该怎么设计算法逻辑来正确计算每个 dp[i] 呢？\n这就是动态规划的重头戏了，要思考如何进行状态转移，这里就可以使用数学归纳的思想：\n我们已经知道了 dp[0…4]dp[0…4] 的所有结果，我们如何通过这些已知结果推出 dp[5]dp[5] 呢？\n根据刚才我们对 dp 数组的定义，现在想求 dp[5] 的值，也就是想求以 nums[5] 为结尾的最长递增子序列。\nnums[5] = 3，既然是递增子序列，我们只要找到前面那些结尾比 3 小的子序列，然后把 3 接到最后，就可以形成一个新的递增子序列，而且这个新的子序列长度加一。\n当然，可能形成很多种新的子序列，但是我们只要最长的，把最长子序列的长度作为 dp[5] 的值即可。\n\nfor (int j = 0; j &lt; i; j++) &#123;    if (nums[i] &gt; nums[j])         dp[i] = Math.max(dp[i], dp[j] + 1);&#125;\n\n这段代码的逻辑就可以算出 dp[5]。到这里，这道算法题我们就基本做完了。读者也许会问，我们刚才只是算了 dp[5] 呀，dp[4], dp[3] 这些怎么算呢？\n类似数学归纳法，你已经可以算出 dp[5] 了，其他的就都可以算出来：\nfor (int i = 0; i &lt; nums.length; i++) &#123;    for (int j = 0; j &lt; i; j++) &#123;        if (nums[i] &gt; nums[j])             dp[i] = Math.max(dp[i], dp[j] + 1);    &#125;&#125;复制代码\n\n还有一个细节问题，dp 数组应该全部初始化为 1，因为子序列最少也要包含自己，所以长度最小为 1。下面我们看一下完整代码：\npublic int lengthOfLIS(int[] nums) &#123;    int[] dp = new int[nums.length];    // dp 数组全都初始化为 1    Arrays.fill(dp, 1);    for (int i = 0; i &lt; nums.length; i++) &#123;        for (int j = 0; j &lt; i; j++) &#123;            if (nums[i] &gt; nums[j])                 dp[i] = Math.max(dp[i], dp[j] + 1);        &#125;    &#125;        int res = 0;    for (int i = 0; i &lt; dp.length; i++) &#123;        res = Math.max(res, dp[i]);    &#125;    return res;&#125;复制代码\n\n至此，这道题就解决了，时间复杂度 O(N^2)。总结一下动态规划的设计流程：\n首先明确 dp 数组所存数据的含义。这步很重要，如果不得当或者不够清晰，会阻碍之后的步骤。\n然后根据 dp 数组的定义，运用数学归纳法的思想，假设 dp[0…i-1]dp[0…i−1] 都已知，想办法求出 dp[i]dp[i]，一旦这一步完成，整个题目基本就解决了。\n但如果无法完成这一步，很可能就是 dp 数组的定义不够恰当，需要重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。\n最后想一想问题的 base case 是什么，以此来初始化 dp 数组,以保证算法正确运行。\n","categories":["算法"],"tags":["算法"]},{"title":"封装 Vue 组件库","url":"/2021/05/31/vue/%E5%B0%81%E8%A3%85vue%E7%BB%84%E4%BB%B6%E5%BA%93/","content":"CDD（Component-Driven Development)\n自上而下\n从组件级别开始，到页面级别结束\n\n优点：\n\n组件在最大程度被重用\n并行开发\n可视化测试\n\n处理组件的边界情况\n$root         ———-响应式的\n\n$parent/$children        ———-响应式的\n\n$refs            ———-响应式的\n\n依赖注入 provide / inject   ——–非响应式的\n\n$attrs  : 把父组件中非 prop 属性绑定到内部组件\n\n从父组件传给自定义子组件的属性，如果没有 prop 接收会自动设置到子组件内部的最外层标签上，如果是 class 和 style 的话，会合并最外层标签的 class 和 style\n如果子组件中不想继承父组件传入的非 prop 属性，可以使用 inheritAttrs 禁用继承，然后通过 v-bind=”$attrs” 把外部传入的非 prop 属性设置给希望的标签上，但是这不会改变 class 和 style\n\n\n$listeners ：把父组件中的 DOM 对象的原生事件绑定到内部组件\n\n\n快速原型开发\nVueCLI 中提供了一个插件可以进行原型快速开发\n\n需要额外安装一个全局的扩展\nnpm install -g @vue/cli-service-global\n使用 vue serve 快速查看组件的运行效果\n\nvue serve 如果不指定参数默认会在当前目录找以下的入口文件\nmain.js   index.js    App.vue   app.vue\n可以指定要加载的组件\nvue serve ./src/login.vue\n\n\n\n基于 elementUI 开发\n初始化 package.json ———npm init -y\n安装 ElementUI  ———– vue add element\n加载 ElementUI，使用 Vue.use() 安装插件\n\n组件分类\n第三方组件\n基础组件\n业务组件\n\n组件开发步骤条组件&lt;template&gt;  &lt;div class=&quot;lg-steps&quot;&gt;    &lt;div class=&quot;lg-steps-line&quot;&gt;&lt;/div&gt;    &lt;div        class=&quot;lg-step&quot;        v-for=&quot;index in count&quot;        :key=&quot;index&quot;        :style=&quot;&#123;color:index &lt;= active ? activeColor : defaultColor &#125;&quot;    &gt;      &#123;&#123; index &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#x27;./steps.css&#x27;  export default &#123;    name: &quot;LgSteps&quot;,    props:&#123;      count:&#123;        type:Number,        default:3      &#125;,      active:&#123;        type:Number,        default: 0      &#125;,      activeColor:&#123;        type:String,        default:&#x27;red&#x27;      &#125;,      defaultColor:&#123;        type:String,        default:&#x27;green&#x27;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n\n表单组件\nForm 组件 依赖注入 整个form  provide ()&#123; return &#123; form:this &#125;&#125;\n\nFormItem 接收 form,从中获取 models 和 rules inject:[&#39;form&#39;]，\n\n表单验证  npm i async-validator\n\n\nInput组件中触发自定义事件 validate\n\nFormItem 渲染完毕注册自定义事件 validate\n\n\nForm 组件&lt;template&gt;  &lt;div class=&quot;lg-steps&quot;&gt;    &lt;div class=&quot;lg-steps-line&quot;&gt;&lt;/div&gt;    &lt;div        class=&quot;lg-step&quot;        v-for=&quot;index in count&quot;        :key=&quot;index&quot;        :style=&quot;&#123;color:index &lt;= active ? activeColor : defaultColor &#125;&quot;    &gt;      &#123;&#123; index &#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import &#x27;./steps.css&#x27;  export default &#123;    name: &quot;LgSteps&quot;,    props:&#123;      count:&#123;        type:Number,        default:3      &#125;,      active:&#123;        type:Number,        default: 0      &#125;,      activeColor:&#123;        type:String,        default:&#x27;red&#x27;      &#125;,      defaultColor:&#123;        type:String,        default:&#x27;green&#x27;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n\nFormItem 组件&lt;template&gt;  &lt;div&gt;    &lt;label&gt;&#123;&#123; label &#125;&#125;&lt;/label&gt;    &lt;div&gt;      &lt;slot&gt;&lt;/slot&gt;      &lt;p v-if=&quot;errMessage&quot;&gt;&#123;&#123; errMessage &#125;&#125;&lt;/p&gt;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  import AsyncValidator from &#x27;async-validator&#x27;  export default &#123;    name: &quot;LgFormItem&quot;,    inject:[&#x27;form&#x27;],    props:&#123;      label:&#123;        type:String      &#125;,      prop:&#123;        type:String      &#125;    &#125;,    data()&#123;      return &#123;        errMessage:&#x27;&#x27;      &#125;    &#125;,    mounted()&#123;      this.$on(&#x27;validate&#x27;,() =&gt; &#123;        this.validate()      &#125;)    &#125;,    methods:&#123;      validate()&#123;        if(!this.prop) return        const value = this.form.model[this.prop]        const rules = this.form.rules[this.prop]                const descriptor = &#123;          [this.prop]:rules        &#125;                const validator = new AsyncValidator(descriptor)        return validator.validate(&#123; [this.prop]:value &#125;,errs =&gt; &#123;          if(errs) &#123;            this.errMessage = errs[0].message          &#125;else&#123;            this.errMessage = &#x27;&#x27;          &#125;        &#125;)      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n\nInput 组件&lt;template&gt;  &lt;div&gt;    &lt;input v-bind=&quot;$attrs&quot; :type=&quot;type&quot; :value=&quot;value&quot; @input=&quot;handleInput&quot;&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;LgInput&quot;,    inheritAttrs:false,    props:&#123;      value:&#123;        type:String      &#125;,      type:&#123;        type:String,        default:&#x27;text&#x27;      &#125;    &#125;,    methods:&#123;      handleInput(event)&#123;        this.$emit(&#x27;input&#x27;,event.target.value)        const findParent = parent =&gt; &#123;          while(parent)&#123;            if(parent.$options.name === &#x27;LgFormItem&#x27;)&#123;              break            &#125;else&#123;              parent = parent.$parent            &#125;          &#125;          return parent        &#125;        const parent = findParent(this.$parent)                if(parent)&#123;          parent.$emit(&#x27;validate&#x27;)        &#125;      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n\nButton 组件&lt;template&gt;  &lt;div&gt;    &lt;button @click=&quot;handleClick&quot;&gt;      &lt;slot&gt;&lt;/slot&gt;    &lt;/button&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;  export default &#123;    name: &quot;LgButton&quot;,    methods:&#123;      handleClick(event)&#123;        this.$emit(&#x27;click&#x27;,event)        event.preventDefault()      &#125;    &#125;  &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;\n\n\n\n组件管理\nMultirepo（Multiple Repository）\n每一个包对应一个项目\n\nMonorepo（Monolithic Repository）\n一个项目仓库中管理多个模块 / 包\n\n\nMonorepo\n组件库开发\n\npackages 文件夹下，每个组件对应一个文件夹，目录结构如下：\n-packages\t- button\t\t- __test__\t\t- dist\t\t- src\t\t\t- button.vue\t\t- index.js\t\t- LICENCE\t\t- package.json\t\t- README.md\t- form\t- formitem\t- input\t- steps\n\nStorybook\n可视化的组件展示平台\n在隔离的开发环境中，以交互式的方式展示组件\n独立开发组件\n支持的框架\nReact 、React Native 、Vue 、Angular \nEmber 、HTML 、Svelte 、Mithril 、Riot\n\n\n\n安装自动安装\nnpx -p @storybook/cli sb init --type vueyarn add vueyarn add vue-loader vue-template-compiler --dev\n\n手动安装\n略\nyarn 工作区npm  不支持 workspaces\n开启 yarn 工作区项目根目录的 package.json\n&quot;private&quot;:true,&quot;workspaces&quot;:[\t&quot;packages/*&quot;]\n\nyarn workspaces 使用\n给工作区根目录安装开发依赖\nyarn add jest -D -W\n给指定工作区安装依赖\nyarn workspace q-button add lodash@4\n给所有的工作区安装依赖\nyarn install\n\nLerna\nLerna 是一个优化使用 git 和 npm 管理多包仓库的工作流工具\n用于管理具有多个包的 JavaScript 项目\n它可以一键把代码提交到 git 和 npm 仓库\n\n使用\n全局安装\nyarn global add lerna\n初始化\nlerna init\n发布\nlerna publish\n\nnpm 指令\n登录 npm\nnpm login\n查看 npm 登录人\nnpm whoami\n查看镜像源\nnpm config get registry\n\nVue 组件单元测试对函数的输入输出进行测试，使用断言，根据输入判断实际输出和预计输出是否一致\n组件单元测试是指使用单元测试工具对组件的行为和状态进行测试，确保组件发布之后在项目使用过程中不会导致错误\n组件单元测试优点：\n\n提供描述组件行为的文档\n节省手动测试的时间\n减少研发新特性时产生的 bug\n改进设计\n促进重构\n\n配置环境\n安装依赖\n\nVue Test Utils\nJest\nvue-jest\nbabel-jest\n\nyarn add jest @vue/test-utils vue-jest babel-jest -D -W\n配置测试脚本\n\npackage.json\n\n&quot;scripts&quot;:&#123;\t&quot;test&quot;:&quot;jest&quot;&#125;\nJest 配置文件\n\njest.config.js\n\nmodule.exports = &#123;\t&quot;testMatch&quot;:[&quot;**/__tests__/**/*.[jt]s?(x)&quot;], // js jsx ts tsx\t&quot;moduleFileExtensions&quot;:[ \t\t&quot;js&quot;,\t\t&quot;json&quot;,\t\t&quot;vue&quot; // 告诉 Jest 处理 `*.vue` 文件\t],\t&quot;transform&quot;:&#123;\t\t&quot;.*\\\\.(vue)$&quot;:&quot;vue-jest&quot;, // 用 `vue-jest` 处理 `*.vue` 文件\t\t&quot;.*\\\\.(js)$&quot;:&quot;babel-jest&quot; // 用 `babel-jest` 处理 `*.js` 文件\t&#125;&#125;\nBabel 配置文件\n\nbabel.config.js\n\nmodule.exports = &#123;\tpresets:[\t\t&#x27;@babel/preset-env&#x27;\t]&#125;\n\n\nBabel 桥接\n\nyarn add babel-core@bridge -D -W\n\nJest 常用 API\n全局函数\ndescribe(name, fn)      把相关测试组合在一起\ntest(name, fn)               测试方法\nexpect(value)                断言\n\n\n匹配器\ntoBe(value)                   判断值是否相等\ntoEqual(obj)                  判断对象是否相等\ntoContain(value)          判断数组或字符串中是否包含\n\n\n快照\ntoMatchSnapshot()\n\n\n\nVue Test Utils 常用 API\nmount()\n创建一个包含被挂载和渲染 Vue 组件的 Wrapper\n\n\nWrapper\nvm                wrapper 包裹的组件实例\nprops()         返回 Vue 实例选项中的 props 对象\nhtml()           组件生成的 HTML 标签\nfind()            通过选择器返回匹配到的组件中的 DOM 元素\ntrigger()       触发 DOM 原生事件，自定义事件 wrapper.vm.$emit()\n\n\n\n// __test__ / input.test.jsimport input from &#x27;../src/input.vue&#x27;import &#123; mount &#125; from &#x27;@vue/test-utils&#x27;describe(&#x27;q-input&#x27;,() =&gt; &#123;  test(&#x27;input-text&#x27;,() =&gt; &#123;    const wrapper = mount(input)    expect(wrapper.html()).toContain(&#x27;input type=&quot;text&quot;&#x27;)  &#125;)    test(&#x27;input-password&#x27;,() =&gt; &#123;    const wrapper = mount(input,&#123;      propsData:&#123;        type:&#x27;password&#x27;      &#125;    &#125;)    expect(wrapper.html()).toContain(&#x27;input type=&quot;password&quot;&#x27;)  &#125;)    test(&#x27;input-password&#x27;,() =&gt; &#123;    const wrapper = mount(input,&#123;      propsData:&#123;        type:&#x27;password&#x27;,        value:&#x27;admin&#x27;      &#125;    &#125;)    expect(wrapper.props(&#x27;value&#x27;)).toBe(&#x27;admin&#x27;)  &#125;)    test(&#x27;input-snapshot&#x27;,() =&gt; &#123;    const wrapper = mount(input,&#123;      propsData:&#123;        type:&#x27;text&#x27;,        value:&#x27;admin&#x27;      &#125;j    &#125;)    expect(wrapper.vm.$el).toMatchSnapshot()  &#125;)&#125;)\n\n\n\nRollup 打包\nRollup 是一个模块打包器\nRollup 支持 Tree-shaking \n打包的结果比 Webpack 要小\n开发框架/组件库的时候使用 Rollup 更合适\n\n安装依赖\nRollup\nrollup-plugin-terser\n&#114;&#111;&#108;&#x6c;&#117;&#112;&#x2d;&#x70;&#x6c;&#x75;&#103;&#105;&#110;&#45;&#x76;&#x75;&#x65;&#x40;&#x35;&#46;&#49;&#46;&#x39;  // 必须制定版本，这个版本是转换 vue 2,新版本转换 vue 3\nvue-template-compiler\n\n配置文件只打包 button 文件\n\n在 button 目录中创建 rollup.config.js\n\nimport &#123; terser &#125; from &#x27;rollup-plugin-terser&#x27;import vue from &#x27;rollup-plugin-vue&#x27;module.exports = [\t&#123;\t\tinput:&#x27;index.js&#x27;,\t\toutput:[\t\t\t&#123;\t\t\t\tfile:&#x27;dist/index.js&#x27;,\t\t\t\tformat:&#x27;es&#x27;\t\t\t&#125;\t\t],\t\tplugins:[\t\t\tvue(&#123;\t\t\t\tcss:true,\t\t\t\tcompileTemplate:true\t\t\t&#125;),\t\t\tterser()\t\t]\t&#125;]\n\n\nbutton 目录下 package.json\n\n&quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;rollup -c&quot;  &#125;,\n\n\n运行命令\n\nyarn workspace q-button run build\n\n\n\n打包全部文件\n\n安装依赖\nyarn add @rollup/plugin-json rollup-plugin-postcss @rollup/plugin-node-resolve -D -W\n配置文件\n项目根目录创建 rollup.config.js\nimport fs from &#x27;fs&#x27;import path from &#x27;path&#x27;import json from &#x27;@rollup/plugin-json&#x27;import vue from &#x27;rollup-plugin-vue&#x27;import postcss from &#x27;rollup-plugin-postcss&#x27;import &#123; terser &#125; from &#x27;rollup-plugin-terser&#x27;import &#123; nodeResolve &#125; from &#x27;@rollup/plugin-node-resolve&#x27;const isDev = process.env.NODE_ENV !== &#x27;production&#x27;// 公共插件配置const plugins = [\tvue(&#123;\t\t// Dynamically inject css as a &lt;style&gt; tag        css:true,        // Explicitly convert template to render function        compileTemplate:true     &#125;),    json(),    nodeResolve(),    postcss(&#123;        // 把 css 插入到 style 中        // inject :true,        // 把 css 放到 js 同一目录        extract:true    &#125;)]// 如果不是开发环境，开启压缩isDev || plugins.push(terser())// package 文件夹路径const root = path.resolve(__dirname,&#x27;packages&#x27;)module.exports = fs.readdirSync(root)\t// 过滤，只保留文件夹\t.filter(item =&gt; fs.statSync(path.resolve(root, item)).isDirectory())\t// 为每一个文件夹创建对应的配置\t.map(item =&gt; &#123;    \tconst pkg = require(path.resolve(root,item,&#x27;package.json&#x27;))        return &#123;            input:path.resolve(root, item, &#x27;index.js&#x27;),            output:[                &#123;                    exports:&#x27;auto&#x27;,                    file:path.resolve(root, item, pkg.main),                    format:&#x27;cjs&#x27;                &#125;,                &#123;                    exports:&#x27;auto&#x27;,                    file:path.resolve(root, item, pkg.module),                    format:&#x27;es&#x27;                &#125;,            ],            plugins:plugins        &#125;\t&#125;)\n在每一个包中设置 package.json 中的 main 和 module 字段\n&quot;main&quot;:&quot;dist/cjs/index.js&quot;&quot;module&quot;:&quot;dist/es/index.js&quot;\n根目录的 package.json 中配置 scripts\n&quot;build&quot;:&quot;rollup -c&quot;\n\n\n遇到的问题\nError: PostCSS plugin postcss-noop-plugin requires PostCSS 8.\n\n解决\nyarn add postcss-loader &#x61;&#117;&#x74;&#x6f;&#112;&#x72;&#x65;&#x66;&#105;&#120;&#x65;&#x72;&#x40;&#56;&#46;&#x30;&#x2e;&#x30; -D -W\npostcss(&#123;    plugins:[      require(&#x27;autoprefixer&#x27;)(&#123;overrideBrowserlist:[&#x27;&gt; 0.15% in CN&#x27;]&#125;)    ]  &#125;)\n\n\n\n设置环境变量\n安装依赖  cross-env ,可以跨平台设置环境变量\nyarn add cross-env -D -W\n修改 项目根目录 package.json 中 scripts 中的 build\n&quot;scripts&quot;:&#123;    &quot;build:prod&quot;:&quot;cross-env NODE_ENV=production rollup -c&quot;,    &quot;build:dev&quot;:&quot;cross-env NODE_ENV=development rollup -c&quot;&#125;\n\n清理\n清理所有包中的 node_modules\n项目根目录 package.json\n&quot;scripts&quot;:&#123;    &quot;clean&quot;: &quot;lerna clean&quot;&#125;\n清理 所有的 dist\n\n安装依赖 rimraf\nyarn add rimraf -D -W\n每个包的  package.json\n&quot;scripts&quot;: &#123;    &quot;del&quot;: &quot;rimraf dist&quot;  &#125;,\n执行所有包中的 del 命令\nyarn workspaces run del\n\n\n\n基于模板生成组件基本结构plop\n\n安装 plop\nyarn add plop -D -W\n创建模板 plop-template 目录\n\nplopfile.js 配置文件\nmodule.exports = plop =&gt; &#123;  plop.setGenerator(&#x27;component&#x27;, &#123;    description: &#x27;create a custom component&#x27;,    prompts: [      &#123;        type: &#x27;input&#x27;,        name: &#x27;name&#x27;,        message: &#x27;component name&#x27;,        default: &#x27;MyComponent&#x27;      &#125;    ],    actions: [      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/src/&#123;&#123;name&#125;&#125;.vue&#x27;,        templateFile: &#x27;plop-template/component/src/component.hbs&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/__tests__/&#123;&#123;name&#125;&#125;.test.js&#x27;,        templateFile: &#x27;plop-template/component/__tests__/component.test.hbs&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/stories/&#123;&#123;name&#125;&#125;.stories.js&#x27;,        templateFile: &#x27;plop-template/component/stories/component.stories.hbs&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/index.js&#x27;,        templateFile: &#x27;plop-template/component/index.hbs&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/LICENSE&#x27;,        templateFile: &#x27;plop-template/component/LICENSE&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/package.json&#x27;,        templateFile: &#x27;plop-template/component/package.hbs&#x27;      &#125;,      &#123;        type: &#x27;add&#x27;,        path: &#x27;packages/&#123;&#123;name&#125;&#125;/README.md&#x27;,        templateFile: &#x27;plop-template/component/README.hbs&#x27;      &#125;    ]  &#125;)&#125;\n根目录 package.json 文件添加命令\n&quot;scripts&quot;: &#123;    &quot;plop&quot;: &quot;plop&quot;  &#125;,\n运行命令\nyarn plop\n\n","categories":["vue"],"tags":["vue"]},{"title":"手写babel","url":"/2021/05/18/webpack/%E6%89%8B%E5%86%99babel/","content":"整体思路babel 的编译流程我们知道，babel 的主要编译流程是 parse、transform、generate。\n\nparse 是把源码转成 AST\ntransform 是对 AST 做增删改\ngenerate 是打印 AST 成目标代码并生成 sourcemap\n\nbabel7 内置的包babel 7 把这些功能的实现放到了不同的包里面：\n\n@babel/parser 解析源码成 AST，对应 parse 阶段\n@babel/traverse 遍历 AST 并调用 visitor 函数，对应 transform 阶段\n@babel/generate 打印 AST，生成目标代码和 sorucemap，对应 generate 阶段\n\n其中，遍历过程中需要创建 AST，会用到：\n\n@babel/types 创建、判断 AST\n@babel/template 根据模块批量创建 AST\n\n上面是每一个阶段的功能， babel 整体功能的入口是在：\n\n@babel/core 解析配置、应用 plugin、preset，完成整体编译流程\n\n插件和插件之间有一些公共函数，这些都是在：\n\n@babel/helpers 用于转换 es next 代码需要的通过模板创建的 AST，比如 _typeof、_defineProperties 等\n@babel/helper-xxx 其他的插件之间共享的用于操作 AST 的公共函数\n\n当然，除了编译期转换的时候会有公共函数以外，运行时也有，这部分是放在：\n\n@babel/runtime 主要是包含 corejs、helpers、regenerator 这 3 部分：\n\n\nhelper：helper 函数的运行时版本（不是通过 AST 注入了，而是运行时引入代码）\ncorejs：es next 的 api 的实现，corejs 2 只支持静态方法，corejs 3 还支持实例方法\nregenerator：async await 的实现，由 facebook 维护\n\n\n\n（babel 做语法转换是自己实现的 helper，但是做 polyfill 都不是自己实现的，而是借助了第三方的 corejs、regenerator）\n我们要实现哪些包上面介绍的是 babel 完成功能所内置的一些包，我们如果要写一个简易的 babel，也得实现这些包，但可以做一些简化。\n\nparser 包是肯定要实现的，babel parser 是基于 acorn fork 的，我们也基于 acorn，做一点扩展。完成从源码到 AST 的转换。\ntraverse 包是对 AST 的遍历，需要知道不同类型的 AST 都遍历哪些 key，这些是在 @babel/types 包里面定义的，我们也用类似的实现方式，并且会调用对应的 visitor，实现 path 和 path.scope 的一些 api 然后传入。\ngenerate 包是打印 AST 成目标代码，生成 sourcemap。打印这部分每个 AST 类型都要写一个对应的函数来处理，生成 sourcemap 使用 source-map 这个包，关联 parse 时记录的 loc 和打印时计算的位置来生成每一个 mapping。\ntypes 包用于创建 AST，会维护创建和判断各种 AST 的 api，并且提供每种 AST 需要遍历的属性是哪些，用于 traverse 的过程\ntemplate 包是批量创建 AST 的，这里我们实现一个简单的版本，传入字符串，parse 成 AST 返回。\ncore 包是整体流程的串联，支持 plugins 和 presets，调用插件，合并成最终的 visitors，然后再 traverse。\nhelper 包我们也会实现一个，因为支持了 plugin，那么中有一些公共的函数可以复用\nruntime 包我们也提供一下，不过只加入一些用于做语法转换的辅助函数就好了\n\n这是我们大概会做的事情，把这些都实现一遍就算一个比较完整的 babel 了。实现的过程中更能加深我们对 babel、对转译器的认识，不只是掌握 babel 本身。\n下面我们来详细分析一下每一步的具体思路：\n代码实现(因为代码在那台坏掉的电脑拿不出来，加上这也不是小册里，所以只会提供思路，等小册上线会提供完整源码的)\n为了简化，我们不做分包了，把代码都放在一个包里实现。\nparser主流的 parser 有 esprima、acorn 等，acorn 是最流行的，babel parser 是 fork 自 acorn，做了很多修改。我们不需要 fork，基于 acorn 的插件机制做一些扩展即可。\n比如 acorn 所 parse 出的 AST 只有 Literal （字面量）类型，不区分具体是字符串、数字或者布尔等字面量，而 babel parser 把它们细化成了 StringLiteral、NumericLiteral、BooleanLiteral 等 AST。\n我们就实现一下对 AST 做了这种扩展的 parser。\n我们先用一下原本的 acorn parser：\nconst acorn = require(&quot;acorn&quot;);const Parser = acorn.Parser;const ast = Parser.parse(`    const a = 1;`);console.log(JSON.stringify(ast, null, 2));\n\n打印如下：\n\n可以看到数字字面量 parse 的结果是 Literal，这样判断类型还需要去看下值的类型，才能确定是什么字面量，比较麻烦。这也是为什么 babel 把它们做了细化。\n我们也细化一下：\nacorn 扩展的方式是继承 + 重写，继承之前的 parser，重写一些方法，返回新 parser。\nconst acorn = require(&quot;acorn&quot;);const Parser = acorn.Parser;var literalExtend = function(Parser) &#123;  return class extends Parser &#123;    parseLiteral (...args) &#123;        const node = super.parseLiteral(...args);        switch(typeof node.value) &#123;            case &#x27;number&#x27;:                node.type = &#x27;NumericLiteral&#x27;;                break;            case &#x27;string&#x27;:                node.type = &#x27;StringLiteral&#x27;;                break;        &#125;        return  node;    &#125;  &#125;&#125;const newParser = Parser.extend(literalExtend);const ast = newParser.parse(`    const a = 1;`);console.log(JSON.stringify(ast, null, 2));\n\n我们在 parse 的时候就判断了字面量的类型，然后设置了 type。\n试下效果：\n\n这样，我们就实现了类似 babel parser 对 acorn 的扩展。\n当然，babel parser 的扩展有很多，这里我们只是简单实现，理清思路即可。\ntraverse遍历 AST 是一个深度优先搜索的过程，当处理到具体的 AST 节点我们要知道怎么继续遍历子 AST 节点。\n在 babel types 包中定义了不同 AST 怎么遍历（visitor）、怎么创建（builder）、怎么判断（fidelds.validate）以及别名（alias）。\nimage.png\n这里我们也需要维护每种 AST 怎么遍历的数据：\nconst AST_DEFINATIONS_MAP = new Map();AST_DEFINATIONS_MAP.set(&#x27;Program&#x27;, &#123;    visitor: [&#x27;body&#x27;]&#125;);AST_DEFINATIONS_MAP.set(&#x27;VariableDeclaration&#x27;, &#123;    visitor: [&#x27;declarations&#x27;]&#125;);AST_DEFINATIONS_MAP.set(&#x27;VariableDeclarator&#x27;, &#123;    visitor: [&#x27;id&#x27;, &#x27;init&#x27;]&#125;);AST_DEFINATIONS_MAP.set(&#x27;Identifier&#x27;, &#123;&#125;);AST_DEFINATIONS_MAP.set(&#x27;NumericLiteral&#x27;, &#123;&#125;);\n\n然后基于这些数据对 AST 进行深度优先遍历：\nfunction traverse(node) &#123;    const defination = astDefinationsMap.get(node.type);    console.log(node.type);    if (defination.visitor) &#123;        defination.visitor.forEach(key =&gt; &#123;            const prop = node[key];            if (Array.isArray(prop)) &#123; // 如果该属性是数组                prop.forEach(childNode =&gt; &#123;                    traverse(childNode);                &#125;)            &#125; else &#123;                traverse(prop);            &#125;        &#125;)    &#125;&#125;\n\n打印结果如下：\n\n对照下刚才的 AST 结构，确实实现了深度优先遍历。\n\nvisitor遍历之后，我们要实现 visitors 的功能，在遍历的过程中对 AST 做增删改。这个就是遍历的过程中根据 node.type 来调用对应的 visitor 函数：\nfunction traverse(node, visitors) &#123;    const defination = astDefinationsMap.get(node.type);    const visitorFunc = visitors[node.type];    if(visitorFunc &amp;&amp; typeof visitorFunc === &#x27;function&#x27;) &#123;        visitorFunc(node);    &#125;    if (defination.visitor) &#123;        defination.visitor.forEach(key =&gt; &#123;            const prop = node[key];            if (Array.isArray(prop)) &#123; // 如果该属性是数组                prop.forEach(childNode =&gt; &#123;                    traverse(childNode, visitors);                &#125;)            &#125; else &#123;                traverse(prop, visitors);            &#125;        &#125;)    &#125;&#125;\n\n我们来试验一下：\ntraverse(ast, &#123;    Identifier(node) &#123;        node.name = &#x27;b&#x27;;    &#125;&#125;);\n\n之后再次查看 AST，发现 Identifier 的 name 已经从 a 变成了 b\n\nbabel 的 visitor 也支持指定 enter、exit 来选择在遍历子节点之前和之后调用，如果传入的是函数，那么就被当做 enter：\nfunction traverse(node, visitors) &#123;    const defination = astDefinationsMap.get(node.type);    let visitorFuncs = visitors[node.type] || &#123;&#125;;    if(typeof visitorFuncs === &#x27;function&#x27;) &#123;        visitorFuncs = &#123;            enter: visitorFuncs        &#125;    &#125;    visitorFuncs.enter &amp;&amp; visitorFuncs.enter(node);    if (defination.visitor) &#123;        defination.visitor.forEach(key =&gt; &#123;            const prop = node[key];            if (Array.isArray(prop)) &#123; // 如果该属性是数组                prop.forEach(childNode =&gt; &#123;                    traverse(childNode, visitors);                &#125;)            &#125; else &#123;                traverse(prop, visitors);            &#125;        &#125;)    &#125;    visitorFuncs.exit &amp;&amp; visitorFuncs.exit(node);&#125;\n\n这样，我们传入的 visitor 也可以这样写：\ntraverse(ast, &#123;    Identifier: &#123;        exit(node) &#123;            node.name = &#x27;b&#x27;;        &#125;    &#125;&#125;);\n\n会在遍历完子节点之后被调用。\npath我们实现的 visitor 是直接传入的 node，但是 AST 中并没有父节点的信息，所以我们要把父节点也传进去。\nbabel 提供了 path 的功能，它是从当前节点到根节点的一条路径，通过 parent 串联。\n\n我们封装一个 NodePath 的类：\nclass NodePath &#123;    constructor(node, parent, parentPath) &#123;        this.node = node;        this.parent = parent;        this.parentPath = parentPath;    &#125;&#125;\n\n调用 visitor 的时候创建 path 对象传入：\nfunction traverse(node, visitors, parent, parentPath) &#123;    const defination = astDefinationsMap.get(node.type);    let visitorFuncs = visitors[node.type] || &#123;&#125;;    if(typeof visitorFuncs === &#x27;function&#x27;) &#123;        visitorFuncs = &#123;            enter: visitorFuncs        &#125;    &#125;    const path = new NodePath(node, parent, parentPath);    visitorFuncs.enter &amp;&amp; visitorFuncs.enter(path);    if (defination.visitor) &#123;        defination.visitor.forEach(key =&gt; &#123;            const prop = node[key];            if (Array.isArray(prop)) &#123; // 如果该属性是数组                prop.forEach(childNode =&gt; &#123;                    traverse(childNode, visitors, node, path);                &#125;)            &#125; else &#123;                traverse(prop, visitors, node, path);            &#125;        &#125;)    &#125;    visitorFuncs.exit &amp;&amp; visitorFuncs.exit(path);&#125;\n\n这样，我们可以在 visitor 中拿到父节点，父节点的父节点，我们来试一下：\ntraverse(ast, &#123;    Identifier: &#123;        exit(path) &#123;            path.node.name = &#x27;b&#x27;;            let curPath = path;            while (curPath) &#123;                console.log(curPath.node.type);                curPath = curPath.parentPath;            &#125;        &#125;    &#125;&#125;);\n\n打印结果如下：\n\n从当前节点到根节点的 AST 都可以获取到。\npath 的 apiparent 可以保存，同理 sibling 也可以，也就是说我们可以通过 path 拿到所有的 AST。但是直接操作 AST 有点麻烦，所以我们要提供一些 api 来简化操作。\n首先我们要把遍历到的 AST 的属性对应的 key 和如果是数组时对应的 listKey 都保存下来。\nclass NodePath &#123;    constructor(node, parent, parentPath, key, listKey) &#123;        this.node = node;        this.parent = parent;        this.parentPath = parentPath;        this.key = key;        this.listKey = listKey;    &#125;&#125;function traverse(node, visitors, parent, parentPath, key, listKey) &#123;    const defination = astDefinationsMap.get(node.type);    let visitorFuncs = visitors[node.type] || &#123;&#125;;    if(typeof visitorFuncs === &#x27;function&#x27;) &#123;        visitorFuncs = &#123;            enter: visitorFuncs        &#125;    &#125;    const path = new NodePath(node, parent, parentPath, key, listKey);    visitorFuncs.enter &amp;&amp; visitorFuncs.enter(path);    if (defination.visitor) &#123;        defination.visitor.forEach(key =&gt; &#123;            const prop = node[key];            if (Array.isArray(prop)) &#123; // 如果该属性是数组                prop.forEach((childNode, index) =&gt; &#123;                    traverse(childNode, visitors, node, path, key, index);                &#125;)            &#125; else &#123;                traverse(prop, visitors, node, path, key);            &#125;        &#125;)    &#125;    visitorFuncs.exit &amp;&amp; visitorFuncs.exit(path);&#125;\n\n然后基于 key 和 listKey 来实现 replaceWith 和 remove 的 api：\nclass NodePath &#123;    constructor(node, parent, parentPath, key, listKey) &#123;        this.node = node;        this.parent = parent;        this.parentPath = parentPath;        this.key = key;        this.listKey = listKey;    &#125;    replaceWith(node) &#123;        if (this.listKey) &#123;            this.parent[this.key].splice(this.listKey, 1, node);        &#125;        this.parent[this.key] = node    &#125;    remove () &#123;        if (this.listKey) &#123;            this.parent[this.key].splice(this.listKey, 1);        &#125;        this.parent[this.key] = null;    &#125;&#125;\n\n试验下效果：\ntraverse(ast, &#123;    NumericLiteral(path) &#123;        path.replaceWith(&#123; type: &#x27;Identifier&#x27;, name: &#x27;bbbbbbb&#x27; &#125;);    &#125;&#125;);\n\n结果为：\n\nNumericLiteral 被替换为了 Identifier。我们成功的实现了 path.replaceWith。\npath.scopepath.scope 是作用域的信息，记录声明的变量的 binding、它们的引用 reference、在哪里被修改 （constantViolations），以及父作用域等。是静态作用域链的实现。\n实现思路：\n首先函数、块、模块都会生成作用域，当处理到这些 AST 时要创建一个 Scope 对象，它有 bindings 属性，每一个声明都会创建一个 binding（比如变量声明语句 VariableDeclaration、函数声明语句 FuncitonDeclaration 以及参数、import 等）\n通过 Identifier 引用这些作用域中的 binding 的时候就会记录 references，如果被修改，则记录修改的语句的 AST 对应的 path，比如赋值语句。\n同样需要提供一系列 api 来简化作用域的分析和操作，比如查找 getBinding、删除 removeBinding、重命名 rename 等。\n篇幅关系，这里就不做实现了，《babel 插件通关秘籍》小册中会有完整的实现。\ntypes在 traverse 的时候我们实现了 path.replaceWith 的 api，用于替换 AST 成新的 AST，我们是直接传入了字面量对象，这种方式比较麻烦。babel 是通过 types 包来提供创建 AST 的能力，我们来分析一下实现思路：\n其实创建 AST 节点也是一个递归的过程，需要保证每一部分都是正确的，我们在遍历的时候保存了 visitor 的 key，在创建的时候仍然是创建这些 key 对应的 AST，不过需要对传入的参数做一下检验。\ndefineType(&quot;BinaryExpression&quot;, &#123;    builder: [&quot;operator&quot;, &quot;left&quot;, &quot;right&quot;],    fields: &#123;      operator: &#123;        validate: assertOneOf(...BINARY_OPERATORS),      &#125;,      left: &#123;        validate: assertNodeType(&quot;Expression&quot;),      &#125;,      right: &#123;        validate: assertNodeType(&quot;Expression&quot;),      &#125;,    &#125;,    visitor: [&quot;left&quot;, &quot;right&quot;],    aliases: [&quot;Binary&quot;, &quot;Expression&quot;],&#125;);\n\nbabel 内部通过 defineType 方法定义 AST 类型的创建逻辑，其中 fileds 属性包含了这个 AST 需要什么属性，每种属性怎么校验。通过校验之后会根据相应的参数创建 AST。\ntemplatebabel template 是通过字符串批量创建 AST，我们可以基于 parser 实现一个简单的 template\nfunction template(code) &#123;    return parse(code);&#125;template.expression = function(code) &#123;    return template(code).body[0].expression;&#125;\n\n上面的代码就可以变成：\ntraverse(ast, &#123;    NumericLiteral(path) &#123;             path.replaceWith(template.expression(&#x27;bbb&#x27;));    &#125;&#125;);\n\ngenerate上面都是对 AST 的增删改，接下来我们来实现下 generate，把 AST 打印成目标代码。\n其实就是一个拼接字符串的过程：\nclass Printer &#123;    constructor () &#123;        this.buf = &#x27;&#x27;;    &#125;    space() &#123;        this.buf += &#x27; &#x27;;    &#125;    nextLine() &#123;        this.buf += &#x27;\\n&#x27;;    &#125;    Program (node) &#123;        node.body.forEach(item =&gt; &#123;            this[item.type](item) + &#x27;;&#x27;;            this.nextLine();        &#125;);    &#125;    VariableDeclaration(node) &#123;        this.buf += node.kind;        this.space();        node.declarations.forEach((declaration, index) =&gt; &#123;            if (index != 0) &#123;                this.buf += &#x27;,&#x27;;            &#125;            this[declaration.type](declaration);        &#125;);        this.buf += &#x27;;&#x27;;    &#125;    VariableDeclarator(node) &#123;        this[node.id.type](node.id);        this.buf += &#x27;=&#x27;;        this[node.init.type](node.init);    &#125;    Identifier(node) &#123;        this.buf += node.name;    &#125;    NumericLiteral(node) &#123;        this.buf += node.value;    &#125;&#125;class Generator extends Printer&#123;    generate(node) &#123;        this[node.type](node);        return this.buf;    &#125;&#125;function generate (node) &#123;    return new Generator().generate(node);&#125;\n\n我们来试验一下：\nconst sourceCode = `const a = 1,b=2,c=3;const d=4,e=5;`;ast = parse(sourceCode);traverse(ast, &#123;    NumericLiteral(path) &#123;        if (path.node.value === 2) &#123;            path.replaceWith(template.expression(&#x27;aaaaa&#x27;));        &#125;    &#125; &#125;)console.log(generate(ast));\n\n打印结果如下：\nconst a=1,b=aaaaa,c=3;const d=4,e=5;\n\n我们成功的实现了 generate 方法。\nsourcemapgenerator 除了打印目标代码外还要生成 sourcemap，这个是转译器很重要的一个功能。\nsourcemap 的实现思路也比较简单：\nparse 之后的 AST 中保留了源码中的位置信息（行列号），在打印成目标代码的时候计算新的行列号，这样有了新旧行列号，就可以用 source-map 包的 api 生成 sourcemap 了。\nvar map = new SourceMapGenerator(&#123;  file: &quot;source-mapped.js&quot;&#125;);map.addMapping(&#123;  generated: &#123;    line: 10,    column: 35  &#125;,  source: &quot;foo.js&quot;,  original: &#123;    line: 33,    column: 2  &#125;,  name: &quot;christopher&quot;&#125;);console.log(map.toString());// &#x27;&#123;&quot;version&quot;:3,&quot;file&quot;:&quot;source-mapped.js&quot;,//   &quot;sources&quot;:[&quot;foo.js&quot;],&quot;names&quot;:[&quot;christopher&quot;],&quot;mappings&quot;:&quot;;;;;;;;;;mCAgCEA&quot;&#125;&#x27;\n\ncore上面我们已经实现了全流程的功能，但是平时我们平时很少使用 api，更多还是使用全流程的包 @babel/core，所以要基于上面的包实现 core 包，然后支持 plugin 和 preset。\nfunction transformSync(code, options) &#123;    const ast = parse(code);    const pluginApi = &#123;        template    &#125;    const visitors = &#123;&#125;;    options.plugins.forEach(([plugin, options]) =&gt; &#123;        const res = plugin(pluginApi, options);        Object.assign(visitors, res.visitor);    &#125;)    traverse(ast, visitors);    return generate(ast);&#125;\n\nplugin 支持传入 options，并且在 plugin 里面可以拿到 api 和 options，返回值是 visitor 函数：\nconst sourceCode = `const a = 1;`;const code = transformSync(sourceCode, &#123;    plugins: [        [            function plugin1(api, options) &#123;                return &#123;                    visitor: &#123;                        Identifier(path) &#123;                                // path.node.value = 2222;                                path.replaceWith(api.template.expression(options.replaceName));                        &#125;                    &#125;                &#125;            &#125;,            &#123;                replaceName: &#x27;ddddd&#x27;            &#125;        ]    ]&#125;);console.log(code);\n\n结果为:\nconst ddddd=1;\n\n至此我们完成了 babel 所有内置功能的简易版本实现。(helper 就是一个放公共函数的包， runtime 是用于运行时引入的 api，这两个包比较简单，就不实现了。在《babel 插件通关秘籍》的小册里面会详细实现）\n总结我们梳理了 babel 的编译流程和内置的包的各自的功能，然后明确了我们要实现的包：parser、traverse、generate、types、template、core。接下来依次做了实现或梳理了实现思路。\nparser 包基于 acorn，babel 是 fork 自 acorn，我们是直接基于 acorn 插件来修改 AST。我们实现了 Literal 的 AST 的扩展。\ntraverse 包负责遍历 AST，我们通过记录 visitor key 实现了 AST 的深度优先遍历，并且在遍历的过程中调用 visitor，而且还支持 enter 和 exit 两个阶段的调用。visitor 传入的参数支持了 path，可以拿到 parent，可以调用 replaceWith 和 remove 等 api。我们还梳理了实现 scope 的思路。\ntypes 和 template 都是用于创建 AST 的，我们梳理了 types 的实现思路，就是递归创建 AST 然后组装，实现了简单的 template，使用直接从字符串 parse 的方式。\ngenerate 包负责把修改以后的 AST 打印成目标代码以及生成 sourcemap，我们实现了代码的打印。梳理了 sourcemap 的思路。\ncore 包是整个编译流程的集成，而且支持 plugins 和 preset，我们实现了 transformSync 的 api，也支持了 plugin 的调用。\n","categories":["babel"],"tags":["babel"]},{"title":"100个JavaScript代码片段总结","url":"/2021/05/14/js/100%E4%B8%AAjs%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%80%BB%E7%BB%93/","content":"实现字符串长度截取function cutstr(str, len) &#123;        var temp;        var icount = 0;        var patrn = /[^\\x00-\\xff]/;        var strre = &quot;&quot;;        for (var i = 0; i &lt; str.length; i++) &#123;            if (icount &lt; len - 1) &#123;                temp = str.substr(i, 1);                if (patrn.exec(temp) == null) &#123;                    icount = icount + 1                &#125; else &#123;                    icount = icount + 2                &#125;                strre += temp            &#125; else &#123;                break            &#125;        &#125;        return strre + &quot;...&quot;    &#125;\n\n获取域名主机function getHost(url) &#123;        var host = &quot;null&quot;;        if(typeof url == &quot;undefined&quot;|| null == url) &#123;            url = window.location.href;        &#125;        var regex = /^\\w+\\:\\/\\/([^\\/]*).*/;        var match = url.match(regex);        if(typeof match != &quot;undefined&quot; &amp;&amp; null != match) &#123;            host = match[1];        &#125;        return host;&#125;\n\n清除空格String.prototype.trim = function() &#123;        var reExtraSpace = /^\\s*(.*?)\\s+$/;        return this.replace(reExtraSpace, &quot;$1&quot;)    &#125;\n\n替换全部String.prototype.replaceAll = function(s1, s2) &#123;    return this.replace(new RegExp(s1, &quot;gm&quot;), s2)&#125;\n\n转义html标签function HtmlEncode(text) &#123;        return text.replace(/&amp;/g, &#x27;&amp;amp&#x27;).replace(/\\&quot;/g, &#x27;&amp;quot;&#x27;).replace(/&lt;/g, &#x27;&amp;lt;&#x27;).replace(/&gt;/g, &#x27;&amp;gt;&#x27;)    &#125;\n\n生JavaScript还原html标签function HtmlDecode(text) &#123;        return text.replace(/&amp;amp;/g, &#x27;&amp;&#x27;).replace(/&amp;quot;/g, &#x27;\\&quot;&#x27;).replace(/&amp;lt;/g, &#x27;&lt;&#x27;).replace(/&amp;gt;/g, &#x27;&gt;&#x27;)    &#125;\n\n时间日期格式转换Date.prototype.Format = function(formatStr) &#123;        var str = formatStr;        var Week = [&#x27;日&#x27;, &#x27;一&#x27;, &#x27;二&#x27;, &#x27;三&#x27;, &#x27;四&#x27;, &#x27;五&#x27;, &#x27;六&#x27;];        str = str.replace(/yyyy|YYYY/, this.getFullYear());        str = str.replace(/yy|YY/, (this.getYear() % 100) &gt; 9 ? (this.getYear() % 100).toString() : &#x27;0&#x27; + (this.getYear() % 100));        str = str.replace(/MM/, (this.getMonth() + 1) &gt; 9 ? (this.getMonth() + 1).toString() : &#x27;0&#x27; + (this.getMonth() + 1));        str = str.replace(/M/g, (this.getMonth() + 1));        str = str.replace(/w|W/g, Week[this.getDay()]);        str = str.replace(/dd|DD/, this.getDate() &gt; 9 ? this.getDate().toString() : &#x27;0&#x27; + this.getDate());        str = str.replace(/d|D/g, this.getDate());        str = str.replace(/hh|HH/, this.getHours() &gt; 9 ? this.getHours().toString() : &#x27;0&#x27; + this.getHours());        str = str.replace(/h|H/g, this.getHours());        str = str.replace(/mm/, this.getMinutes() &gt; 9 ? this.getMinutes().toString() : &#x27;0&#x27; + this.getMinutes());        str = str.replace(/m/g, this.getMinutes());        str = str.replace(/ss|SS/, this.getSeconds() &gt; 9 ? this.getSeconds().toString() : &#x27;0&#x27; + this.getSeconds());        str = str.replace(/s|S/g, this.getSeconds());        return str    &#125;\n\n判断是否为数字类型function isDigit(value) &#123;        var patrn = /^[0-9]*$/;        if (patrn.exec(value) == null || value == &quot;&quot;) &#123;            return false        &#125; else &#123;            return true        &#125;    &#125;\n\n设置cookie值function setCookie(name, value, Hours) &#123;            var d = new Date();        var offset = 8;        var utc = d.getTime() + (d.getTimezoneOffset() * 60000);        var nd = utc + (3600000 * offset);        var exp = new Date(nd);        exp.setTime(exp.getTime() + Hours * 60 * 60 * 1000);        document.cookie = name + &quot;=&quot; + escape(value) + &quot;;path=/;expires=&quot; + exp.toGMTString() + &quot;;domain=360doc.com;&quot;    &#125;\n\n获取cookie值function getCookie(name) &#123;     var arr = document.cookie.match(new RegExp(&quot;(^| )&quot; + name + &quot;=([^;]*)(;|$)&quot;));     if (arr != null) return unescape(arr[2]);     return null &#125;\n\n加入收藏夹function AddFavorite(sURL, sTitle) &#123;        try &#123;            window.external.addFavorite(sURL, sTitle)        &#125; catch(e) &#123;            try &#123;                window.sidebar.addPanel(sTitle, sURL, &quot;&quot;)            &#125; catch(e) &#123;                alert(&quot;加入收藏失败，请使用Ctrl+D进行添加&quot;)            &#125;        &#125;    &#125;\n\n设为首页function setHomepage() &#123;        if (document.all) &#123;            document.body.style.behavior = &#x27;url(#default#homepage)&#x27;;            document.body.setHomePage(&#x27;http://***&#x27;)        &#125; else if (window.sidebar) &#123;            if (window.netscape) &#123;                try &#123;                    netscape.security.PrivilegeManager.enablePrivilege(&quot;UniversalXPConnect&quot;)                &#125; catch(e) &#123;                    alert(&quot;该操作被浏览器拒绝，如果想启用该功能，请在地址栏内输入 about:config,然后将项 signed.applets.codebase_principal_support 值该为true&quot;)                &#125;            &#125;            var prefs = Components.classes[&#x27;@mozilla.org/preferences-service;1&#x27;].getService(Components.interfaces.nsIPrefBranch);            prefs.setCharPref(&#x27;browser.startup.homepage&#x27;, &#x27;http://***&#x27;)        &#125;    &#125;\n\n判断IE6var ua = navigator.userAgent.toLowerCase();    var isIE6 = ua.indexOf(&quot;msie 6&quot;) &gt; -1;    if (isIE6) &#123;        try &#123;            document.execCommand(&quot;BackgroundImageCache&quot;, false, true)        &#125; catch(e) &#123;&#125;    &#125;\n\n加载样式文件function LoadStyle(url) &#123;        try &#123;            document.createStyleSheet(url)        &#125; catch(e) &#123;            var cssLink = document.createElement(&#x27;link&#x27;);            cssLink.rel = &#x27;stylesheet&#x27;;            cssLink.type = &#x27;text/css&#x27;;            cssLink.href = url;            var head = document.getElementsByTagName(&#x27;head&#x27;)[0];            head.appendChild(cssLink)        &#125;    &#125;\n\n返回脚本内容function evalscript(s) &#123;        if(s.indexOf(&#x27;&lt;script&#x27;) == -1) return s;        var p = /&lt;script[^\\&gt;]*?&gt;([^\\x00]*?)&lt;\\/script&gt;/ig;        var arr = [];        while(arr = p.exec(s)) &#123;            var p1 = /&lt;script[^\\&gt;]*?src=\\&quot;([^\\&gt;]*?)\\&quot;[^\\&gt;]*?(reload=\\&quot;1\\&quot;)?(?:charset=\\&quot;([\\w\\-]+?)\\&quot;)?&gt;&lt;\\/script&gt;/i;            var arr1 = [];            arr1 = p1.exec(arr[0]);            if(arr1) &#123;                appendscript(arr1[1], &#x27;&#x27;, arr1[2], arr1[3]);            &#125; else &#123;                p1 = /&lt;script(.*?)&gt;([^\\x00]+?)&lt;\\/script&gt;/i;                arr1 = p1.exec(arr[0]);                appendscript(&#x27;&#x27;, arr1[2], arr1[1].indexOf(&#x27;reload=&#x27;) != -1);            &#125;        &#125;        return s;    &#125;\n\n清除脚本内容function stripscript(s) &#123;    return s.replace(/&lt;script.*?&gt;.*?&lt;\\/script&gt;/ig, &#x27;&#x27;); &#125;\n\n动态加载脚本文件function appendscript(src, text, reload, charset) &#123;        var id = hash(src + text);        if(!reload &amp;&amp; in_array(id, evalscripts)) return;        if(reload &amp;&amp; $(id)) &#123;            $(id).parentNode.removeChild($(id));        &#125;             evalscripts.push(id);        var scriptNode = document.createElement(&quot;script&quot;);        scriptNode.type = &quot;text/javascript&quot;;        scriptNode.id = id;        scriptNode.charset = charset ? charset : (BROWSER.firefox ? document.characterSet : document.charset);        try &#123;            if(src) &#123;                scriptNode.src = src;                scriptNode.onloadDone = false;                scriptNode.onload = function () &#123;                    scriptNode.onloadDone = true;                    JSLOADED[src] = 1;                &#125;;                scriptNode.onreadystatechange = function () &#123;                    if((scriptNode.readyState == &#x27;loaded&#x27; || scriptNode.readyState == &#x27;complete&#x27;) &amp;&amp; !scriptNode.onloadDone) &#123;                        scriptNode.onloadDone = true;                        JSLOADED[src] = 1;                    &#125;                &#125;;            &#125; else if(text)&#123;                scriptNode.text = text;            &#125;            document.getElementsByTagName(&#x27;head&#x27;)[0].appendChild(scriptNode);        &#125; catch(e) &#123;&#125;    &#125;\n\n返回按ID检索的元素对象function $(id) &#123;        return !id ? null : document.getElementById(id);    &#125;\n\n返回浏览器版本内容function browserVersion(types) &#123;        var other = 1;        for(i in types) &#123;            var v = types[i] ? types[i] : i;            if(USERAGENT.indexOf(v) != -1) &#123;                var re = new RegExp(v + &#x27;(\\\\/|\\\\s)([\\\\d\\\\.]+)&#x27;, &#x27;ig&#x27;);                var matches = re.exec(USERAGENT);                var ver = matches != null ? matches[2] : 0;                other = ver !== 0 &amp;&amp; v != &#x27;mozilla&#x27; ? 0 : other;            &#125;else &#123;                var ver = 0;            &#125;            eval(&#x27;BROWSER.&#x27; + i + &#x27;= ver&#x27;);        &#125;        BROWSER.other = other;    &#125;\n\n元素显示的通用方法function $(id) &#123;        return !id ? null : document.getElementById(id);    &#125;    function display(id) &#123;        var obj = $(id);        if(obj.style.visibility) &#123;            obj.style.visibility = obj.style.visibility == &#x27;visible&#x27; ? &#x27;hidden&#x27; : &#x27;visible&#x27;;        &#125; else &#123;            obj.style.display = obj.style.display == &#x27;&#x27; ? &#x27;none&#x27; : &#x27;&#x27;;        &#125;    &#125;\n\n中有insertBefore方法,可惜却没有insertAfter方法?用如下函数实现function insertAfter(newChild,refChild)&#123;     var parElem=refChild.parentNode;     if(parElem.lastChild==refChild)&#123;         refChild.appendChild(newChild);     &#125;else&#123;         parElem.insertBefore(newChild,refChild.nextSibling);     &#125; &#125;\n\n中兼容浏览器绑定元素事件function addEventSamp(obj,evt,fn)&#123;     if (obj.addEventListener) &#123;         obj.addEventListener(evt, fn, false);     &#125;else if(obj.attachEvent)&#123;         obj.attachEvent(&#x27;on&#x27;+evt,fn);     &#125; &#125;\n\n光标停在文字的后面，文本框获得焦点时调用function focusLast()&#123;     var e = event.srcElement;     var r =e.createTextRange();     r.moveStart(&#x27;character&#x27;,e.value.length);     r.collapse(true);     r.select(); &#125;\n\n检验URL链接是否有效function getUrlState(URL)&#123;     var xmlhttp = new ActiveXObject(&quot;microsoft.xmlhttp&quot;);     xmlhttp.Open(&quot;GET&quot;,URL, false);      try&#123;          xmlhttp.Send();     &#125;catch(e)&#123;    &#125;finally&#123;         var result = xmlhttp.responseText;         if(result)&#123;             if(xmlhttp.Status==200)&#123;                 return(true);             &#125;else&#123;                 return(false);             &#125;         &#125;else&#123;             return(false);         &#125;     &#125; &#125;\n\n格式化CSS样式代码function formatCss(s)&#123;//格式化代码    s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, &quot;$1&quot;);    s = s.replace(/;\\s*;/g, &quot;;&quot;); //清除连续分号    s = s.replace(/\\,[\\s\\.\\#\\d]*&#123;/g, &quot;&#123;&quot;);    s = s.replace(/([^\\s])\\&#123;([^\\s])/g, &quot;$1 &#123;\\n\\t$2&quot;);    s = s.replace(/([^\\s])\\&#125;([^\\n]*)/g, &quot;$1\\n&#125;\\n$2&quot;);    s = s.replace(/([^\\s]);([^\\s\\&#125;])/g, &quot;$1;\\n\\t$2&quot;);    return s;&#125;\n\n压缩CSS样式代码function yasuoCss (s) &#123;//压缩代码    s = s.replace(/\\/\\*(.|\\n)*?\\*\\//g, &quot;&quot;); //删除注释    s = s.replace(/\\s*([\\&#123;\\&#125;\\:\\;\\,])\\s*/g, &quot;$1&quot;);    s = s.replace(/\\,[\\s\\.\\#\\d]*\\&#123;/g, &quot;&#123;&quot;); //容错处理    s = s.replace(/;\\s*;/g, &quot;;&quot;); //清除连续分号    s = s.match(/^\\s*(\\S+(\\s+\\S+)*)\\s*$/); //去掉首尾空白    return (s == null) ? &quot;&quot; : s[1];&#125;\n\n获取当前路径var currentPageUrl = &quot;&quot;;if (typeof this.href === &quot;undefined&quot;) &#123;    currentPageUrl = document.location.toString().toLowerCase();&#125;else &#123;    currentPageUrl = this.href.toString().toLowerCase();&#125;\n\nIP转成整型function _ip2int(ip)&#123;    var num = 0;    ip = ip.split(&quot;.&quot;);    num = Number(ip[0]) * 256 * 256 * 256 + Number(ip[1]) * 256 * 256 + Number(ip[2]) * 256 + Number(ip[3]);    num = num &gt;&gt;&gt; 0;    return num;&#125;\n\n整型解析为IP地址function _int2iP(num)&#123;    var str;    var tt = new Array();    tt[0] = (num &gt;&gt;&gt; 24) &gt;&gt;&gt; 0;    tt[1] = ((num &lt;&lt; 8) &gt;&gt;&gt; 24) &gt;&gt;&gt; 0;    tt[2] = (num &lt;&lt; 16) &gt;&gt;&gt; 24;    tt[3] = (num &lt;&lt; 24) &gt;&gt;&gt; 24;    str = String(tt[0]) + &quot;.&quot; + String(tt[1]) + &quot;.&quot; + String(tt[2]) + &quot;.&quot; + String(tt[3]);    return str;&#125;\n\n实现checkbox全选与全不选function checkAll() &#123;    var selectall = document.getElementById(&quot;selectall&quot;);    var allbox = document.getElementsByName(&quot;allbox&quot;);    if (selectall.checked) &#123;        for (var i = 0; i &lt; allbox.length; i++) &#123;            allbox[i].checked = true;        &#125;    &#125; else &#123;        for (var i = 0; i &lt; allbox.length; i++) &#123;            allbox[i].checked = false;        &#125;    &#125;&#125;\n\n判断是否移动设备function isMobile()&#123;    if (typeof this._isMobile === &#x27;boolean&#x27;)&#123;        return this._isMobile;    &#125;    var screenWidth = this.getScreenWidth();    var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport;    var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === &quot;new&quot;);    if(!fixViewPortsExperiment)&#123;        if(!this.isAppleMobileDevice())&#123;            screenWidth = screenWidth/window.devicePixelRatio;        &#125;    &#125;    var isMobileScreenSize = screenWidth &lt; 600;    var isMobileUserAgent = false;    this._isMobile = isMobileScreenSize &amp;&amp; this.isTouchScreen();    return this._isMobile;&#125;\n\n判断是否移动设备访问function isMobileUserAgent()&#123;    return (/iphone|ipod|android.*mobile|windows.*phone|blackberry.*mobile/i.test(window.navigator.userAgent.toLowerCase()));&#125;\n\n判断是否苹果移动设备访问1 function isAppleMobileDevice()&#123;2     return (/iphone|ipod|ipad|Macintosh/i.test(navigator.userAgent.toLowerCase()));3 &#125;\n\n判断是否安卓移动设备访问1 function isAndroidMobileDevice()&#123;2     return (/android/i.test(navigator.userAgent.toLowerCase()));3 &#125;\n\n判断是否Touch屏幕1 function isTouchScreen()&#123;2     return ((&#x27;ontouchstart&#x27; in window) || window.DocumentTouch &amp;&amp; document instanceof DocumentTouch);3 &#125;\n\n判断是否在安卓上的谷歌浏览器function isNewChromeOnAndroid()&#123;    if(this.isAndroidMobileDevice())&#123;        var userAgent = navigator.userAgent.toLowerCase();        if((/chrome/i.test(userAgent)))&#123;            var parts = userAgent.split(&#x27;chrome/&#x27;);            var fullVersionString = parts[1].split(&quot; &quot;)[0];            var versionString = fullVersionString.split(&#x27;.&#x27;)[0];            var version = parseInt(versionString);            if(version &gt;= 27)&#123;                return true;            &#125;        &#125;    &#125;    return false;&#125;\n\n判断是否打开视窗1 function isViewportOpen() &#123;2     return !!document.getElementById(&#x27;wixMobileViewport&#x27;);3 &#125;\n\n获取移动设备初始化大小function getInitZoom()&#123;    if(!this._initZoom)&#123;        var screenWidth = Math.min(screen.height, screen.width);        if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;            screenWidth = screenWidth/window.devicePixelRatio;        &#125;        this._initZoom = screenWidth /document.body.offsetWidth;    &#125;    return this._initZoom;&#125;\n\n获取移动设备最大化大小function getZoom()&#123;    var screenWidth = (Math.abs(window.orientation) === 90) ? Math.max(screen.height, screen.width) : Math.min(screen.height, screen.width);    if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;        screenWidth = screenWidth/window.devicePixelRatio;    &#125;    var FixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport;    var FixViewPortsExperimentRunning = FixViewPortsExperiment &amp;&amp; (FixViewPortsExperiment === &quot;New&quot; || FixViewPortsExperiment === &quot;new&quot;);    if(FixViewPortsExperimentRunning)&#123;        return screenWidth / window.innerWidth;    &#125;else&#123;        return screenWidth / document.body.offsetWidth;    &#125;&#125;\n\n获取移动设备屏幕宽度function getScreenWidth()&#123;    var smallerSide = Math.min(screen.width, screen.height);    var fixViewPortsExperiment = rendererModel.runningExperiments.FixViewport || rendererModel.runningExperiments.fixviewport;    var fixViewPortsExperimentRunning = fixViewPortsExperiment &amp;&amp; (fixViewPortsExperiment.toLowerCase() === &quot;new&quot;);    if(fixViewPortsExperiment)&#123;        if(this.isAndroidMobileDevice() &amp;&amp; !this.isNewChromeOnAndroid())&#123;            smallerSide = smallerSide/window.devicePixelRatio;        &#125;    &#125;    return smallerSide;&#125;\n\n完美判断是否为网址function IsURL(strUrl) &#123;    var regular = /^\\b(((https?|ftp):\\/\\/)?[-a-z0-9]+(\\.[-a-z0-9]+)*\\.(?:com|edu|gov|int|mil|net|org|biz|info|name|museum|asia|coop|aero|[a-z][a-z]|((25[0-5])|(2[0-4]\\d)|(1\\d\\d)|([1-9]\\d)|\\d))\\b(\\/[-a-z0-9_:\\@&amp;?=+,.!\\/~%\\$]*)?)$/i    if (regular.test(strUrl)) &#123;        return true;    &#125;    else &#123;        return false;    &#125;&#125;\n\n根据样式名称检索元素对象function getElementsByClassName(name) &#123;    var tags = document.getElementsByTagName(&#x27;*&#x27;) || document.all;    var els = [];    for (var i = 0; i &lt; tags.length; i++) &#123;        if (tags[i].className) &#123;            var cs = tags[i].className.split(&#x27; &#x27;);            for (var j = 0; j &lt; cs.length; j++) &#123;                if (name == cs[j]) &#123;                    els.push(tags[i]);                    break                &#125;            &#125;        &#125;    &#125;    return els&#125;\n\n判断是否以某个字符串开头1 String.prototype.startWith = function (s) &#123;2     return this.indexOf(s) == 03 &#125;\n\n判断是否以某个字符串结束1 String.prototype.endWith = function (s) &#123;2     var d = this.length - s.length;3     return (d &gt;= 0 &amp;&amp; this.lastIndexOf(s) == d)4 &#125;\n\n返回IE浏览器的版本号function getIE()&#123;    if (window.ActiveXObject)&#123;        var v = navigator.userAgent.match(/MSIE ([^;]+)/)[1];        return parseFloat(v.substring(0, v.indexOf(&quot;.&quot;)))    &#125;    return false&#125;\n\n获取页面高度function getPageHeight()&#123;    var g = document, a = g.body, f = g.documentElement, d = g.compatMode == &quot;BackCompat&quot;            ? a            : g.documentElement;    return Math.max(f.scrollHeight, a.scrollHeight, d.clientHeight);&#125;\n\n获取页面scrollLeft1 function getPageScrollLeft()&#123;2     var a = document;3     return a.documentElement.scrollLeft || a.body.scrollLeft;4 &#125;\n\n获取页面可视宽度function getPageViewWidth()&#123;    var d = document, a = d.compatMode == &quot;BackCompat&quot;            ? d.body            : d.documentElement;    return a.clientWidth;&#125;\n\n获取页面宽度\n\n\nfunction getPageWidth()&#123;    var g = document, a = g.body, f = g.documentElement, d = g.compatMode == &quot;BackCompat&quot;            ? a            : g.documentElement;    return Math.max(f.scrollWidth, a.scrollWidth, d.clientWidth);&#125;\n\n获取页面scrollTop1 function getPageScrollTop()&#123;2     var a = document;3     return a.documentElement.scrollTop || a.body.scrollTop;4 &#125;\n\n获取页面可视高度function getPageViewHeight() &#123;    var d = document, a = d.compatMode == &quot;BackCompat&quot;            ? d.body            : d.documentElement;    return a.clientHeight;&#125;\n\n跨浏览器添加事件function addEvt(oTarget,sEvtType,fnHandle)&#123;    if(!oTarget)&#123;return;&#125;    if(oTarget.addEventListener)&#123;        oTarget.addEventListener(sEvtType,fnHandle,false);    &#125;else if(oTarget.attachEvent)&#123;        oTarget.attachEvent(&quot;on&quot; + sEvtType,fnHandle);    &#125;else&#123;        oTarget[&quot;on&quot; + sEvtType] = fnHandle;    &#125;&#125;\n\n跨浏览器删除事件\n\n\nfunction delEvt(oTarget,sEvtType,fnHandle)&#123;    if(!oTarget)&#123;return;&#125;    if(oTarget.addEventListener)&#123;        oTarget.addEventListener(sEvtType,fnHandle,false);    &#125;else if(oTarget.attachEvent)&#123;        oTarget.attachEvent(&quot;on&quot; + sEvtType,fnHandle);    &#125;else&#123;        oTarget[&quot;on&quot; + sEvtType] = fnHandle;    &#125;&#125;\n\n去掉url前缀function removeUrlPrefix(a)&#123;  a=a.replace(/：/g,&quot;:&quot;).replace(/．/g,&quot;.&quot;).replace(/／/g,&quot;/&quot;);  while(trim(a).toLowerCase().indexOf(&quot;http://&quot;)==0)&#123;    a=trim(a.replace(/http:\\/\\//i,&quot;&quot;));  &#125;  return a;&#125;\n\n随机数时间戳1 function uniqueId()&#123;2     var a=Math.random,b=parseInt;3     return Number(new Date()).toString()+b(10*a())+b(10*a())+b(10*a());4 &#125;\n\n全角半角转换,iCase: 0全到半，1半到全，其他不转化function chgCase(sStr,iCase)&#123;    if(typeof sStr != &quot;string&quot; || sStr.length &lt;= 0 || !(iCase === 0 || iCase == 1))&#123;        return sStr;    &#125;    var i,oRs=[],iCode;    if(iCase)&#123;/*半-&gt;全*/        for(i=0; i&lt;sStr.length;i+=1)&#123;             iCode = sStr.charCodeAt(i);            if(iCode == 32)&#123;                iCode = 12288;                            &#125;else if(iCode &lt; 127)&#123;                iCode += 65248;            &#125;            oRs.push(String.fromCharCode(iCode));         &#125;            &#125;else&#123;/*全-&gt;半*/        for(i=0; i&lt;sStr.length;i+=1)&#123;             iCode = sStr.charCodeAt(i);            if(iCode == 12288)&#123;                iCode = 32;            &#125;else if(iCode &gt; 65280 &amp;&amp; iCode &lt; 65375)&#123;                iCode -= 65248;                            &#125;            oRs.push(String.fromCharCode(iCode));         &#125;            &#125;            return oRs.join(&quot;&quot;);        &#125;\n\n确认是否键盘有效输入值function checkKey(iKey)&#123;    if(iKey == 32 || iKey == 229)&#123;return true;&#125;/*空格和异常*/    if(iKey&gt;47 &amp;&amp; iKey &lt; 58)&#123;return true;&#125;/*数字*/    if(iKey&gt;64 &amp;&amp; iKey &lt; 91)&#123;return true;&#125;/*字母*/    if(iKey&gt;95 &amp;&amp; iKey &lt; 108)&#123;return true;&#125;/*数字键盘1*/    if(iKey&gt;108 &amp;&amp; iKey &lt; 112)&#123;return true;&#125;/*数字键盘2*/    if(iKey&gt;185 &amp;&amp; iKey &lt; 193)&#123;return true;&#125;/*符号1*/    if(iKey&gt;218 &amp;&amp; iKey &lt; 223)&#123;return true;&#125;/*符号2*/    return false;&#125;\n\n获取网页被卷去的位置function getScrollXY() &#123;    return document.body.scrollTop ? &#123;        x: document.body.scrollLeft,        y: document.body.scrollTop    &#125;: &#123;        x: document.documentElement.scrollLeft,        y: document.documentElement.scrollTop    &#125;&#125;\n\n另一种正则日期格式化函数+调用方法Date.prototype.format = function(format)&#123; //author: meizz  var o = &#123;    &quot;M+&quot; : this.getMonth()+1, //month    &quot;d+&quot; : this.getDate(),    //day    &quot;h+&quot; : this.getHours(),   //hour    &quot;m+&quot; : this.getMinutes(), //minute    &quot;s+&quot; : this.getSeconds(), //second    &quot;q+&quot; : Math.floor((this.getMonth()+3)/3),  //quarter    &quot;S&quot; : this.getMilliseconds() //millisecond  &#125;  if(/(y+)/.test(format)) format=format.replace(RegExp.$1,    (this.getFullYear()+&quot;&quot;).substr(4 - RegExp.$1.length));  for(var k in o)if(new RegExp(&quot;(&quot;+ k +&quot;)&quot;).test(format))    format = format.replace(RegExp.$1,      RegExp.$1.length==1 ? o[k] :        (&quot;00&quot;+ o[k]).substr((&quot;&quot;+ o[k]).length));  return format;&#125;alert(new Date().format(&quot;yyyy-MM-dd hh:mm:ss&quot;));\n\n时间个性化输出功能/*1、&lt; 60s, 显示为“刚刚”2、&gt;= 1min &amp;&amp; &lt; 60 min, 显示与当前时间差“XX分钟前”3、&gt;= 60min &amp;&amp; &lt; 1day, 显示与当前时间差“今天 XX:XX”4、&gt;= 1day &amp;&amp; &lt; 1year, 显示日期“XX月XX日 XX:XX”5、&gt;= 1year, 显示具体日期“XXXX年XX月XX日 XX:XX” */function timeFormat(time)&#123;  var date = new Date(time)    , curDate = new Date()    , year = date.getFullYear()    , month = date.getMonth() + 1    , day = date.getDate()    , hour = date.getHours()    , minute = date.getMinutes()    , curYear = curDate.getFullYear()    , curHour = curDate.getHours()    , timeStr;  if(year &lt; curYear)&#123;    timeStr = year +&#x27;年&#x27;+ month +&#x27;月&#x27;+ day +&#x27;日 &#x27;+ hour +&#x27;:&#x27;+ minute;  &#125;else&#123;    var pastTime = curDate - date      , pastH = pastTime/3600000;    if(pastH &gt; curHour)&#123;      timeStr = month +&#x27;月&#x27;+ day +&#x27;日 &#x27;+ hour +&#x27;:&#x27;+ minute;    &#125;else if(pastH &gt;= 1)&#123;      timeStr = &#x27;今天 &#x27; + hour +&#x27;:&#x27;+ minute +&#x27;分&#x27;;    &#125;else&#123;      var pastM = curDate.getMinutes() - minute;      if(pastM &gt; 1)&#123;        timeStr = pastM +&#x27;分钟前&#x27;;      &#125;else&#123;        timeStr = &#x27;刚刚&#x27;;      &#125;    &#125;  &#125;  return timeStr;&#125;\n\n解决offsetX兼容性问题// 针对火狐不支持offsetX/Yfunction getOffset(e)&#123;  var target = e.target, // 当前触发的目标对象      eventCoord,      pageCoord,      offsetCoord;  // 计算当前触发元素到文档的距离  pageCoord = getPageCoord(target);  // 计算光标到文档的距离  eventCoord = &#123;    X : window.pageXOffset + e.clientX,    Y : window.pageYOffset + e.clientY  &#125;;  // 相减获取光标到第一个定位的父元素的坐标  offsetCoord = &#123;    X : eventCoord.X - pageCoord.X,    Y : eventCoord.Y - pageCoord.Y  &#125;;  return offsetCoord;&#125;function getPageCoord(element)&#123;  var coord = &#123; X : 0, Y : 0 &#125;;  // 计算从当前触发元素到根节点为止，  // 各级 offsetParent 元素的 offsetLeft 或 offsetTop 值之和  while (element)&#123;    coord.X += element.offsetLeft;    coord.Y += element.offsetTop;    element = element.offsetParent;  &#125;  return coord;&#125;\n\n常用的正则表达式//正整数/^[0-9]*[1-9][0-9]*$/;//负整数/^-[0-9]*[1-9][0-9]*$/;//正浮点数/^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$/;   //负浮点数/^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$/;  //浮点数/^(-?\\d+)(\\.\\d+)?$/;//email地址/^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$/;//url地址/^[a-zA-z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$/;//年/月/日（年-月-日、年.月.日）/^(19|20)\\d\\d[- /.](0[1-9]|1[012])[- /.](0[1-9]|[12][0-9]|3[01])$/;//匹配中文字符/[\\u4e00-\\u9fa5]/;//匹配帐号是否合法(字母开头，允许5-10字节，允许字母数字下划线)/^[a-zA-Z][a-zA-Z0-9_]&#123;4,9&#125;$/;//匹配空白行的正则表达式/\\n\\s*\\r/;//匹配中国邮政编码/[1-9]\\d&#123;5&#125;(?!\\d)/;//匹配身份证/\\d&#123;15&#125;|\\d&#123;18&#125;/;//匹配国内电话号码/(\\d&#123;3&#125;-|\\d&#123;4&#125;-)?(\\d&#123;8&#125;|\\d&#123;7&#125;)?/;//匹配IP地址/((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.)&#123;3&#125;(2[0-4]\\d|25[0-5]|[01]?\\d\\d?)/;//匹配首尾空白字符的正则表达式/^\\s*|\\s*$/;//匹配HTML标记的正则表达式&lt; (\\S*?)[^&gt;]*&gt;.*?|&lt; .*? /&gt;;\n\n实现返回顶部的通用方法function backTop(btnId) &#123;    var btn = document.getElementById(btnId);    var d = document.documentElement;    var b = document.body;    window.onscroll = set;    btn.style.display = &quot;none&quot;;    btn.onclick = function() &#123;        btn.style.display = &quot;none&quot;;        window.onscroll = null;        this.timer = setInterval(function() &#123;            d.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1);            b.scrollTop -= Math.ceil((d.scrollTop + b.scrollTop) * 0.1);            if ((d.scrollTop + b.scrollTop) == 0) clearInterval(btn.timer, window.onscroll = set);        &#125;,        10);    &#125;;    function set() &#123;        btn.style.display = (d.scrollTop + b.scrollTop &gt; 100) ? &#x27;block&#x27;: &quot;none&quot;    &#125;&#125;;backTop(&#x27;goTop&#x27;);\n\n获得URL中GET参数值// 用法：如果地址是 test.htm?t1=1&amp;t2=2&amp;t3=3, 那么能取得：GET[&quot;t1&quot;], GET[&quot;t2&quot;], GET[&quot;t3&quot;]function get_get()&#123;   querystr = window.location.href.split(&quot;?&quot;)  if(querystr[1])&#123;    GETs = querystr[1].split(&quot;&amp;&quot;)    GET =new Array()    for(i=0;i&lt;GETs.length;i++)&#123;      tmp_arr = GETs[i].split(&quot;=&quot;)      key=tmp_arr[0]      GET[key] = tmp_arr[1]    &#125;  &#125;  return querystr[1];&#125;\n\n实现全选通用方法function checkall(form, prefix, checkall) &#123;    var checkall = checkall ? checkall : &#x27;chkall&#x27;;    for(var i = 0; i &lt; form.elements.length; i++) &#123;        var e = form.elements[i];        if(e.type==&quot;checkbox&quot;)&#123;            e.checked = form.elements[checkall].checked;        &#125;    &#125;&#125;\n\n实现全部取消选择通用方法function uncheckAll(form) &#123;    for (var i=0;i&lt;form.elements.length;i++)&#123;        var e = form.elements[i];        if (e.name != &#x27;chkall&#x27;)        e.checked=!e.checked;    &#125;&#125;\n\n实现打开一个窗体通用方法function openWindow(url,windowName,width,height)&#123;    var x = parseInt(screen.width / 2.0) - (width / 2.0);     var y = parseInt(screen.height / 2.0) - (height / 2.0);    var isMSIE= (navigator.appName == &quot;Microsoft Internet Explorer&quot;);    if (isMSIE) &#123;        var p = &quot;resizable=1,location=no,scrollbars=no,width=&quot;;        p = p+width;        p = p+&quot;,height=&quot;;        p = p+height;        p = p+&quot;,left=&quot;;        p = p+x;        p = p+&quot;,top=&quot;;        p = p+y;        retval = window.open(url, windowName, p);    &#125; else &#123;        var win = window.open(url, &quot;ZyiisPopup&quot;, &quot;top=&quot; + y + &quot;,left=&quot; + x + &quot;,scrollbars=&quot; + scrollbars + &quot;,dialog=yes,modal=yes,width=&quot; + width + &quot;,height=&quot; + height + &quot;,resizable=no&quot; );        eval(&quot;try &#123; win.resizeTo(width, height); &#125; catch(e) &#123; &#125;&quot;);        win.focus();    &#125;&#125;\n\n判断是否为客户端设备function client(o)&#123;           var b = navigator.userAgent.toLowerCase();          var t = false;       if (o == &#x27;isOP&#x27;)&#123;             t = b.indexOf(&#x27;opera&#x27;) &gt; -1;       &#125;       if (o == &#x27;isIE&#x27;)&#123;             t = b.indexOf(&#x27;msie&#x27;) &gt; -1;       &#125;       if (o == &#x27;isFF&#x27;)&#123;             t = b.indexOf(&#x27;firefox&#x27;) &gt; -1;       &#125;       return t;&#125;\n\n获取单选按钮的值function get_radio_value(field)&#123;    if(field&amp;&amp;field.length)&#123;            for(var i=0;i&lt;field.length;i++)&#123;                    if(field[i].checked)&#123;                            return field[i].value;                                            &#125;                    &#125;            &#125;else &#123;                return ;                    &#125;    &#125;\n\n获取复选框的值function get_checkbox_value(field)&#123;        if(field&amp;&amp;field.length)&#123;            for(var i=0;i&lt;field.length;i++)&#123;                        if(field[i].checked &amp;&amp; !field[i].disabled)&#123;                return field[i].value;            &#125;        &#125;            &#125;else &#123;        return;    &#125;            &#125;\n\n判断是否为邮箱function isEmail(str)&#123;    var re=/^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z0-9]+$/;     if (re.test(str) != true) &#123;        return false;    &#125;else&#123;        return true;    &#125;    &#125;\n\n判断是否有列表中的危险字符function isValidReg(chars)&#123;    var re=/&lt;|&gt;|\\[|\\]|\\&#123;|\\&#125;|『|』|※|○|●|◎|§|△|▲|☆|★|◇|◆|□|▼|㊣|﹋|⊕|⊙|〒|ㄅ|ㄆ|ㄇ|ㄈ|ㄉ|ㄊ|ㄋ|ㄌ|ㄍ|ㄎ|ㄏ|ㄐ|ㄑ|ㄒ|ㄓ|ㄔ|ㄕ|ㄖ|ㄗ|ㄘ|ㄙ|ㄚ|ㄛ|ㄜ|ㄝ|ㄞ|ㄟ|ㄢ|ㄣ|ㄤ|ㄥ|ㄦ|ㄧ|ㄨ|ㄩ|■|▄|▆|\\*|@|#|\\^|\\\\/;    if (re.test( chars) == true) &#123;        return false;    &#125;else&#123;        return true;    &#125;    &#125;\n\n判断字符串是否大于规定的长度function isValidLength(chars, len) &#123;    if (chars.length &lt; len) &#123;        return false;    &#125;    return true;&#125;\n\n判断字符串是为网址不区分大小写function isValidURL( chars ) &#123;    var re=/^([hH][tT]&#123;2&#125;[pP]:\\/\\/|[hH][tT]&#123;2&#125;[pP][sS]:\\/\\/)(\\S+\\.\\S+)$/;    if (!isNULL(chars)) &#123;        chars = jsTrim(chars);        if (chars.match(re) == null)            return false;        else            return true;    &#125;    return false;&#125;\n\n判断字符串是否为小数function isValidDecimal( chars ) &#123;    var re=/^\\d*\\.?\\d&#123;1,2&#125;$/;    if (chars.match(re) == null)        return false;    else        return true;&#125;\n\n判断字符串是否为整数function isNumber( chars ) &#123;    var re=/^\\d*$/;    if (chars.match(re) == null)        return false;    else        return true;&#125;\n\n判断字符串是否为浮点数function isFloat( str ) &#123;    for(i=0;i&lt;str.length;i++)  &#123;       if ((str.charAt(i)&lt;&quot;0&quot; || str.charAt(i)&gt;&quot;9&quot;)&amp;&amp; str.charAt(i) != &#x27;.&#x27;)&#123;            return false;       &#125;    &#125;    return true;&#125;\n\n判断字符是否为A-Za-z英文字母function isLetters( str )&#123;    var re=/^[A-Za-z]+$/;    if (str.match(re) == null)        return false;    else        return true;&#125;\n\n判断字符串是否邮政编码function isValidPost( chars ) &#123;    var re=/^\\d&#123;6&#125;$/;    if (chars.match(re) == null)        return false;    else        return true;&#125;\n\n判断字符是否空NULLfunction isNULL( chars ) &#123;    if (chars == null)        return true;    if (jsTrim(chars).length==0)        return true;    return false;&#125;\n\n用正则表达式提取页面代码中所有网址1 var aa = document.documentElement.outerHTML.match(/(url\\(|src=|href=)[\\&quot;\\&#x27;]*([^\\&quot;\\&#x27;\\(\\)\\&lt;\\&gt;\\[\\] ]+)[\\&quot;\\&#x27;\\)]*|(http:\\/\\/[\\w\\-\\.]+[^\\&quot;\\&#x27;\\(\\)\\&lt;\\&gt;\\[\\] ]+)/ig).join(&quot;\\r\\n&quot;).replace(/^(src=|href=|url\\()[\\&quot;\\&#x27;]*|[\\&quot;\\&#x27;\\&gt;\\) ]*$/igm,&quot;&quot;);2 alert(aa)\n\n用正则表达式清除相同的数组(低效率)1 Array.prototype.unique=function()&#123;2     return this.reverse().join(&quot;,&quot;).match(/([^,]+)(?!.*\\1)/ig).reverse();3 &#125;\n\n用正则表达式清除相同的数组(高效率)String.prototype.unique=function()&#123;    var x=this.split(/[\\r\\n]+/);    var y=&#x27;&#x27;;    for(var i=0;i&lt;x.length;i++)&#123;        if(!new RegExp(&quot;^&quot;+x[i].replace(/([^\\w])/ig,&quot;\\\\$1&quot;)+&quot;$&quot;,&quot;igm&quot;).test(y))&#123;            y+=x[i]+&quot;\\r\\n&quot;        &#125;    &#125;    return y&#125;\n\n用正则表达式按字母排序，对每行进行数组排序1 function SetSort()&#123;2     var text=K1.value.split(/[\\r\\n]/).sort().join(&quot;\\r\\n&quot;);//顺序3     var test=K1.value.split(/[\\r\\n]/).sort().reverse().join(&quot;\\r\\n&quot;);//反序4     K1.value=K1.value!=text?text:test;5 &#125;\n\n字符串反序1 function IsReverse(text)&#123;2     return text.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;);3 &#125;\n\n用正则表达式清除html代码中的脚本1 function clear_script()&#123;2   K1.value=K1.value.replace(/&lt;script.*?&gt;[\\s\\S]*?&lt;\\/script&gt;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?&quot;[\\s\\S]*?&quot;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=\\s?&#x27;[\\s\\S]*?&#x27;|\\s+on[a-zA-Z]&#123;3,16&#125;\\s?=[^ &gt;]+/ig,&quot;&quot;);3 &#125;\n\n动态执行JavaScript脚本function javascript()&#123;    try&#123;      eval(K1.value);    &#125;catch(e)&#123;        alert(e.message);    &#125;&#125;\n\n动态执行VBScript脚本function vbscript()&#123;    try&#123;        var script=document.getElementById(&quot;K1&quot;).value;        if(script.trim()==&quot;&quot;)return;        window.execScript(&#x27;On Error Resume Next \\n&#x27;+script+&#x27;\\n If Err.Number&lt;&gt;0 Then \\n MsgBox &quot;请输入正确的VBScript脚本!&quot;,48,&quot;脚本错误!&quot; \\n End If&#x27;,&quot;vbscript&quot;)    &#125;catch(e)&#123;        alert(e.message);    &#125;&#125;\n\n实现金额大写转换函数function transform(tranvalue) &#123;  try &#123;    var i = 1;    var dw2 = new Array(&quot;&quot;, &quot;万&quot;, &quot;亿&quot;); //大单位    var dw1 = new Array(&quot;拾&quot;, &quot;佰&quot;, &quot;仟&quot;); //小单位    var dw = new Array(&quot;零&quot;, &quot;壹&quot;, &quot;贰&quot;, &quot;叁&quot;, &quot;肆&quot;, &quot;伍&quot;, &quot;陆&quot;, &quot;柒&quot;, &quot;捌&quot;, &quot;玖&quot;); //整数部分用    //以下是小写转换成大写显示在合计大写的文本框中         //分离整数与小数    var source = splits(tranvalue);    var num = source[0];    var dig = source[1];    //转换整数部分    var k1 = 0; //计小单位    var k2 = 0; //计大单位    var sum = 0;    var str = &quot;&quot;;    var len = source[0].length; //整数的长度    for (i = 1; i &lt;= len; i++) &#123;      var n = source[0].charAt(len - i); //取得某个位数上的数字      var bn = 0;      if (len - i - 1 &gt;= 0) &#123;        bn = source[0].charAt(len - i - 1); //取得某个位数前一位上的数字      &#125;      sum = sum + Number(n);      if (sum != 0) &#123;        str = dw[Number(n)].concat(str); //取得该数字对应的大写数字，并插入到str字符串的前面        if (n == &#x27;0&#x27;) sum = 0;      &#125;      if (len - i - 1 &gt;= 0) &#123; //在数字范围内        if (k1 != 3) &#123; //加小单位          if (bn != 0) &#123;            str = dw1[k1].concat(str);          &#125;          k1++;        &#125; else &#123; //不加小单位，加大单位          k1 = 0;          var temp = str.charAt(0);          if (temp == &quot;万&quot; || temp == &quot;亿&quot;) //若大单位前没有数字则舍去大单位          str = str.substr(1, str.length - 1);          str = dw2[k2].concat(str);          sum = 0;        &#125;      &#125;      if (k1 == 3) //小单位到千则大单位进一      &#123;        k2++;      &#125;    &#125;    //转换小数部分    var strdig = &quot;&quot;;    if (dig != &quot;&quot;) &#123;      var n = dig.charAt(0);      if (n != 0) &#123;        strdig += dw[Number(n)] + &quot;角&quot;; //加数字      &#125;      var n = dig.charAt(1);      if (n != 0) &#123;        strdig += dw[Number(n)] + &quot;分&quot;; //加数字      &#125;    &#125;    str += &quot;元&quot; + strdig;  &#125; catch(e) &#123;    return &quot;0元&quot;;  &#125;  return str;&#125;//拆分整数与小数function splits(tranvalue) &#123;  var value = new Array(&#x27;&#x27;, &#x27;&#x27;);  temp = tranvalue.split(&quot;.&quot;);  for (var i = 0; i &lt; temp.length; i++) &#123;    value[i] = temp[i];  &#125;  return value;&#125;\n\n常用的正则表达式大收集匹配中文字符的正则表达式： [\\u4e00-\\u9fa5] 匹配双字节字符（包括汉字在内）：[^\\x00-\\xff] 匹配空行的正则表达式：\\n[\\s| ]*\\r 匹配 HTML 标记的正则表达式：&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt;匹配首尾空格的正则表达式：(^\\s*)|(\\s*$) 匹配 IP 地址的正则表达式：/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g匹配 Email 地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*匹配网址 URL 的正则表达式：http://(/[\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)?sql 语句：^(select|drop|delete|create|update|insert).*$ 非负整数：^\\d+$ 正整数：^[0-9]*[1-9][0-9]*$ 非正整数：^((-\\d+)|(0+))$ 负整数：^-[0-9]*[1-9][0-9]*$ 整数：^-?\\d+$ 非负浮点数：^\\d+(\\.\\d+)?$ 正浮点数：^((0-9)+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 非正浮点数：^((-\\d+\\.\\d+)?)|(0+(\\.0+)?))$ 英文字符串：^[A-Za-z]+$ 英文大写串：^[A-Z]+$ 英文小写串：^[a-z]+$ 英文字符数字串：^[A-Za-z0-9]+$ 英数字加下划线串：^\\w+$ E-mail地址：^[\\w-]+(\\.[\\w-]+)*@[\\w-]+(\\.[\\w-]+)+$ URL：^[a-zA-Z]+://(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\s*)?$ 或：^http:\\/\\/[A-Za-z0-9]+\\.[A-Za-z0-9]+[\\/=\\?%\\-&amp;_~`@[\\]\\&#x27;:+!]*([^&lt;&gt;\\&quot;\\&quot;])*$ 邮政编码：^[1-9]\\d&#123;5&#125;$ 电话号码：^((\\(\\d&#123;2,3&#125;\\))|(\\d&#123;3&#125;\\-))?(\\(0\\d&#123;2,3&#125;\\)|0\\d&#123;2,3&#125;-)?[1-9]\\d&#123;6,7&#125;(\\-\\d&#123;1,4&#125;)?$ 手机号码：^((\\(\\d&#123;2,3&#125;\\))|(\\d&#123;3&#125;\\-))?13\\d&#123;9&#125;$ 双字节字符（包括汉字在内）：^\\x00-\\xff 匹配首尾空格：(^\\s*)|(\\s*$)匹配 HTML 标记：&lt;(.*)&gt;.*&lt;\\/\\1&gt;|&lt;(.*) \\/&gt; 匹配空行：\\n[\\s| ]*\\r 提取信息中的网络链接：(h|H)(r|R)(e|E)(f|F) *= *(&#x27;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#x27;|&quot;| *|&gt;)? 提取信息中的邮件地址：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 提取信息中的图片链接：(s|S)(r|R)(c|C) *= *(&#x27;|&quot;)?(\\w|\\\\|\\/|\\.)+(&#x27;|&quot;| *|&gt;)? 提取信息中的 IP 地址：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+) 提取信息中的中国手机号码：(86)*0*13\\d&#123;9&#125; 提取信息中的中国固定电话号码：(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;8&#125; 提取信息中的中国电话号码（包括移动和固定电话）：(\\(\\d&#123;3,4&#125;\\)|\\d&#123;3,4&#125;-|\\s)?\\d&#123;7,14&#125; 提取信息中的中国邮政编码：[1-9]&#123;1&#125;(\\d+)&#123;5&#125; 提取信息中的浮点数（即小数）：(-?\\d*)\\.?\\d+ 提取信息中的任何数字 ：(-?\\d*)(\\.\\d+)? IP：(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+) 电话区号：^0\\d&#123;2,3&#125;$腾讯 QQ 号：^[1-9]*[1-9][0-9]*$ 帐号（字母开头，允许 5-16 字节，允许字母数字下划线）：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$ 中文、英文、数字及下划线：^[\\u4e00-\\u9fa5_a-zA-Z0-9]+$\n\n实现窗体改变事件resize的操作\n兼容所以的浏览器\n\n(function()&#123;    var fn = function()&#123;        var w = document.documentElement ? document.documentElement.clientWidth : document.body.clientWidth            ,r = 1255            ,b = Element.extend(document.body)            ,classname = b.className;        if(w &lt; r)&#123;            //当窗体的宽度小于1255的时候执行相应的操作        &#125;else&#123;            //当窗体的宽度大于1255的时候执行相应的操作        &#125;    &#125;    if(window.addEventListener)&#123;        window.addEventListener(&#x27;resize&#x27;, function()&#123; fn(); &#125;);    &#125;else if(window.attachEvent)&#123;        window.attachEvent(&#x27;onresize&#x27;, function()&#123; fn(); &#125;);    &#125;    fn();&#125;)();\n\n用正则清除空格分左右1 function ltrim(s)&#123; return s.replace( /^(\\s*| *)/, &quot;&quot;); &#125; 2 function rtrim(s)&#123; return s.replace( /(\\s*| *)$/, &quot;&quot;); &#125; 3 function trim(s)&#123; return ltrim(rtrim(s));&#125; \n\n判断变量是否空值/** * 判断变量是否空值 * undefined, null, &#x27;&#x27;, false, 0, [], &#123;&#125; 均返回true，否则返回false */function empty(v)&#123;    switch (typeof v)&#123;        case &#x27;undefined&#x27; : return true;        case &#x27;string&#x27;    : if(trim(v).length == 0) return true; break;        case &#x27;boolean&#x27;   : if(!v) return true; break;        case &#x27;number&#x27;    : if(0 === v) return true; break;        case &#x27;object&#x27;    :             if(null === v) return true;            if(undefined !== v.length &amp;&amp; v.length==0) return true;            for(var k in v)&#123;return false;&#125; return true;            break;    &#125;    return false;&#125;\n\n实现base64解码function base64_decode(data)&#123;    var b64 = &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=&quot;;    var o1, o2, o3, h1, h2, h3, h4, bits, i = 0,ac = 0,dec = &quot;&quot;,tmp_arr = [];    if (!data) &#123; return data; &#125;    data += &#x27;&#x27;;    do &#123;         h1 = b64.indexOf(data.charAt(i++));        h2 = b64.indexOf(data.charAt(i++));        h3 = b64.indexOf(data.charAt(i++));        h4 = b64.indexOf(data.charAt(i++));        bits = h1 &lt;&lt; 18 | h2 &lt;&lt; 12 | h3 &lt;&lt; 6 | h4;        o1 = bits &gt;&gt; 16 &amp; 0xff;        o2 = bits &gt;&gt; 8 &amp; 0xff;        o3 = bits &amp; 0xff;        if (h3 == 64) &#123;            tmp_arr[ac++] = String.fromCharCode(o1);        &#125; else if (h4 == 64) &#123;            tmp_arr[ac++] = String.fromCharCode(o1, o2);        &#125; else &#123;            tmp_arr[ac++] = String.fromCharCode(o1, o2, o3);        &#125;    &#125; while (i &lt; data.length);    dec = tmp_arr.join(&#x27;&#x27;);    dec = utf8_decode(dec);    return dec;&#125;\n\n实现utf8解码function utf8_decode(str_data)&#123;    var tmp_arr = [],i = 0,ac = 0,c1 = 0,c2 = 0,c3 = 0;str_data += &#x27;&#x27;;    while (i &lt; str_data.length) &#123;        c1 = str_data.charCodeAt(i);        if (c1 &lt; 128) &#123;            tmp_arr[ac++] = String.fromCharCode(c1);            i++;        &#125; else if (c1 &gt; 191 &amp;&amp; c1 &lt; 224) &#123;                   c2 = str_data.charCodeAt(i + 1);            tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 31) &lt;&lt; 6) | (c2 &amp; 63));            i += 2;        &#125; else &#123;            c2 = str_data.charCodeAt(i + 1);            c3 = str_data.charCodeAt(i + 2);            tmp_arr[ac++] = String.fromCharCode(((c1 &amp; 15) &lt;&lt; 12) | ((c2 &amp; 63) &lt;&lt; 6) | (c3 &amp; 63));            i += 3;        &#125;    &#125;     return tmp_arr.join(&#x27;&#x27;);&#125;\n\n获取窗体可见范围的宽与高function getViewSize()&#123;    var de=document.documentElement;    var db=document.body;    var viewW=de.clientWidth==0 ?  db.clientWidth : de.clientWidth;    var viewH=de.clientHeight==0 ?  db.clientHeight : de.clientHeight;    return Array(viewW ,viewH);&#125;\n\n判断IE版本号\n（既简洁、又向后兼容！）\n\nvar _IE = (function()&#123;    var v = 3, div = document.createElement(&#x27;div&#x27;), all = div.getElementsByTagName(&#x27;i&#x27;);    while (        div.innerHTML = &#x27;&lt;!--[if gt IE &#x27; + (++v) + &#x27;]&gt;&lt;i&gt;&lt;/i&gt;&lt;![endif]--&gt;&#x27;,        all[0]    );    return v &gt; 4 ? v : false ;&#125;());\n\n获取浏览器版本号function browserVersion(types) &#123;    var other = 1;    for (i in types) &#123;        var v = types[i] ? types[i] : i;        if (USERAGENT.indexOf(v) != -1) &#123;            var re = new RegExp(v + &#x27;(\\\\/|\\\\s|:)([\\\\d\\\\.]+)&#x27;, &#x27;ig&#x27;);            var matches = re.exec(USERAGENT);            var ver = matches != null ? matches[2] : 0;            other = ver !== 0 &amp;&amp; v != &#x27;mozilla&#x27; ? 0 : other;        &#125; else &#123;            var ver = 0;        &#125;        eval(&#x27;BROWSER.&#x27; + i + &#x27;= ver&#x27;);    &#125;    BROWSER.other = other;&#125;\n\n半角转换为全角函数function ToDBC(str)&#123;  var result = &#x27;&#x27;;  for(var i=0; i &lt; str.length; i++)&#123;    code = str.charCodeAt(i);    if(code &gt;= 33 &amp;&amp; code &lt;= 126)&#123;      result += String.fromCharCode(str.charCodeAt(i) + 65248);    &#125;else if (code == 32)&#123;      result += String.fromCharCode(str.charCodeAt(i) + 12288 - 32);    &#125;else&#123;      result += str.charAt(i);    &#125;  &#125; return result;&#125;\n\n全角转换为半角函数function ToCDB(str)&#123;  var result = &#x27;&#x27;;  for(var i=0; i &lt; str.length; i++)&#123;    code = str.charCodeAt(i);    if(code &gt;= 65281 &amp;&amp; code &lt;= 65374)&#123;      result += String.fromCharCode(str.charCodeAt(i) - 65248);    &#125;else if (code == 12288)&#123;      result += String.fromCharCode(str.charCodeAt(i) - 12288 + 32);    &#125;else&#123;      result += str.charAt(i);    &#125;  &#125; return result;&#125;\n\nend\n","categories":["js"],"tags":["js"]},{"title":"vue项目实战","url":"/2021/06/02/vue/vue%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/","content":"项目技术：vue2 + ts + elementui\n搭建项目架构创建项目使用 Vue CLI 创建项目安装 Vue ClI\nnpm i -g @vue/clivue create edu-boss-fed Vue CLI v4.5.6 ? Please pick a preset: Manually select features // 手动选择公共特性 ? Check the features needed for your project: Babel, TS, Router,Vuex, CSS Pre-processors, Linter ? Use class-style component syntax? Yes // TS 相关 ? Use Babel alongside TypeScript (required for modern mode, auto\u0002detected polyfills, transpiling JSX)? Yes ? Use history mode for router? (Requires proper server setup forindex fallback in production) No ? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modulesare supported by default): Sass/SCSS (with dart-sass) ? Pick a linter / formatter config: Standard ? Pick additional lint features: Lint on save, Lint and fix on commit ? Where do you prefer placing config for Babel, ESLint, etc.? Indedicated config files // 保存到各自独立的配置文件中 ? Save this as a preset for future projects? No ⚓ Running completion hooks... � Generating README.md... � Successfully created project topline-m-89. � Get started with the following commands: $ cd edu-boss-fed $ npm run serve\n\n安装结束，启动开发服务\ncd edu-boss-fednpm run serve\n\n\n\n使用 TypeScript 开发 Vue 项目\n全新项目\n脚手架安装时 选择 TypeScript\n\n已有项目\nvue add @vue/typescript\n\nTypeScript 相关配置介绍安装了 TypeScript 相关的依赖项\ndependencies 依赖\n\n\n\n\n依赖项\n说明\n\n\n\nvue-class-component\n提供使用 Class 语法写 Vue 组件\n\n\nvue-property-decorator\n在 Class 语法基础之上提供了一些辅助装饰器\n\n\n\ndevDependencies 依赖\n\n\n\n\n依赖项\n说明\n\n\n\n@typescript-eslint/eslint-plugin\n使用 ESLint 校验 TypeScript 代码\n\n\n@typescript-eslint/parser\n将 TypeScript 转为 AST 供 ESLint 校验使用\n\n\n@vue/cli-plugin-typescript\n使用 TypeScript + ts-loader + fork-ts-checker-webpack-plugin 进行更快的类型检查\n\n\n@vue/eslint-config-typescript\n兼容 ESLint 的 TypeScript 校验规则\n\n\ntypescript\nTypeScript 编译器，提供类型校验和转换 JavaScript 功能\n\n\nTypeScript 配置文件 tsconfig.json&#123;  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;esnext&quot;,    &quot;module&quot;: &quot;esnext&quot;,    &quot;strict&quot;: true,    &quot;jsx&quot;: &quot;preserve&quot;,    &quot;importHelpers&quot;: true,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;experimentalDecorators&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;sourceMap&quot;: true,    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;types&quot;: [      &quot;webpack-env&quot;    ],    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [        &quot;src/*&quot;      ]    &#125;,    &quot;lib&quot;: [      &quot;esnext&quot;,      &quot;dom&quot;,      &quot;dom.iterable&quot;,      &quot;scripthost&quot;    ]  &#125;,  &quot;include&quot;: [    &quot;src/**/*.ts&quot;,    &quot;src/**/*.tsx&quot;,    &quot;src/**/*.vue&quot;,    &quot;tests/**/*.ts&quot;,    &quot;tests/**/*.tsx&quot;  ],  &quot;exclude&quot;: [    &quot;node_modules&quot;  ]&#125;\n\nshims-vue.d.ts 文件的作用// 主要用于 TypeScript 识别 .vue 文件模块// TypeScript 默认不支持导入 .vue 模块。这个文件告诉 TypeScript 导入 .vue 文件模块都按 VueConstructor&lt;Vue&gt; 类型识别处理declare module &#x27;*.vue&#x27; &#123;  import Vue from &#x27;vue&#x27;  export default Vue&#125;\n\nshims-tsx.d.ts 文件的作用// 为 jsx 组件模板补充类型声明import Vue, &#123; VNode &#125; from &#x27;vue&#x27;declare global &#123;  namespace JSX &#123;    // tslint:disable no-empty-interface    interface Element extends VNode &#123;&#125;    // tslint:disable no-empty-interface    interface ElementClass extends Vue &#123;&#125;    interface IntrinsicElements &#123;      [elem: string]: any    &#125;  &#125;&#125;\n\n定义组件的方式使用 Options APIs\n组件仍然可以使用以前的方式定义（导出组件选项对象，或者使用 Vue.extend()）\n但是当我们导出的是一个普通的对象，此时 TypeScript 无法推断出对应的类型\n至于 VSCode 可以推断出类型成员的原因是因为我们使用了 Vue 插件\n这个插件明确知道我们这里导出的是一个 Vue 对象\n所以我们必须使用 Vue.extend() 方法确保 TypeScript 能够有正常的类型推断\n\nconst component = &#123;\t// 这里不会有类型推断    // 因为 TypeScript 不能确认这是 Vue 组件的选项&#125;\n\n&lt;script lang=&quot;ts&quot;&gt;    import Vue from &#x27;vue&#x27;    export default Vue.extend(&#123;        // 类型推断已启用        name:&#x27;Button&#x27;,        data()&#123;            return &#123;                count: 1            &#125;        &#125;    &#125;)&lt;/script&gt;\n\n使用 Class APIs 定义 Vue 组件https://class-component.vuejs.org\n在 TypeScript 下，Vue 组件可以使用一个继承自 Vue 类型的子类表示，这种类型需要使用 Component 装饰器去修饰\n装饰器函数接收的参数就是以前的组件选项对象（data、props、methods之类）\n// 基于类的 Vue 组件--使用 vue-class-component 装饰器&lt;script lang=&quot;ts&quot;&gt;    import Vue from &#x27;vue&#x27;    import Component from &#x27;vue-class-component&#x27;    // @Component 修饰符注明了此类为一个 Vue 组件    @Component(&#123;      // 所有的组件选项都可以放在这里      template: &#x27;&lt;button @click=&quot;onClick&quot;&gt;Click!&lt;/button&gt;&#x27;,      props:&#123;          size:String      &#125;    &#125;)    export default class MyComponent extends Vue &#123;      // 初始数据可以直接声明为实例的 property      message: string = &#x27;Hello!&#x27;      // 组件方法也可以直接声明为实例的方法      onClick (): void &#123;        window.alert(this.message)      &#125;    &#125;&lt;/script&gt;\n\n关于装饰器语法https://es6.ruanyifeng.com/#docs/decorator\n装饰器 是 ES 草案中的一个特性，不建议在生产环境使用\n类的装饰器\nfunction testable (target) &#123;    target.isTestable = true&#125;@testableclass MyTestableClass &#123;    // ...&#125;console.log(MyTestableClass.isTestable) // true\n\n使用 VuePropertyDecorator 创建 Vue 组件https://github.com/kaorun343/vue-property-decorator\n该项目已经自动安装了\n个人建议 使用 Options APIs:\n\nClass 语法仅仅是一种写法而已，最终还是要转换为普通的组件数据结构\n装饰器语法还没有正式定稿发布，建议了解即可，正式发布之后再使用\n\n加入 Git 版本管理\n创建远程仓库\n将本地仓库推到线上\n\ngit initgit add .git commit -m &#x27;提交日志&#x27;git remote add origin 远程仓库地址git push -u origin master\n\n项目目录结构说明 . ├── node_modules # 第三⽅包存储⽬录 ├── public # 静态资源⽬录，任何放置在 public ⽂件夹的静态资源都会被简单的复制，⽽不经过 webpack │ ├── favicon.ico │ └── index.html ├── src │ ├── assets # 公共资源⽬录，放图⽚等资源 │ ├── components # 公共组件⽬录 │ ├── router # 路由相关模块 │ ├── store # 容器相关模块 │ ├── views # 路由⻚⾯组件存储⽬录 │ ├── App.vue # 根组件，最终被替换渲染到 index.html ⻚⾯中 #app ⼊⼝节点 │ ├── main.ts # 整个项⽬的启动⼊⼝模块 │ ├── shims-tsx.d.ts # ⽀持以 .tsc 结尾的⽂件，在 Vue 项⽬中编写 jsx代码 │ └── shims-vue.d.ts # 让 TypeScript 识别 .vue 模块 ├── .browserslistrc # 指定了项⽬的⽬标浏览器的范围。这个值会被 @babel/preset-env 和 Autoprefixer ⽤来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀 ├── .editorconfig # EditorConfig 帮助开发⼈员定义和维护跨编辑器（或IDE）的统⼀的代码⻛格 ├── .eslintrc.js # ESLint 的配置⽂件 ├── .gitignore # Git 的忽略配置⽂件，告诉Git项⽬中要忽略的⽂件或⽂件夹 ├── README.md # 说明⽂档 ├── babel.config.js # Babel 配置⽂件 ├── package-lock.json # 记录安装时的包的版本号，以保证⾃⼰或其他⼈在 npm install 时⼤家的依赖能保证⼀致 ├── package.json # 包说明⽂件，记录了项⽬中使⽤到的第三⽅包依赖信息等内容 └── tsconfig.json # TypeScript 配置⽂件\n\n调整初始目录结构默认生成的目录结构不满足我们的开发需求，所以需要做一些自定义改动。\n\n删除初始化的默认文件\n新增调整我们需要的目录结构\n\n修改 App.vue :\n&lt;template&gt;\t&lt;div id=&quot;app&quot;&gt;        &lt;h1&gt;App&lt;/h1&gt;                &lt;!-- 根级路由出口 --&gt;        &lt;router-view /&gt;    &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;\n\n修改 router/index.ts :\nimport Vue from &#x27;vue&#x27;import VueRouter, &#123; RouteConfig &#125; from &#x27;vue-router&#x27;Vue.use(VueRouter)// 路由配置规则const routes: Array&lt;RouteConfig&gt; = []const router = new VueRouter(&#123;  routes&#125;)export default router\n\n删除默认示例文件：\n\nsrc/views/About.vue\nsrc/views/Home.vue\nsrc/components/HelloWorld.vue\nsrc/assets/logo.png\n\n创建以下内容\n\nsrc/services 目录：接口模块\nsrc/utils 目录：存储一些工具模块\nsrc/styles 目录：存储一些样式资源\n\n调整后的目录结构如下：\n.├── node_modules ├── public │ ├── favicon.ico│ └── index.html├── src│ ├── assets │ ├── components │ ├── router │ ├── services │ ├── store │ ├── styles│ ├── utils│ ├── views│ ├── App.vue │ ├── main.ts │ ├── shims-tsx.d.ts │ └── shims-vue.d.ts ├── .browserslistrc ├── .editorconfig ├── .eslintrc.js├── .gitignore ├── README.md├── babel.config.js ├── package-lock.json ├── package.json └── tsconfig.json\n\n风格指南本项⽬的⻛格指南主要是参照 vue 官⽅的[⻛格指南](风格指南 — Vue.js (vuejs.org))。在真正开始使⽤该项⽬之前建议先阅读⼀遍指南， 这能帮助让你写出更规范和统⼀的代码。当然每个团队都会有所区别。其中⼤部分规则也都配置在了 eslint-plugin-vue之中，当没有遵循规则的时候会报错，详细内容⻅[eslint](ESLint | vue-element-admin (gitee.io))章节。 \n当然也有⼀些特殊的规范，是不能被 eslint 校验的。需要⼈为的⾃⼰注意，并且来遵循。最主要的就是⽂ 件的命名规则，这⾥拿 vue-element-admin 来举例。\nComponent所有的Component文件都是以大写开头，除了index.vue\n\n@/components/BackToTop/index.vue \n@/components/Charts/Line.vue \n@/views/example/components/Button.vue\n\nJavaScript 文件所有的.js文件都遵循横线连接（kebab-case)\n\n@/utils/open-window.js \n@/views/svg-icons/require-icons.js \n@/components/MarkdownEditor/default-options.js\n\nViews在views文件下，代表路由的.vue文件都使用横线连接（kebab-case)，代表路由的文件夹也是使用同样的规则\n\n@/views/svg-icons/index.vue \n@/views/svg-icons/require-icons.js\n\n使⽤横线连接 (kebab-case)来命名views主要是出于以下⼏个考虑。\n\n横线连接 (kebab-case) 也是官⽅推荐的命名规范之⼀ [⽂档 ](风格指南 — Vue.js (vuejs.org))\nviews 下的 .vue ⽂件代表的是⼀个路由，所以它需要和 component 进⾏区分(component 都是⼤ 写开头) \n⻚⾯的 url 也都是横线连接的，⽐如 https://www.xxx.admin/export-excel ，所以路由对应 的 view 应该要保持统⼀ \n没有⼤⼩写敏感问题\n\n代码规范和 ESLint不管是多⼈合作还是个⼈项⽬，代码规范都是很重要的。这样做不仅可以很⼤程度地避免基本语法错误， 也保证了代码的可读性。 \n这⾥主要说明以下⼏点： \n\n代码格式规范介绍 \n我们项⽬中配置的具体代码规范是什么 \n遇到代码格式规范错误怎么办 \n如何⾃定义代码格式校验规范\n\n代码规范介绍良好的代码格式规范更有利于： \n\n更好的多⼈协作 \n\n更好的阅读 \n\n更好的维护 …\n\n\n标准是什么没有绝对的标准，下⾯是⼀些⼤⼚商根据多数开发者的编码习惯制定的⼀些编码规范，仅供参考。\n\n自己用：[JavaScript Standard Style](JavaScript Standard Style (standardjs.com))\n工作大型团队用：[Airbnb JavaScript Style Guide](GitHub - airbnb/javascript: JavaScript Style Guide)\n工作大型团队用：[Google JavaScript Style Guide](Google JavaScript Style Guide)\n\n如何约束代码规范只靠⼝头约定肯定是不⾏的，所以要利⽤⼯具来强制执⾏。 \n\n[JSLint ](JSLint: The JavaScript Code Quality Tool)\n[JSHint ](JSHint, a JavaScript Code Quality Tool)\n[ESLint](JSHint, a JavaScript Code Quality Tool) …\n\n项目中的代码规范是什么ESLint 配置文件 .eslintrc.js\nmodule.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  // 插件：扩展了校验规则  extends: [    &#x27;plugin:vue/essential&#x27;, // eslint-plugin-vue    &#x27;@vue/standard&#x27;, // @vue/eslint-config-standard    &#x27;@vue/typescript/recommended&#x27; // @vue/eslint-config-typescript  ],  parserOptions: &#123;    ecmaVersion: 2020  &#125;,  // 自定义校验规则  rules: &#123;    &#x27;no-console&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;warn&#x27; : &#x27;off&#x27;,    &#x27;no-debugger&#x27;: process.env.NODE_ENV === &#x27;production&#x27; ? &#x27;warn&#x27; : &#x27;off&#x27;,      // 关闭 函数名与左括号之间的空格校验    &#x27;space-before-function-paren&#x27;: 0  &#125;&#125;\n\n\neslint-plugin-vue\nGitHub 仓库：https://github.com/vuejs/eslint-plugin-vue \n官⽅⽂档：https://eslint.vuejs.org/ \n该插件使我们可以使⽤ ESLint 检查 .vue ⽂件的 &lt;template&gt; 和 &lt;script&gt;\n查找语法错误\n查找对 Vue.js 指令的错误使用\n查找违反 Vue.js 样式指南的行为\n\n\n@vue/eslint-config-standard\neslint-plugin-standard \n[JavaScript Standard Style](JavaScript Standard Style (standardjs.com))\n\n\n@vue/eslint-config-typescript\n规则列表：https://github.com/typescript-eslint/typescript-eslint/tree/master/packages/eslint-plugin#supported-rules \n\n\n\n如何自定义代码格式校验规范https://eslint.bootcss.com/docs/user-guide/getting-started\n&#123;    &quot;rules&quot;:&#123;        &quot;semi&quot;:[&quot;errors&quot;,&quot;always&quot;],        &quot;quotes&quot;:[&quot;errors&quot;,&quot;double&quot;]    &#125;&#125;\n\nESLint 附带有⼤量的规则。你可以使⽤注释或配置⽂件修改你项⽬中要使⽤的规则。要改变⼀个规则设 置，你必须将规则 ID 设置为下列值之⼀：\n\n&quot;off&quot;`` 或 0``` - 关闭规则 \n&quot;warn&quot; 或 1 - 开启规则，使⽤警告级别的错误： warn (不会导致程序退出) \n&quot;error&quot; 或 2 - 开启规则，使⽤错误级别的错误： error (当被触发的时候，程序会退出)\n\n为了在⽂件注释⾥配置规则，使⽤以下格式的注释：\n/* eslint eqeqeq: &quot;off&quot;, curly: &quot;error&quot; */\n\n在这个例⼦⾥， eqeqeq 规则被关闭，curly规则被打开，定义为错误级别。你也可以使⽤对应的数字 定义规则严重程度：\n/* eslint eqeqeq: 0, curly: 2 */\n\n这个例⼦和上个例⼦是⼀样的，只不过它是⽤的数字⽽不是字符串。 eqeqeq 规则是关闭的， curly 规 则被设置为错误级别。 如果⼀个规则有额外的选项，你可以使⽤数组字⾯量指定它们，⽐如：\n/* eslint quotes: [&quot;error&quot;, &quot;double&quot;], curly: 2 */\n\n这条注释为规则 quotes 指定了 “double”选项。数组的第⼀项总是规则的严重程度（数字或字符串）。\n还可以使⽤ rules 连同错误级别和任何你想使⽤的选项，在配置⽂件中进⾏规则配置。例如：\n&#123;    &quot;rules&quot;: &#123;        &quot;eqeqeq&quot;: &quot;off&quot;,        &quot;curly&quot;: &quot;error&quot;,        &quot;quotes&quot;: [&quot;error&quot;, &quot;double&quot;]    &#125;&#125;\n\n配置定义在插件中的⼀个规则的时候，你必须使⽤ 插件名/规则ID 的形式。⽐如：\n&#123;    &quot;plugins&quot;:[        &quot;plugin1&quot;    ],    &quot;rules&quot;:&#123;        &quot;eqeqed&quot;:&quot;off&quot;,        &quot;curly&quot;:&quot;error&quot;,        &quot;quotes&quot;:[&quot;error&quot;,&quot;double&quot;],        &quot;plugin1/rule1&quot;:&quot;error&quot;    &#125;&#125;\n\n在这些配置⽂件中，规则 plugin1/rule1 表示来⾃插件 plugin1 的 rule1 规则。你也可以使⽤ 这种格式的注释配置，⽐如：\n/* eslint &quot;plugin1/rule1&quot;: &quot;error&quot; */\n\n注意：当指定来⾃插件的规则时，确保删除 eslint-plugin- 前缀。ESLint 在内部只使⽤没有前缀的 名称去定位规则。\nvscode 配置 ESLintvscode  安装 eslint安装并配置完成 ESLint 后，我们继续回到 VSCode 进⾏扩展设置，依次点击 ⽂件 &gt; ⾸选项 &gt; 设置 打 开 VSCode 配置⽂件,添加如下配置：\n&#123;    &quot;files.autoSave&quot;: &quot;off&quot;,    &quot;eslint.validate&quot;: [        &quot;javascript&quot;,        &quot;javascriptreact&quot;,        &quot;vue-html&quot;,        &#123;            &quot;language&quot;: &quot;vue&quot;,            &quot;autoFix&quot;: true        &#125;    ],    &quot;eslint.run&quot;: &quot;onSave&quot;,    &quot;eslint.autoFixOnSave&quot;: true&#125;\n\n\n\n自动修复npm run lint -- --fix\n\n\n\nGit Hooks布局导入 Element 组件库Element，⼀套为开发者、设计师和产品经理准备的基于 Vue 2.0 的桌⾯端组件库。\n\n官⽹：https://element.eleme.cn/ \nGitHub 仓库：https://github.com/ElemeFE/element\n\n\n安装 element\nnpm i element-ui\n在main.ts中导入配置（完整引入）\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(ElementUI)Vue.config.productionTip = falsenew Vue(&#123;  router,  store,  render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)\n按需引入\n借助 babel-plugin-component，我们可以只引入需要的组件，以达到减小项目体积的目的。\n首先，安装 babel-plugin-component：\nnpm install babel-plugin-component -D\n\n然后，将 .babelrc 修改为:\n&#123;  &quot;presets&quot;: [[&quot;es2015&quot;, &#123; &quot;modules&quot;: false &#125;]],  &quot;plugins&quot;: [    [      &quot;component&quot;,      &#123;        &quot;libraryName&quot;: &quot;element-ui&quot;,        &quot;styleLibraryName&quot;: &quot;theme-chalk&quot;      &#125;    ]  ]&#125;\n\n接下来，如果你只希望引入部分组件，比如 Button 和 Select，那么需要在 main.js 中写入以下内容：\nimport Vue from &#x27;vue&#x27;;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import &#123; Button, Select &#125; from &#x27;element-ui&#x27;;import App from &#x27;./App.vue&#x27;;Vue.component(Button.name, Button);Vue.component(Select.name, Select);/* 或写为 * Vue.use(Button) * Vue.use(Select) */Vue.config.productionTip = falsenew Vue(&#123;  router,  store,  render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)\n全局配置\n在引入 Element 时，可以传入一个全局配置对象。该对象目前支持 size 与 zIndex 字段。size 用于改变组件的默认尺寸，zIndex 设置弹框的初始 z-index（默认值：2000）。按照引入 Element 的方式，具体操作如下：\n\n完整引入 Element：\n\nimport Vue from &#x27;vue&#x27;;import Element from &#x27;element-ui&#x27;;Vue.use(Element, &#123; size: &#x27;small&#x27;, zIndex: 3000 &#125;);\n\n\n按需引入 Element：\n\nimport Vue from &#x27;vue&#x27;;import &#123; Button &#125; from &#x27;element-ui&#x27;;Vue.prototype.$ELEMENT = &#123; size: &#x27;small&#x27;, zIndex: 3000 &#125;;Vue.use(Button);\n\n样式处理 src/styles ├── index.scss # 全局样式（在⼊⼝模块被加载⽣效） ├── mixin.scss # 公共的 mixin 混⼊（可以把重复的样式封装为 mixin 混⼊到复⽤的地⽅） ├── reset.scss # 重置基础样式 └── variables.scss # 公共样式变量\n\n\nvariables.scss\n$primary-color: #40586F;$success-color: #51cf66;$warning-color: #fcc419;$danger-color: #ff6b6b;$info-color: #868e96; // #22b8cf;$body-bg: #E9EEF3; // #f5f5f9;$sidebar-bg: #F8F9FB;$navbar-bg: #F8F9FB;$font-family: system-ui, -apple-system, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif;\nindex.scss\n@import &#x27;./variables.scss&#x27;;// globalshtml &#123;  font-family: $font-family;  -webkit-text-size-adjust: 100%;  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);  // better Font Rendering  -webkit-font-smoothing: antialiased;  -moz-osx-font-smoothing: grayscale;&#125;body &#123;  margin: 0;  background-color: $body-bg;&#125;// custom element theme$--color-primary: $primary-color;$--color-success: $success-color;$--color-warning: $warning-color;$--color-danger: $danger-color;$--color-info: $info-color;// change font path, required$--font-path: &#x27;~element-ui/lib/theme-chalk/fonts&#x27;;// import element default theme@import &#x27;~element-ui/packages/theme-chalk/src/index&#x27;;// node_modules/element-ui/packages/theme-chalk/src/common/var.scss// overrides// .el-menu-item, .el-submenu__title &#123;//   height: 50px;//   line-height: 50px;// &#125;.el-pagination &#123;  color: #868e96;&#125;// components.status &#123;  display: inline-block;  cursor: pointer;  width: .875rem;  height: .875rem;  vertical-align: middle;  border-radius: 50%;  &amp;-primary &#123;    background: $--color-primary;  &#125;  &amp;-success &#123;    background: $--color-success;  &#125;  &amp;-warning &#123;    background: $--color-warning;  &#125;  &amp;-danger &#123;    background: $--color-danger;  &#125;  &amp;-info &#123;    background: $--color-info;  &#125;&#125;\nreset.scss\n\nmixin.scss\n\nmain.ts 中引入\nimport Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import router from &#x27;./router&#x27;import store from &#x27;./store&#x27;import ElementUI from &#x27;element-ui&#x27;// index.scss文件中已经引入了// import &#x27;element-ui/lib/theme-chalk/index.css&#x27; // 加载全局样式import &#x27;./styles/index.scss&#x27;Vue.use(ElementUI)Vue.config.productionTip = falsenew Vue(&#123;  router,  store,  render: h =&gt; h(App)&#125;).$mount(&#x27;#app&#x27;)\n\n⽗组件改变⼦组件样式 深度选择器建议你使⽤ ::v-deep 的写法，它不仅兼容了 css 的 &gt;&gt;&gt; 写法，还兼容了 sass /deep/ 的写法。⽽且 它还是 vue 3.0 RFC 中指定的写法。 \n⽽且原本 /deep/ 的写法也本身就被 Chrome 所废弃，你现在经常能在控制台中发现 Chrome 提示你 不要使⽤ /deep/ 的警告。\n共享全局样式变量全局注入 variables.scss 的变量\n有的时候你想要向 webpack 的预处理器 loader 传递选项。你可以使用 vue.config.js 中的 css.loaderOptions 选项。比如你可以这样向所有 Sass/Less 样式传入共享的全局变量：\n参考： https://cli.vuejs.org/zh/guide/css.html#%E5%90%91%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-loader-%E4%BC%A0%E9%80%92%E9%80%89%E9%A1%B9\n// vue.config.jsmodule.exports = &#123;  css: &#123;    loaderOptions: &#123;      // 默认情况下 `sass` 选项会同时对 `sass` 和 `scss` 语法同时生效      // 因为 `scss` 语法在内部也是由 sass-loader 处理的      // 但是在配置 `prependData` 选项的时候      // `scss` 语法会要求语句结尾必须有分号，`sass` 则要求必须没有分号      // 在这种情况下，我们可以使用 `scss` 选项，对 `scss` 语法进行单独配置      scss: &#123;        additionalData: `@import &quot;~@styles/variables.scss&quot;;`      &#125;    &#125;  &#125;&#125;\n\n&lt;template&gt;  &lt;div id=&quot;app&quot;&gt;    &lt;h1&gt;App&lt;/h1&gt;    &lt;p class=&quot;text&quot;&gt;hello world&lt;/p&gt;    &lt;!--根级路由出口--&gt;    &lt;router-view /&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;interface Foo &#123;  a: string  b: number&#125;export default Vue.extend(&#123;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;// @import &#x27;~@/styles/variables.scss&#x27;;// 全局引入过，所以可以直接使用，不用再引入.text &#123;  color: $danger-color;&#125;&lt;/style&gt;\n\n\n\n服务端接口说明后台为我们提供了数据接口，分别是：\n\nhttp://eduboss.lagou.com\n用户名：15510792995   密码：111111用户名： 18201288771  密码： 111111\n\nhttp://eduboss.lagou.com/boss/doc.html#/home\n\nhttp://edufront.lagou.com\nhttp://113.31.105.128/front/doc.html#/home\n\n\n这两个接口都没有提供 CORS 跨域请求，所以需要在客户端配置服务端代理处理跨域请求\n配置客户端层⾯的服务端代理跨域可以参考官⽅⽂档中的说明： \n\nhttps://cli.vuejs.org/zh/config/#devserver-proxy \nhttps://github.com/chimurai/http-proxy-middleware\n\n下面是具体的操作流程：\n// vue.config.jsmodule.exports = &#123;  devServer: &#123;    proxy: &#123;      &#x27;/boss&#x27;: &#123;        target: &#x27;https://eduboss.lagou.com&#x27;,        // ws: true, // webSocket 协议        changeOrigin: true // 把请求头中的 host 配置为 target      &#125;,      &#x27;/front&#x27;: &#123;        target: &#x27;http://edufront.lagou.com&#x27;,        changeOrigin: true      &#125;    &#125;  &#125;&#125;\n\n接口跨域问题\ncors ：生产环境可使用\n我最推荐的也是我⼯作中在使⽤的⽅式就是： cors 全称为 Cross Origin Resource Sharing（跨域资 源共享）。这种⽅案对于前端来说没有什么⼯作量，和正常发送请求写法上没有任何区别，⼯作量基本都 在后端这⾥。每⼀次请求，浏览器必须先以 OPTIONS 请求⽅式发送⼀个预请求（也不是所有请求都会发 送 options，展开介绍 (点我CS | awesome-bookmarks (panjiachen.github.io)），通过预检请求从⽽获知服务器端对跨源请求⽀持的 HTTP ⽅法。在确认 服务器允许该跨源请求的情况下，再以实际的 HTTP 请求⽅法发送那个真正的请求。推荐的原因是：只要 第⼀次配好了，之后不管有多少接⼝和项⽬复⽤就可以了，⼀劳永逸的解决了跨域问题，⽽且不管是开发 环境还是正式环境都能⽅便的使⽤。详细 MDN跨源资源共享（CORS） - HTTP | MDN (mozilla.org) ⽂档\n\nwebpack 的 proxy 代理：正向代理，生产环境不能使用\n开发中 Server(devServer) | webpack 中文网 (webpackjs.com)\n\nnginx 反向代理：生产环境可使用\n\n\n封装请求模块安装 axios\nnpm i axios\n\n创建 src/utils/request.js\n/** * 用户相关请求模块*/import request from &#x27;@/utils/request&#x27;import qs from &#x27;qs&#x27;interface User &#123;  phone: string  password: string&#125;export const login = (data: User) =&gt; &#123;  return request(&#123;    method: &#x27;POST&#x27;,    url: &#x27;/front/user/login&#x27;,    // qs 转化参数后，axios 会自动将请求格式设置为 x-www-form-urlencoded，所以不需要在设置 headers 的 content-type，key=value&amp;key=value    // 不用 qs 转化，axios 默认发送的类型是 application/json &#123;key:value,key:value&#125;    // 如果 data 是 formData 对象，则 content-type 是 multipart/form-data    data: qs.stringify(data)    // headers: &#123;    //   &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    // &#125;  &#125;)&#125;export const getUserInfo = () =&gt; &#123;  return request(&#123;    method: &#x27;GET&#x27;,    url: &#x27;/front/user/getInfo&#x27;  &#125;)&#125;\n\n请求方法封装\n services/user.ts\n/** * 用户相关请求模块*/import request from &#x27;@/utils/request.js&#x27;import qs from &#x27;qs&#x27;interface User &#123;  phone: string  password: string&#125;export const login = (data: User) =&gt; &#123;  return request(&#123;    method: &#x27;POST&#x27;,    url: &#x27;/front/user/login&#x27;,    // axios 默认发送的类型是 application/json 数据，这个接口的数据格式是 x-www-form-urlencoded,    // 设置 headers,qs 序列化参数    data: qs.stringify(data),    headers: &#123;      &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    &#125;  &#125;)&#125;\n\n请求数据格式转换,请求格式为 x-www-form-urlencoded 的处理方式axios 默认的请求数据格式为 ‘application/json&#39;,如果接口支持的格式为其他需要进行转换\n\n安装 qs\nnpm i qs\n使用\n/** * 用户相关请求模块*/import request from &#x27;@/utils/request.js&#x27;import qs from &#x27;qs&#x27;interface User &#123;/*  */  phone: string  password: string&#125;export const login = (data: User) =&gt; &#123;  return request(&#123;    method: &#x27;POST&#x27;,    url: &#x27;/front/user/login&#x27;, // 这个接口的数据格式是 x-www-form-urlencoded,    // qs 转化参数后，axios 会自动将请求格式设置为 x-www-form-urlencoded，所以不需要在设置 headers 的 content-type，key=value&amp;key=value    // 不用 qs 转化，axios 默认发送的类型是 application/json &#123;key:value,key:value&#125;    // 如果 data 是 formData 对象，则 content-type 是 multipart/form-data    data: qs.stringify(data)    // headers: &#123;    //   &#x27;content-type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;    // &#125;  &#125;)&#125;\n\n配置环境变量初始化路由页面组件views 文件夹下创建以下目录\n\n\n\n路径\n说明\n\n\n\n/\n首页\n\n\n/login\n用户登录\n\n\n/role\n角色管理\n\n\n/menu\n菜单管理\n\n\n/resource\n资源管理\n\n\n/course\n课程管理\n\n\n/user\n用户管理\n\n\n/advert\n广告管理\n\n\n/advert-space\n广告位管理\n\n\n路由和侧边栏router/index.ts\nimport Vue from &#x27;vue&#x27;import VueRouter, &#123; RouteConfig &#125; from &#x27;vue-router&#x27;Vue.use(VueRouter)// 路由配置规则const routes: Array&lt;RouteConfig&gt; = [  &#123;    path: &#x27;/&#x27;,    name: &#x27;home&#x27;,    // 通过注释起个别名    // 路由懒加载    component: () =&gt; import(/* webpackChunkName:&#x27;home&#x27; */ &#x27;@/views/home/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/login&#x27;,    name: &#x27;login&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;login&#x27; */ &#x27;@/views/login/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/role&#x27;,    name: &#x27;role&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;role&#x27; */ &#x27;@/views/role/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/menu&#x27;,    name: &#x27;menu&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;menu&#x27; */ &#x27;@/views/menu/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/resource&#x27;,    name: &#x27;resource&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;resource&#x27; */ &#x27;@/views/resource/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/course&#x27;,    name: &#x27;course&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;course&#x27; */ &#x27;@/views/course/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/user&#x27;,    name: &#x27;user&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;user&#x27; */ &#x27;@/views/user/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/advert&#x27;,    name: &#x27;advert&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;advert&#x27; */ &#x27;@/views/advert/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/advert-space&#x27;,    name: &#x27;advert-space&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;advert-space&#x27; */ &#x27;@/views/advert-space/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;*&#x27;, // 现在放哪个位置都行，vue-router 内部会放到最后，建议放到最后    name: &#x27;404&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;404&#x27; */ &#x27;@/views/error-page/404.vue&#x27;)  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router\n\n\n\nLayout 布局vue-router 嵌套路由 https://router.vuejs.org/zh/guide/essentials/nested-routes.html\n。。。借助 element  快速搭建\n\nlayout/index.vue\n\n&lt;template&gt;  &lt;el-container&gt;    &lt;el-aside width=&quot;200px&quot;&gt;      &lt;app-aside /&gt;    &lt;/el-aside&gt;    &lt;el-container&gt;      &lt;el-header&gt;        &lt;app-header /&gt;      &lt;/el-header&gt;      &lt;el-main&gt;        &lt;!-- 子路由出口 --&gt;        &lt;router-view /&gt;      &lt;/el-main&gt;    &lt;/el-container&gt;  &lt;/el-container&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;import AppAside from &#x27;./components/app-aside.vue&#x27;import AppHeader from &#x27;./components/app-header.vue&#x27;export default Vue.extend(&#123;  name: &#x27;LayoutIndex&#x27;,  components: &#123;    AppAside,    AppHeader  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.el-container &#123;  min-height: 100vh;  min-width: 980px;&#125;.el-header &#123;  background-color: #f8f9fb;&#125;.el-aside &#123;  background-color: #d3dce6;&#125;.el-main &#123;  background-color: #e9eef3;&#125;&lt;/style&gt;\n\n\n侧边栏 layout/components/app-aside.vue\n\n&lt;template&gt;  &lt;div class=&quot;aside&quot;&gt;    &lt;el-menu default-active=&quot;2&quot;             class=&quot;el-menu-vertical-demo&quot;             @open=&quot;handleOpen&quot;             @close=&quot;handleClose&quot;             background-color=&quot;#545c64&quot;             text-color=&quot;#fff&quot;             active-text-color=&quot;#ffd04b&quot;             router&gt;      &lt;el-submenu index=&quot;1&quot;&gt;        &lt;template slot=&quot;title&quot;&gt;          &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;          &lt;span&gt;权限管理&lt;/span&gt;        &lt;/template&gt;        &lt;el-menu-item-group&gt;          &lt;el-menu-item index=&quot;/role&quot;&gt;            &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;            &lt;span&gt;角色列表&lt;/span&gt;          &lt;/el-menu-item&gt;          &lt;el-menu-item index=&quot;/menu&quot;&gt;            &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;            &lt;span&gt;菜单管理&lt;/span&gt;          &lt;/el-menu-item&gt;          &lt;el-menu-item index=&quot;/resource&quot;&gt;            &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;            &lt;span&gt;资源管理&lt;/span&gt;          &lt;/el-menu-item&gt;        &lt;/el-menu-item-group&gt;      &lt;/el-submenu&gt;      &lt;el-menu-item index=&quot;/course&quot;&gt;        &lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;        &lt;span slot=&quot;title&quot;&gt;课程管理&lt;/span&gt;      &lt;/el-menu-item&gt;      &lt;el-menu-item index=&quot;/user&quot;&gt;        &lt;i class=&quot;el-icon-document&quot;&gt;&lt;/i&gt;        &lt;span slot=&quot;title&quot;&gt;用户管理&lt;/span&gt;      &lt;/el-menu-item&gt;      &lt;el-submenu index=&quot;4&quot;&gt;        &lt;template slot=&quot;title&quot;&gt;          &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;          &lt;span&gt;广告管理&lt;/span&gt;        &lt;/template&gt;        &lt;el-menu-item-group&gt;          &lt;el-menu-item index=&quot;/advert&quot;&gt;            &lt;i class=&quot;el-icon-location&quot;&gt;&lt;/i&gt;            &lt;span&gt;广告列表&lt;/span&gt;          &lt;/el-menu-item&gt;          &lt;el-menu-item index=&quot;/advert-space&quot;&gt;            &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;            &lt;span&gt;广告位管理&lt;/span&gt;          &lt;/el-menu-item&gt;        &lt;/el-menu-item-group&gt;      &lt;/el-submenu&gt;    &lt;/el-menu&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;export default Vue.extend(&#123;  name: &#x27;AppAside&#x27;,  methods: &#123;    handleOpen(key: string, keyPath: string): void &#123;      console.log(key, keyPath)    &#125;,    handleClose(key: string, keyPath: string): void &#123;      console.log(key, keyPath)    &#125;  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.aside &#123;  .el-menu &#123;    min-height: 100vh;  &#125;&#125;&lt;/style&gt;\n\n\n头部layout/components/app-header.vue\n\n&lt;template&gt;  &lt;div class=&quot;header&quot;&gt;    &lt;el-breadcrumb separator-class=&quot;el-icon-arrow-right&quot;&gt;      &lt;el-breadcrumb-item :to=&quot;&#123; path: &#x27;/&#x27; &#125;&quot;&gt;首页&lt;/el-breadcrumb-item&gt;      &lt;el-breadcrumb-item&gt;活动管理&lt;/el-breadcrumb-item&gt;      &lt;el-breadcrumb-item&gt;活动列表&lt;/el-breadcrumb-item&gt;      &lt;el-breadcrumb-item&gt;活动详情&lt;/el-breadcrumb-item&gt;    &lt;/el-breadcrumb&gt;    &lt;el-dropdown&gt;      &lt;span class=&quot;el-dropdown-link&quot;&gt;        &lt;el-avatar shape=&quot;square&quot;                   :size=&quot;40&quot;                   src=&quot;https://cube.elemecdn.com/9/c2/f0ee8a3c7c9638a54940382568c9dpng.png&quot;&gt;&lt;/el-avatar&gt;        &lt;i class=&quot;el-icon-arrow-down el-icon--right&quot;&gt;&lt;/i&gt;      &lt;/span&gt;      &lt;el-dropdown-menu slot=&quot;dropdown&quot;&gt;        &lt;el-dropdown-item&gt;用户ID&lt;/el-dropdown-item&gt;        &lt;el-dropdown-item divided&gt;登出&lt;/el-dropdown-item&gt;      &lt;/el-dropdown-menu&gt;    &lt;/el-dropdown&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;export default Vue.extend(&#123;  name: &#x27;AppHeader&#x27;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.header &#123;  height: 100%;  display: flex;  align-items: center;  justify-content: space-between;  .el-dropdown-link &#123;    display: flex;    align-items: center;  &#125;&#125;&lt;/style&gt;\n\n\n\nhttps://element.eleme.cn/#/zh-CN\nrouter/index.ts\nimport Vue from &#x27;vue&#x27;import VueRouter, &#123; RouteConfig &#125; from &#x27;vue-router&#x27;import Layout from &#x27;@/layout/index.vue&#x27;Vue.use(VueRouter)// 路由配置规则const routes: Array&lt;RouteConfig&gt; = [  &#123;    path: &#x27;/login&#x27;,    name: &#x27;login&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;login&#x27; */ &#x27;@/views/login/index.vue&#x27;)  &#125;,  &#123;    path: &#x27;/&#x27;,    component: Layout,    children: [      &#123;        path: &#x27;&#x27;,  // 默认子路由，匹配到 / 时会默认渲染这个组件        name: &#x27;home&#x27;,        // 通过注释起个别名        component: () =&gt; import(/* webpackChunkName:&#x27;home&#x27; */ &#x27;@/views/home/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/role&#x27;,        name: &#x27;role&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;role&#x27; */ &#x27;@/views/role/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/menu&#x27;,        name: &#x27;menu&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;menu&#x27; */ &#x27;@/views/menu/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/resource&#x27;,        name: &#x27;resource&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;resource&#x27; */ &#x27;@/views/resource/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/course&#x27;,        name: &#x27;course&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;course&#x27; */ &#x27;@/views/course/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/user&#x27;,        name: &#x27;user&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;user&#x27; */ &#x27;@/views/user/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/advert&#x27;,        name: &#x27;advert&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;advert&#x27; */ &#x27;@/views/advert/index.vue&#x27;)      &#125;,      &#123;        path: &#x27;/advert-space&#x27;,        name: &#x27;advert-space&#x27;,        component: () =&gt; import(/* webpackChunkName:&#x27;advert-space&#x27; */ &#x27;@/views/advert-space/index.vue&#x27;)      &#125;    ]  &#125;,  &#123;    path: &#x27;*&#x27;,    name: &#x27;404&#x27;,    component: () =&gt; import(/* webpackChunkName:&#x27;404&#x27; */ &#x27;@/views/error-page/404.vue&#x27;)  &#125;]const router = new VueRouter(&#123;  routes&#125;)export default router\n\n\n\n登录页面布局\n布局\n\n登录接口请求\n\n请求格式处理，axios 默认发送的类型是 application/json 数据，这个接口的数据格式是 x-www-form-urlencoded，设置 headers,qs 序列化参数\n\n请求成功跳转到首页，提示登录成功\n\n请求失败提示错误原因\n\n表单校验 \nhttps://github.com/yiminghe/async-validator\n\n\n\n请求期间禁用按钮\n\n\n&lt;template&gt;  &lt;div class=&quot;login&quot;&gt;    &lt;h1&gt;Edu boss管理系统&lt;/h1&gt;    &lt;el-form ref=&quot;form&quot;             label-position=&quot;top&quot;             :model=&quot;form&quot;             :rules=&quot;rules&quot;             class=&quot;login-form&quot;             label-width=&quot;80px&quot;&gt;      &lt;el-form-item label=&quot;手机号&quot;                    prop=&quot;phone&quot;&gt;        &lt;el-input v-model=&quot;form.phone&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item label=&quot;密码&quot;                    prop=&quot;password&quot;&gt;        &lt;el-input type=&quot;password&quot;                  v-model=&quot;form.password&quot;&gt;&lt;/el-input&gt;      &lt;/el-form-item&gt;      &lt;el-form-item&gt;        &lt;el-button type=&quot;primary&quot;                   class=&quot;login-btn&quot;                   :loading=&quot;isLoginLoading&quot;                   @click=&quot;onSubmit&quot;&gt;登录&lt;/el-button&gt;      &lt;/el-form-item&gt;    &lt;/el-form&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;import &#123; login &#125; from &#x27;@/services/user.ts&#x27;import &#123; Form &#125; from &#x27;element-ui&#x27;export default Vue.extend(&#123;  name: &#x27;LoginIndex&#x27;,  data() &#123;    return &#123;      form: &#123;        phone: &#x27;18201288771&#x27;,        password: &#x27;111111&#x27;      &#125;,      rules: &#123;        phone: [          &#123; required: true, message: &#x27;请输入手机号&#x27;, trigger: &#x27;blur&#x27; &#125;,          &#123;            pattern: /^1\\d&#123;10&#125;$/,            message: &#x27;请输入正确的手机号&#x27;,            trigger: &#x27;blur&#x27;          &#125;        ],        password: [          &#123; required: true, message: &#x27;请输入密码&#x27;, trigger: &#x27;blur&#x27; &#125;,          &#123;            // pattern: /^1\\d&#123;10&#125;$/,            min: 6,            max: 18,            message: &#x27;长度在 6 到 18 个字符&#x27;,            trigger: &#x27;blur&#x27;          &#125;        ]      &#125;,      isLoginLoading: false    &#125;  &#125;,  methods: &#123;    async onSubmit() &#123;      try &#123;        // 1. 表单验证        // this.$refs.form.validate()        await (this.$refs.form as Form).validate()        // 登录按钮显示 loading        this.isLoginLoading = true        // 2. 验证通过-提交表单        const &#123; data &#125; = await login(this.form)        // 3.处理请求结果        //   失败：给出提示        if (data.state !== 1) &#123;          this.$message.error(data.message)        &#125; else &#123;          //   成功：跳转到首页          this.$router.push(&#123;            name: &#x27;home&#x27;          &#125;)          this.$message.success(&#x27;登录成功&#x27;)        &#125;      &#125; catch (err) &#123;        this.$message.error(&#x27;登录失败&#x27; + err)      &#125;      // 结束登录按钮 loading      this.isLoginLoading = false    &#125;  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.login &#123;  height: 100vh;  display: flex;  flex-direction: column;  justify-content: center;  align-items: center;  .login-form &#123;    width: 300px;    background: #ffffff;    padding: 20px;    border-radius: 5px;    .login-btn &#123;      width: 100%;    &#125;  &#125;&#125;&lt;/style&gt;\n\n路由懒加载当打包构建应⽤时，Javascript 包会变得⾮常⼤，影响⻚⾯加载速度。如果我们能把不同路由对应的组件 分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加⾼效了。 \n结合 Vue 的异步组件和 Webpack 的代码分割功能，轻松实现路由组件的懒加载。如：\nconst Foo = () =&gt; import(/* webpackChunkName: &#x27;foo&#x27; */ &#x27;./Foo.vue&#x27;)\n\n当你的项⽬⻚⾯越来越多之后，在开发环境之中使⽤ lazy-loading 会变得不太合适，每次更改代码触 发热更新都会变得⾮常的慢。所以建议只在⽣产环境之中使⽤路由懒加载功能。\n\n安装依赖 npm install babel-plugin-dynamic-import-node -S -D \n在 babel.config.js 中添加插件\n\nmodule.exports = &#123;    presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;],    env:&#123;        development:&#123;            plugins:[&#x27;dynamic-import-node&#x27;]        &#125;    &#125;&#125;\n\n\n\n用户登录和身份认证用户登录状态存储\n用户登录成功，记录登录状态，登录状态存放到 vuex 容器中，容器中的数据方便共享，组件间使用方便\nviews/login/index.vue\nthis.$store.commit(&#x27;setUser&#x27;, data.content)\n数据持久化，为了防止页面刷新数据丢失，存放到本地存储\nstore/index.ts\nimport Vue from &#x27;vue&#x27;import Vuex from &#x27;vuex&#x27;Vue.use(Vuex)export default new Vuex.Store(&#123;  state: &#123;    // 类型警告报错解决 || &#x27;null&#x27;    user: JSON.parse(window.localStorage.getItem(&#x27;user&#x27;) || &#x27;null&#x27;) // 当前登录状态  &#125;,  mutations: &#123;    setUser(state, payload) &#123;      state.user = JSON.parse(payload)      // 数据持久化，为了防止页面刷新数据丢失，存放到本地存储      // 本地存储只能存放 字符串      window.localStorage.setItem(&#x27;user&#x27;, payload)    &#125;  &#125;,  actions: &#123;  &#125;,  modules: &#123;  &#125;&#125;)\n访问需要登录的页面时，判断有没有登录状态 路由守卫\n使用路由元信息\n从哪跳转登录页面，登录成功之后跳转回去\nconst routes: Array&lt;RouteConfig&gt; = [    ...    &#123;        path: &#x27;/&#x27;,        component: Layout,        meta: &#123;          requiresAuth: true        &#125;,        children:[...]     &#125;    ...]// 访问需要登录的页面时，判断有没有登录状态// 全局前置守卫router.beforeEach((to, from, next) =&gt; &#123;  // to.matched 是一个数组（匹配到的路由记录）  // 判断匹配到的路由是否需要登录权限，只要一个匹配到就是，因父路由需要的话子路由也需要  if (to.matched.some(record =&gt; record.meta.requiresAuth)) &#123;    // 判断登录状态    if (!store.state.user) &#123;      next(&#123;        name: &#x27;login&#x27;,        // 通过 url 传递查询字符串参数        query: &#123;          redirect: to.fullPath // 把登录成功需要返回的页面告诉登录页面        &#125;      &#125;)    &#125;  &#125;  next() // 允许通过&#125;)\n\n登录页面：\n// 1. 登录成功，记录登录状态，状态需要能够全局访问，vuexthis.$store.commit(&#x27;setUser&#x27;, data.content)// 2. 访问需要登录的页面时，判断有没有登录状态 路由守卫//   成功：跳转到首页this.$router.push((this.$route.query.redirect as string) || &#x27;/&#x27;)this.$message.success(&#x27;登录成功&#x27;)\n头部信息获取\nimport store from &#x27;@/store/index.ts&#x27;export const getUserInfo = () =&gt; &#123;  return request(&#123;    method: &#x27;GET&#x27;,    url: &#x27;/front/user/getInfo&#x27;,    headers: &#123;      Authorization: store.state.user.access_token    &#125;  &#125;)&#125;\n设置统一 token\n请求拦截器里设置\n// 请求拦截器request.interceptors.request.use(function (config) &#123;  // 改写 config 配置信息来实现业务功能的统一处理  const &#123; user &#125; = store.state  if (user &amp;&amp; user.access_token) &#123;    config.headers = &#123;      Authorization: user.access_token    &#125;  &#125;  // 一定要返回 config,否则请求发不出去了  return config&#125;, function (error) &#123;  return Promise.reject(error)&#125;)\n退出登录\n\n给组件注册原生事件 .native 修饰符\n&lt;el-dropdown-item divided @click.native=&quot;handleLogout&quot;&gt;登出&lt;/el-dropdown-item&gt;handleLogout() &#123;      this.$confirm(&#x27;确认退出吗?&#x27;, &#x27;退出提示&#x27;, &#123;        confirmButtonText: &#x27;确定&#x27;,        cancelButtonText: &#x27;取消&#x27;,        type: &#x27;warning&#x27;      &#125;)        .then(() =&gt; &#123;          this.$store.commit(&#x27;setUser&#x27;, null)          this.$router.push(&#123;            name: &#x27;login&#x27;          &#125;)          this.$message(&#123;            type: &#x27;success&#x27;,            message: &#x27;退出成功!&#x27;          &#125;)        &#125;)        .catch(() =&gt; &#123;          this.$message(&#123;            type: &#x27;info&#x27;,            message: &#x27;已取消退出&#x27;          &#125;)        &#125;)    &#125;\n\n\n\n身份认证Token 过期Token 过期是根据后台返回的信息判断的，后台会返回 401\n\n可以让用户重新登录\n\n刷新 Token\n\n在请求发起前拦截每个请求，判断 Token 的有效时间是否已过期，若已过期，则将请求挂起，先刷新 token 后在继续请求\n优点：在请求前拦截，能节省请求，省流量\n缺点：需要后端额外提供一个 token 过期时间的字段，使用了本地时间判断，若本地时间被篡改，特别是本地时间比服务器时间慢时，拦截会失败\n\n不在请求前拦截，而是拦截返回后的数据，先发起请求，接口返回过期后，先刷新 token ，再进行一次重试\n优点：不需额外的 token 过期字段，不需判断时间\n缺点：会消耗多一次请求，耗流量\n\n\n\n\n登录接口响应数据：\taccess_token：获取需要授权的接口数据\texpires_in：access_token过期时间\trefresh_token：刷新获取新的 access_tokenaccess_token 有过期时间以及时间较短：\t为了安全\n\naxios 错误处理 - 错误消息提示如果是自定义状态码，错误处理就写到第一个回调\n下面几项为：第二个回调\n请求收到响应了，但是状态码 超出 2xx\n\n400 - 请求参数错误\n\n401 - token 无效(没有，过期，无效)\n\n如果有 refresh_token ,则使用refresh_token获取新的 access_token\n\n​       成功了 -&gt; 把本次失败的请求重新发出去\n​       失败了 -&gt; 跳转登录页面重新登录获取新的 token\n\n没有，则直接跳转登录页面\n\n\n403 - 没有权限\n\n404 - 请求资源不存在\n\n500 - 服务端错误\n\n\n请求发出去了，但是没有收到响应\n请求的时候设置请求时发生了一些事情，触发了错误\n// 响应拦截器request.interceptors.response.use(function (response) &#123;  // 状态码为 2xx  // 如果是自定义状态码，错误处理就写到这里  return response&#125;, async function (error) &#123;  // 超出 2xx 状态码  // 如果是 HTTP 状态码，错误处理就写到这里  if (error.response) &#123; // 请求收到响应了，但是状态码 超出 2xx    // const errMsgObj = &#123;    //   &#x27;400&#x27;: &#x27;请求参数错误&#x27;,    //   &#x27;401&#x27;: &#x27;&#x27;,    //   &#x27;403&#x27;: &#x27;&#x27;,    //   &#x27;404&#x27;: &#x27;&#x27;,    //   &#x27;500&#x27;: &#x27;&#x27;    // &#125;    // let &#123; status &#125; = error.response    // status = status + &#x27;&#x27;    // Message.error(errMsgObj[status])    const &#123; status &#125; = error.response    if (status === 400) &#123;      Message.error(&#x27;请求参数错误&#x27;)    &#125; else if (status === 401) &#123;      // token 无效(没有，过期，无效)      // 如果有 refresh_token ,则使用refresh_token获取新的 access_token      // 成功了 -&gt; 把本次失败的请求重新发出去      // 失败了 -&gt; 跳转登录页面重新登录获取新的 token      // 没有，则直接跳转登录页面      if (!store.state.user) &#123;        redirectLogin()        return Promise.reject(error)      &#125;      // 刷新 token      try &#123;        // 通过 axios.create() 发送请求，不用 request ,避免死循环        const &#123; data &#125; = await axios.create()(&#123;          method: &#x27;POST&#x27;,          url: &#x27;/front/user/refresh_token&#x27;,          data: qs.stringify(&#123;            refreshtoken: store.state.user.refresh_token          &#125;)        &#125;)        // 成功了 -&gt; 更新新的token,把本次失败的请求重新发出去        store.commit(&#x27;setUser&#x27;, data.content)        // error.config -&gt; 失败请求的配置信息        return request(error.config)      &#125; catch (err) &#123;        // 失败了 -&gt; 清除当前用户登录状态，跳转登录页面        store.commit(&#x27;setUser&#x27;, null)        redirectLogin()        return Promise.reject(error)      &#125;    &#125; if (status === 403) &#123;      Message.error(&#x27;没有权限，请联系管理员&#x27;)    &#125; if (status === 404) &#123;      Message.error(&#x27;请求资源不存在&#x27;)    &#125; if (status &gt;= 500) &#123;      Message.error(&#x27;服务端错误，请联系管理员&#x27;)    &#125;  &#125; else if (error.request) &#123; // 请求发出去了，但是没有收到响应    Message.error(&#x27;请求超时，请刷新重试&#x27;)  &#125; else &#123; // 请求的时候设置请求时发生了一些事情，触发了错误    Message.error(`请求失败：$&#123;error.message&#125;`)  &#125;  // 请求失败的错误对象抛出，扔给上一个调用者  return Promise.reject(error)&#125;)\n\n\n\n多次请求\n多个请求同时发，会触发多以请求刷新 Token\n\nrefresh 只能请求一次，不然会出错\n\n多个请求失败，只刷新一次 token ,重新请求 会把 其他的请求漏掉\n\n思路：定义一个数组，定义一个刷新状态，1. 如果是刷新状态，则将请求挂起存放到数组中（返回一个promise，数组中 push 一个回调函数，回调函数里调用 promise的resolve，resolve里真正触发请求发送），2. 如果是非刷新状态，则触发刷新 token请求，请求成功则遍历 requests 数组调用其回调函数，重置 requests 数组，重新发送当前失败请求\n\n\nfunction refreshToken() &#123;  return axios.create()(&#123;    method: &#x27;POST&#x27;,    url: &#x27;/front/user/refresh_token&#x27;,    data: qs.stringify(&#123;      refreshtoken: store.state.user.refresh_token    &#125;)  &#125;)&#125;// 响应拦截器let isRefreshing = false // 控制刷新 token 的状态let requests: any[] = [] // 存储刷新 token 期间过来的请求request.interceptors.response.use(function (response) &#123;  // 状态码为 2xx  // 如果是自定义状态码，错误处理就写到这里  return response&#125;, async function (error) &#123;  // 超出 2xx 状态码  // 如果是 HTTP 状态码，错误处理就写到这里  if (error.response) &#123; // 请求收到响应了，但是状态码 超出 2xx    // const errMsgObj = &#123;    //   &#x27;400&#x27;: &#x27;请求参数错误&#x27;,    //   &#x27;401&#x27;: &#x27;&#x27;,    //   &#x27;403&#x27;: &#x27;&#x27;,    //   &#x27;404&#x27;: &#x27;&#x27;,    //   &#x27;500&#x27;: &#x27;&#x27;    // &#125;    // let &#123; status &#125; = error.response    // status = status + &#x27;&#x27;    // Message.error(errMsgObj[status])    const &#123; status &#125; = error.response    if (status === 400) &#123;      Message.error(&#x27;请求参数错误&#x27;)    &#125; else if (status === 401) &#123;      // token 无效(没有，过期，无效)      // 如果有 refresh_token ,则使用refresh_token获取新的 access_token      // 成功了 -&gt; 把本次失败的请求重新发出去      // 失败了 -&gt; 跳转登录页面重新登录获取新的 token      // 没有，则直接跳转登录页面      if (!store.state.user) &#123;        redirectLogin()        return Promise.reject(error)      &#125;      // 目前没有在刷新 token ,则尝试刷新 token      if (!isRefreshing) &#123;        isRefreshing = true // 开启刷新状态        // 刷新 token        return refreshToken().then(res =&gt; &#123;          if (!res.data.success) &#123;            // 失败            throw new Error(&#x27;刷新 Token 失败&#x27;)          &#125;          // 成功了 -&gt; 更新新的token,把本次失败的请求重新发出去          store.commit(&#x27;setUser&#x27;, res.data.content)          // error.config -&gt; 失败请求的配置信息          // 把 requests 数组队列中的请求重新发出去          requests.forEach(cb =&gt; cb())          // 重置 requests 数组          requests = []          return request(error.config)        &#125;).catch(error =&gt; &#123;          // 失败了 -&gt; 清除当前用户登录状态，跳转登录页面          store.commit(&#x27;setUser&#x27;, null)          redirectLogin()          return Promise.reject(error)        &#125;).finally(() =&gt; &#123;          isRefreshing = false // 重置刷新状态        &#125;)      &#125;      // 刷新状态下，把请求挂起，放到 requests 数组中      return new Promise(resolve =&gt; &#123;        requests.push(() =&gt; &#123;          resolve(request(error.config))        &#125;)      &#125;)    &#125; if (status === 403) &#123;      Message.error(&#x27;没有权限，请联系管理员&#x27;)    &#125; if (status === 404) &#123;      Message.error(&#x27;请求资源不存在&#x27;)    &#125; if (status &gt;= 500) &#123;      Message.error(&#x27;服务端错误，请联系管理员&#x27;)    &#125;  &#125; else if (error.request) &#123; // 请求发出去了，但是没有收到响应    Message.error(&#x27;请求超时，请刷新重试&#x27;)  &#125; else &#123; // 请求的时候设置请求时发生了一些事情，触发了错误    Message.error(`请求失败：$&#123;error.message&#125;`)  &#125;  // 请求失败的错误对象抛出，扔给上一个调用者  return Promise.reject(error)&#125;)\n\n\n\n配置环境变量知识点：\n\n配置 Vue 项目中的环境变量\n[dotenv](GitHub - motdotla/dotenv: Loads environment variables from .env for nodejs projects.)\n\n.env.development\nVUE_APP_API=http://eduboss.lagou.com\n\n\n\n.env.production\nVUE_APP_API=http://eduboss.lagou.com\n\n\n\n用户权限\n菜单列表\n\n资源列表\n\n角色列表\n\n用户管理\n\n\n课程管理发布部署项目中遇到的问题vscode 关闭 单引号转换为 双引号的问题项目根目录 创建 .prettierrc.json文件\n&#123;  &quot;singleQuote&quot;: true,  &quot;semi&quot;: false&#125;\n\ncore-js 报错npm install core-js@3 --save\n\nTS 校验报错this.$refs.form.validate()\n\nProperty ‘validate’ does not exist on type ‘Vue | Element | (Vue | Element)[]’. \nProperty ‘validate’ does not exist on type ‘Vue’.\n解决方法：\n\n强制将 this.$refs.form 转换为 any 类型，不推荐\n(this.$refs.form as any).validate()\n标注正确的类型\nimport &#123; Form &#125; from &#x27;element-ui&#x27;(this.$refs.form as Form).validate()\n\n上传文件 及 上传进度条export const upload = (data: any, onUploadProgress: (progressEvent: ProgressEvent) =&gt; void) =&gt; &#123;  // 该接口要求的请求数据类型是 multipart/form-data  // 所以需要提交 FormData 数据对象  return request(&#123;    method: &#x27;POST&#x27;,    url: &#x27;/boss/course/upload&#x27;,    data,    // HTML5新增的上传响应事件 : progress    onUploadProgress  &#125;)&#125;\n\n\n\n&lt;!--1. 组件需要根据绑定的数据进行图片预览2. 组件需要把上传成功的图片地址同步到绑定的数据中v-model 的本质还是父子组件通信 给子组件传递一个 value 的数据 默认监听 input 事件，修改绑定的数据--&gt;&lt;template&gt;  &lt;div class=&quot;course-upload&quot;&gt;    &lt;el-progress v-if=&quot;isUploading&quot;                 type=&quot;circle&quot;                 :percentage=&quot;percentage&quot;                 :width=&quot;178&quot;                 :status=&quot;percentage === 100 ? &#x27;success&#x27; : undefined&quot;&gt;    &lt;/el-progress&gt;    &lt;el-upload v-else               class=&quot;avatar-uploader&quot;               action=&quot;/boss/course/upload&quot;               :http-request=&quot;handleUpload&quot;               :show-file-list=&quot;false&quot;               :before-upload=&quot;beforeAvatarUpload&quot;&gt;      &lt;img v-if=&quot;imageUrl&quot;           :src=&quot;imageUrl&quot;           class=&quot;avatar&quot;&gt;      &lt;i v-else         class=&quot;el-icon-plus avatar-uploader-icon&quot;&gt;&lt;/i&gt;    &lt;/el-upload&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;import Vue from &#x27;vue&#x27;import &#123; upload &#125; from &#x27;@/services/course&#x27;export default Vue.extend(&#123;  name: &#x27;CourseUpload&#x27;,  model: &#123;    prop: &#x27;imageUrl&#x27;,    event: &#x27;update&#x27;  &#125;,  props: &#123;    imageUrl: &#123;      type: String    &#125;,    limit: &#123;      type: Number,      default: 2    &#125;  &#125;,  data() &#123;    return &#123;      isUploading: false,      percentage: 0    &#125;  &#125;,  methods: &#123;    beforeAvatarUpload(file: any) &#123;      const isJPG = file.type === &#x27;image/jpeg&#x27;      const isLt2M = file.size / 1024 / 1024 &lt; this.limit      if (!isJPG) &#123;        this.$message.error(&#x27;上传头像图片只能是 JPG 格式!&#x27;)      &#125;      if (!isLt2M) &#123;        this.$message.error(`上传头像图片大小不能超过 $&#123;this.limit&#125;MB!`)      &#125;      return isJPG &amp;&amp; isLt2M    &#125;,    async handleUpload(options: any) &#123;      try &#123;        this.isUploading = true        const fd = new FormData()        fd.append(&#x27;file&#x27;, options.file)        const &#123; data &#125; = await upload(fd, e =&gt; &#123;          this.percentage = Math.floor((e.loaded / e.total) * 100)        &#125;)        if (data.code === &#x27;000000&#x27;) &#123;          this.$emit(&#x27;update&#x27;, data.data.name)        &#125;        this.isUploading = false        this.percentage = 0      &#125; catch (e) &#123;        this.isUploading = false      &#125;    &#125;  &#125;&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.course-upload &#123;  ::v-deep .avatar-uploader .el-upload &#123;    border: 1px dashed #d9d9d9;    border-radius: 6px;    cursor: pointer;    position: relative;    overflow: hidden;  &#125;  ::v-deep .avatar-uploader .el-upload:hover &#123;    border-color: #409eff;  &#125;  .avatar-uploader-icon &#123;    font-size: 28px;    color: #8c939d;    width: 178px;    height: 178px;    line-height: 178px;    text-align: center;  &#125;  .avatar &#123;    width: 178px;    height: 178px;    display: block;  &#125;&#125;&lt;/style&gt;\n\n\n\n富文本编辑器\nwangeditor https://www.wangeditor.com/\n基于javascript和css开发的 Web富文本编辑器， 轻量、简洁、界面美观、易用、开源免费。\n\nTinyMCE https://www.tiny.cloud/docs/demo/full-featured/\nTinyMCE是一个轻量级的基于浏览器的所见即所得编辑器，由JavaScript写成。它对IE6+和Firefox1.5+都有着非常良好的支持。功能齐全，界面美观，就是文档是英文的，对开发人员英文水平有一定要求。\n\n百度ueditor https://github.com/fex-team/ueditor\nUEditor是由百度web前端研发部开发所见即所得富文本web编辑器，具有轻量，功能齐全，可定制，注重用户体验等特点，开源基于MIT协议，允许自由使用和修改代码，缺点是已经没有更新了\n\nkindeditor http://kindeditor.net/demo.php\n界面经典。\n\nTextbox https://www.textbox.io/\nTextbox是一款极简但功能强大的在线文本编辑器，支持桌面设备和移动设备。主要功能包含内置的图像处理和存储、文件拖放、拼写检查和自动更正。此外，该工具还实现了屏幕阅读器等辅助技术，并符合WAI-ARIA可访问性标准。\n\nCKEditor https://ckeditor.com/ckeditor-5/demo/\n国外的，界面美观。\n\nquill https://quilljs.com/\n功能强大，还可以编辑公式等\n\nmedium-editor https://yabwe.github.io/medium-editor/\nhttps://github.com/yabwe/medium-editor\n\nsimditor https://simditor.tower.im/\n界面美观，功能较全。（个人博客考虑使用）\n\n**summernote **https://summernote.org/\nUI好看，精美\n\njodit https://xdsoft.net/jodit/\n功能齐全\n\nEditor.md https://pandao.github.io/editor.md/\n功能非常丰富的编辑器，左端编辑，右端预览，非常方便，完全免费\n\nfroala Editorhttps://froala.com/wysiwyg-editor/\n界面非常好看，功能非常强大，非常好用（非免费，可破解）\n\nsyncfusion https://ej2.syncfusion.com/react/demos/#/material/rich-text-editor/tools\n\ndhtmlxEditor https://dhtmlx.com/docs/products/dhtmlxRichText/\n\nbootstrap-wysiwyg https://www.zybuluo.com/mdeditor\nbootstrap-wysiwyg是基于Bootstrap的轻型、免费开源的富文本编辑器，界面简洁大方。使用需要先引入bootstrap。\n\neWebEditor http://www.ewebeditor.net/demo/\neWebEditor外观和使用风格都和微软 Word很类似，功能很多。工具条可以定制，运行速度很快。导入文件接口很多，支持word、excel、pdf、ppt直接导入，目前版本不支持代码高亮，不适合纯技术平台使用，适合内容编辑人员使用\n\n\n比较推荐：不在维护的项目不介意使用\n\nCKEditor\nquill\nmedium-editor\nwangeditor\nueditor\ntinymce\n\n拖拽排序element tree 树形组件\n图片压缩compressorjs https://fengyuanchen.github.io/compressorjs/\n阿里云视频点播https://help.aliyun.com/\n测试的阿里云账号ID：1618139964448548\nts 扩展 window 数据类型shims-vue.d.ts\ndeclare module &#x27;*.vue&#x27; &#123;  import Vue from &#x27;vue&#x27;  export default Vue&#125;interface Window &#123;  AliyunUpload: any&#125;\n\n将诸如路径字符串/user/:name转换为正则表达式。npm install path-to-regexp --save\n\nconst &#123; pathToRegexp, match, parse, compile &#125; = require(&quot;path-to-regexp&quot;); // pathToRegexp(path, keys?, options?)// match(path)// parse(path)// compile(path)\n\n按需加载插件\n安装依赖 npm install babel-plugin-dynamic-import-node -S -D\n在 babel.config.js 中添加插件\n\nmodule.exports = &#123;  presets: [&#x27;@vue/cli-plugin-babel/preset&#x27;],  env: &#123;    development: &#123;      plugins: [&#x27;dynamic-import-node&#x27;]    &#125;  &#125;&#125;\n\n\n\nvue cli 打包部署本地预览dist 目录需要启动一个 HTTP 服务器来访问\n\n使用一个 Node.js 静态文件服务器，例如 serve\nnpm install -g serve# -s 参数的意思是将其架设在 Single-Page Application 模式下# 这个模式会处理即将提到的路由问题serve -s dist\n\n问题：接口跨域\n\n自己搭建服务器\nconst express = require(&#x27;express&#x27;)const app = express()const path = require(&#x27;path&#x27;)// 托管 dist 目录，当访问 / 的时候，默认返回托管目录中的 index.html 文件app.use(express.static(path.join(__dirname, &#x27;../dist&#x27;)))app.listen(3000, () =&gt; &#123;  console.log(&#x27;running~~&#x27;)&#125;)\n\n问题：接口跨域\n解决：http-proxy-middleware中间件代理\nnpm install --save-dev http-proxy-middleware\n\nconst express = require(&#x27;express&#x27;)const app = express()const path = require(&#x27;path&#x27;)const &#123;  createProxyMiddleware&#125; = require(&#x27;http-proxy-middleware&#x27;);// 托管 dist 目录，当访问 / 的时候，默认返回托管目录中的 index.html 文件app.use(express.static(path.join(__dirname, &#x27;../dist&#x27;)))app.use(&#x27;/boss&#x27;, createProxyMiddleware(&#123;  target: &#x27;http://eduboss.lagou.com&#x27;,  changeOrigin: true&#125;));app.use(&#x27;/front&#x27;, createProxyMiddleware(&#123;  target: &#x27;http://edufront.lagou.com&#x27;,  changeOrigin: true&#125;));app.listen(3000, () =&gt; &#123;  console.log(&#x27;running~~&#x27;)&#125;)\n\n// package.json &quot;preview&quot;: &quot;node test-serve/app.js&quot;\n\n","categories":["vue","项目实战"],"tags":["vue"]}]